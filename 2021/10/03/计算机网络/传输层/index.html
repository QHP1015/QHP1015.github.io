<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">



  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/notes32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/notes16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"note.qhp.us","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="概述和传输层服务传输服务和协议  为运行在不同主机上的应用进程提供逻辑通信 传输协议运行在端系统 发送方：将应用层的报文分成报文段，然后传递给网络层 接收方：将报文段重组成报文，然后传递给应用层   有多个传输层协议可供应用选择 Internet：TCP和UDP">
<meta property="og:type" content="article">
<meta property="og:title" content="传输层">
<meta property="og:url" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/index.html">
<meta property="og:site_name" content="从此在回忆里">
<meta property="og:description" content="概述和传输层服务传输服务和协议  为运行在不同主机上的应用进程提供逻辑通信 传输协议运行在端系统 发送方：将应用层的报文分成报文段，然后传递给网络层 接收方：将报文段重组成报文，然后传递给应用层   有多个传输层协议可供应用选择 Internet：TCP和UDP">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820075814869.png">
<meta property="og:image" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820080351026.png">
<meta property="og:image" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820080540803.png">
<meta property="og:image" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820081615213.png">
<meta property="og:image" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820082340128.png">
<meta property="og:image" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820082514757.png">
<meta property="og:image" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820083417442.png">
<meta property="og:image" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820083926717.png">
<meta property="og:image" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820084716025.png">
<meta property="og:image" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820084743656.png">
<meta property="og:image" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820084813574.png">
<meta property="og:image" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820090145229.png">
<meta property="og:image" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820090616698.png">
<meta property="og:image" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820090917997.png">
<meta property="og:image" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820091837025.png">
<meta property="og:image" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820092208134.png">
<meta property="og:image" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820095627060.png">
<meta property="og:image" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820095652709.png">
<meta property="og:image" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820104619583.png">
<meta property="og:image" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820161745890.png">
<meta property="og:image" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820161805269.png">
<meta property="og:image" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820211326552.png">
<meta property="og:image" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820211512381.png">
<meta property="og:image" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820212852535.png">
<meta property="og:image" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210821080358267.png">
<meta property="og:image" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210821081124973.png">
<meta property="og:image" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210821081546986.png">
<meta property="og:image" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210821082126992.png">
<meta property="og:image" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210821082535145.png">
<meta property="og:image" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210821082948105.png">
<meta property="og:image" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20211228184915293.png">
<meta property="og:image" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210821091932885.png">
<meta property="og:image" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210821094010456.png">
<meta property="article:published_time" content="2021-10-03T06:17:21.000Z">
<meta property="article:modified_time" content="2022-01-05T01:17:02.897Z">
<meta property="article:author" content="从此在回忆里">
<meta property="article:tag" content="大学课程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820075814869.png">


<link rel="canonical" href="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/","path":"2021/10/03/计算机网络/传输层/","title":"传输层"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>传输层 | 从此在回忆里</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">从此在回忆里</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fab fa-themeisle fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fas fa-pallet fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0%E5%92%8C%E4%BC%A0%E8%BE%93%E5%B1%82%E6%9C%8D%E5%8A%A1"><span class="nav-text">概述和传输层服务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-%E8%A7%A3%E5%A4%8D%E7%94%A8"><span class="nav-text">多路复用&#x2F;解复用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E8%BF%9E%E6%8E%A5%E4%BC%A0%E8%BE%93%EF%BC%9AUDP"><span class="nav-text">无连接传输：UDP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%EF%BC%88rdt%EF%BC%89%E5%8E%9F%E7%90%86"><span class="nav-text">可靠数据传输（rdt）原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93%EF%BC%9ATCP"><span class="nav-text">面向连接的传输：TCP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%EF%BC%9A%E6%A6%82%E8%BF%B0"><span class="nav-text">TCP：概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="nav-text">可靠数据传输</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-text">流量控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="nav-text">连接管理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86"><span class="nav-text">拥塞控制原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E5%8E%9F%E5%9B%A0%E4%B8%8E%E4%BB%A3%E4%BB%B7"><span class="nav-text">拥塞原因与代价</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95"><span class="nav-text">拥塞控制方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-text">TCP拥塞控制</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <a target="_blank" rel="noopener" href="https://qhp.us">
    <img class="site-author-image" itemprop="image" alt="从此在回忆里"
      src="/images/avatar.gif">
  </a>
  <p class="site-author-name" itemprop="name">从此在回忆里</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/QHP1015" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;QHP1015" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/2439462872@qq.com" title="E-Mail → 2439462872@qq.com"><i class="fas fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://note.qhp.us/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="从此在回忆里">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="从此在回忆里">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          传输层
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-03 14:17:21" itemprop="dateCreated datePublished" datetime="2021-10-03T14:17:21+08:00">2021-10-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-01-05 09:17:02" itemprop="dateModified" datetime="2022-01-05T09:17:02+08:00">2022-01-05</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="概述和传输层服务"><a href="#概述和传输层服务" class="headerlink" title="概述和传输层服务"></a>概述和传输层服务</h2><p>传输服务和协议</p>
<ul>
<li>为运行在不同主机上的应用进程提供逻辑通信</li>
<li>传输协议运行在端系统<ul>
<li>发送方：将应用层的报文分成报文段，然后传递给网络层</li>
<li>接收方：将报文段重组成报文，然后传递给应用层</li>
</ul>
</li>
<li>有多个传输层协议可供应用选择<ul>
<li>Internet：TCP和UDP</li>
</ul>
</li>
</ul>
<span id="more"></span>

<p>传输层与网络层的关系</p>
<ul>
<li><p>网络层服务：主机之间的逻辑通信</p>
</li>
<li><p>传输层服务：进程间的逻辑通信</p>
<ul>
<li><p>依赖于网络层的服务</p>
<ul>
<li>延时、带宽</li>
</ul>
</li>
<li><p>对网络层的服务进行增强</p>
<ul>
<li><p>数据丢失、顺序混乱</p>
</li>
<li><p>加密</p>
<blockquote>
<p>有些服务是可以加强的：不可靠 -&gt; 可靠；安全 </p>
<p>但有些服务是不可以被加强的：带宽，延迟</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Internet传输层协议</p>
<ul>
<li><p>可靠的、保序的传输：TCP</p>
<ul>
<li>多路复用、解复用</li>
<li>拥塞控制</li>
<li>流量控制</li>
<li>建立连接</li>
</ul>
</li>
<li><p>不可靠、不保序的传输：UDP</p>
<ul>
<li><p>多路复用、解复用</p>
</li>
<li><p>没有为尽力而为的IP服务添加更多的其它额外服务</p>
<blockquote>
<p>IP的服务模型为尽力而为交付服务（best-effort delivery service），即IP尽“最大努力”在通信主机之间交付报文段，但不做任何确保。因此IP被称为不可靠服务（unreliable service）</p>
</blockquote>
</li>
</ul>
</li>
<li><p>都不提供的服务</p>
<ul>
<li>延时保证</li>
<li>带宽保证</li>
</ul>
</li>
</ul>
<h2 id="多路复用-解复用"><a href="#多路复用-解复用" class="headerlink" title="多路复用/解复用"></a>多路复用/解复用</h2><p> 在发送方主机多路复用：从多个套接字接收来自多个进程的报文，根据套接字对应的IP地址和端口号等信息对报文段用头部加以封装 (该头部信息用于以后的解复用)</p>
<p>在接收方主机多路解复用：根据报文段的头部信息中的IP地址和端口号将接收到的报文段发给正确的套接字(和对应的应用进程)</p>
<p>多路解复用工作原理</p>
<ul>
<li>解复用作用：TCP或者UDP实体采用哪些信息，将报文段的数据部分交给正确的socket，从而交给正确的进程</li>
<li>主机收到IP数据报<ul>
<li>每个数据报有源IP地址和目标地址</li>
<li>每个数据报承载一个传输层报文段</li>
<li>每个报文段有一个源端口号和目标端口号 (特定应用有著名的端口号) </li>
</ul>
</li>
<li>主机联合使用IP地址和端口号将报文段发送给合适的套接字</li>
</ul>
<p>无连接(UDP)多路解复用</p>
<ol>
<li>创建套接字</li>
<li>在接收端，UDP套接字用二元组标识 (目标IP地址、目标端口号)</li>
<li>当主机收到UDP报文段<ul>
<li>检查报文段的目标端口号</li>
<li>用该端口号将报文段定位给套接字</li>
</ul>
</li>
<li>如果两个不同源IP地址/源端口号的数据报，但是有相同的目标IP地址和端口号，则被定位到相同的套接字</li>
</ol>
<p>面向连接(TCP)的多路复用</p>
<ul>
<li>TCP套接字:四元组本地标识<ul>
<li>源IP地址</li>
<li>源端口号</li>
<li>目的IP地址</li>
<li>目的端口号</li>
</ul>
</li>
<li>解复用：接收主机用这四个值来将数据报定位到合适的套接字</li>
<li>服务器能够在一个TCP 端口上同时支持多个TCP套接字<ul>
<li>每个套接字由其四元组标识（有不同的源IP和源Port）</li>
</ul>
</li>
<li>Web服务器对每个连接客户端有不同的套接字<ul>
<li>非持久对每个请求有不同的套接字</li>
</ul>
</li>
</ul>
<p>面向连接的多路复用：多线程Web Server</p>
<ul>
<li>一个进程下面可能有多个线程：由多个线程分别为客户提供服务</li>
<li>在这个场景下，还是根据4元组决定将报文段内容划分在同一个进程下的不同线程</li>
<li>解复用到不同线程</li>
</ul>
<h2 id="无连接传输：UDP"><a href="#无连接传输：UDP" class="headerlink" title="无连接传输：UDP"></a>无连接传输：UDP</h2><p>“尽力而为”的服务，报文段可能<strong>丢失</strong>或<strong>送到应用进程的报文段乱序</strong></p>
<p>无连接特点</p>
<ul>
<li>UDP发送端和接收端之间没有握手</li>
<li>每个UDP报文段都被独立地处理</li>
</ul>
<p>UDP 被用于流媒体（丢失不敏感， 速率敏感、应用可控制传输速率）、DNS、SNMP</p>
<p>在UDP上可行可靠传输，则</p>
<ul>
<li>在应用层增加可靠性</li>
<li>应用特定的差错恢复</li>
</ul>
<p><strong>UDP报文段格式：</strong></p>
<p>![流程图 (2)](传输层/流程图 (2)-16406727379761.png)</p>
<p><strong>UDP存在的必要性</strong></p>
<ul>
<li>不建立连接（会增加延时 ）</li>
<li>简单：在发送端和接收端没有连接状态</li>
<li>报文段的头部很小（开销小）</li>
<li>无拥塞控制和流量控制：UDP可以尽可能快的发送报文段</li>
</ul>
<p><strong>UDP校验和</strong></p>
<p>目标： 检测在被传输报文段中的差错（如比特反转）</p>
<p>发送方</p>
<ul>
<li>将报文段的内容视为16比特的整数</li>
<li>校验和：报文段的加法和（1的补运算）</li>
<li>发送方将校验和放 UDP的校验和字段</li>
</ul>
<p>接收方</p>
<ul>
<li>计算接收到的报文段的校验和</li>
<li>检查计算出的校验和与校验和字段的内容是否相等<ul>
<li>不相等––检测到差错</li>
<li>相等––没有检测到差错 ，但也许还是有差错，如残存错误</li>
</ul>
</li>
</ul>
<p>校验和的计算：</p>
<ul>
<li>当数字相加时，在最高位的进位要回卷，再加到结果上</li>
<li>最终得到的检验码是计算的反码</li>
<li>目标端：校验范围+校验和=1111111111111111 则通过校验</li>
</ul>
<h2 id="可靠数据传输（rdt）原理"><a href="#可靠数据传输（rdt）原理" class="headerlink" title="可靠数据传输（rdt）原理"></a>可靠数据传输（rdt）原理</h2><p>rdt（可靠数据传输协议）在应用层、传输层和数据链路层都很重要</p>
<p>信道的不可靠特点决定了可靠数据传输协议的复杂性</p>
<p>服务实现模型：</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820075814869.png" alt="image-20210820075814869"></p>
<p>可靠数据传输：问题描述</p>
<ul>
<li><p>渐增式地开发可靠数据传输协议（ rdt ）的发送方和接收方</p>
</li>
<li><p>只考虑单向数据传输，但控制信息是双向流动的</p>
</li>
<li><p>双向的数据传输问题实际上是2个单向数据传输问题的综合</p>
</li>
<li><p>使用有限状态机 (FSM) 来描述发送方和接收方</p>
<blockquote>
<p>有限状态机是一种描述形式</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820080351026.png" alt="image-20210820080351026"></p>
</blockquote>
</li>
</ul>
<p>Rdt1.0： 在可靠信道上的可靠数据传输</p>
<ul>
<li><p>下层的信道是完全可靠的</p>
<ul>
<li>没有比特出错</li>
<li>没有分组丢失</li>
</ul>
</li>
<li><p>发送方和接收方的FSM</p>
<ul>
<li><p>发送方将数据封装发送到下层信道</p>
</li>
<li><p>接收方从下层信道接收数据，解封装</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820080540803.png" alt="image-20210820080540803"></p>
</li>
</ul>
</li>
</ul>
<p>Rdt2.0：具有比特差错的信道</p>
<ul>
<li><p>下层信道可能会出错：将分组中的比特翻转</p>
<ul>
<li>用校验和来检测比特差错</li>
</ul>
</li>
<li><p>问题：怎样从差错中恢复</p>
<ul>
<li>确认（ACK）：接收方显式地告诉发送方分组已被正确接收</li>
<li>否定确认（NAK）: 接收方显式地告诉发送方分组发生了差错<ul>
<li>发送方收到NAK后，发送方重传分组</li>
</ul>
</li>
</ul>
</li>
<li><p>rdt2.0中的新机制：采用差错控制编码进行差错检测</p>
<ul>
<li>发送方差错控制编码、缓存</li>
<li>接收方使用编码检错</li>
<li>接收方的反馈：控制报文（ACK，NAK），由接收方发给发送方</li>
<li>发送方收到反馈相应的动作</li>
</ul>
</li>
<li><p>基于这样重传机制的可靠数据传输协议称为自动重传请求（ARQ）协议</p>
</li>
<li><p>FSM描述</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820081615213.png" alt="image-20210820081615213"></p>
</li>
</ul>
<p>rdt2.0存在致命缺陷则 -&gt; rdt2.1</p>
<p>如果ACK/NAK出错？</p>
<ul>
<li>发送方不知道接收方发生了什么事情</li>
<li>发送方如何做<ul>
<li>若重传可能重复</li>
<li>若不重传可能死锁(或出错) </li>
</ul>
</li>
<li>需要引入新的机制：序号</li>
</ul>
<p>处理重复</p>
<ul>
<li>发送方在每个分组中加入序号</li>
<li>如果ACK/NAK出错，发送方重传当前分组</li>
<li>接收方丢弃（不发给上层）重复分组</li>
</ul>
<p>停止等待协议：发送方发送一个分组， 然后等待接收方的应答</p>
<p>FSM描述：</p>
<ul>
<li><p>发送方处理出错的ACK/NAK</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820082340128.png" alt="image-20210820082340128"></p>
</li>
<li><p>接收方处理出错的ACK/NAK</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820082514757.png" alt="image-20210820082514757"></p>
</li>
</ul>
<p>rdt2.1发送方</p>
<ul>
<li>在分组中加入序列号</li>
<li>两个序列号（0，1）就足够了<ul>
<li>一次只发送一个未经确认的分组</li>
</ul>
</li>
<li>必须检测ACK/NAK是否出错（需要EDC）</li>
<li>状态数变成了两倍<ul>
<li>必须记住当前分组的序列号为0还是1</li>
</ul>
</li>
</ul>
<p>rdt2.1接收方</p>
<ul>
<li>必须检测接收到的分组是否是重复的<ul>
<li>状态会指示希望接收到的分组的序号为0还是1</li>
</ul>
</li>
<li>注意：接收方并不知道发送方是否正确收到了其ACK/NAK<ul>
<li>没有安排确认的确认</li>
</ul>
</li>
</ul>
<p>rdt2.1运行过程：</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820083417442.png" alt="image-20210820083417442"></p>
<p>接收方不知道它最后发送的ACK/NAK是否被正确地收到</p>
<ul>
<li>发送方不对收到的ack/nak给确认，没有所谓的确认的确认</li>
<li>接收方发送ack，如果后面接收方收到的是<ul>
<li>老分组p0，则ack 错误</li>
<li>下一个分组P1，则ack正确</li>
</ul>
</li>
</ul>
<p>rdt2.2：无NAK（NAK free）的协议</p>
<ul>
<li><p>功能同rdt2.1，但只使用ACK(ack 要编号）</p>
</li>
<li><p>接收方对<strong>最后</strong>正确接收的分组发ACK，以替代NAK</p>
<ul>
<li>接收方必须显式地包含被正确接收分组的序号</li>
</ul>
</li>
<li><p>当收到重复的ACK（如：再次收到ack0）时，发送方与收到NAK采取相同的动作：重传当前分组</p>
</li>
<li><p>为后面的一次发送多个数据单位做一个准备</p>
<ul>
<li>一次能够发送多个</li>
<li>使用对前一个数据单位的ACK，代替本数据单位的NAK</li>
<li>确认信息减少一半，协议处理简单</li>
</ul>
</li>
<li><p>运行过程</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820083926717.png" alt="image-20210820083926717"></p>
</li>
</ul>
<p>rdt3.0：具有比特差错和分组丢失的信道</p>
<p>问题：若下层信道可能会丢失分组（数据或ACK）</p>
<p>解决方法：发送方等待ACK一段合理的时间</p>
<blockquote>
<p>链路层的timeout时间确定的 </p>
<p>传输层timeout时间是适应式的</p>
</blockquote>
<ul>
<li>发送端超时重传：如果到时没有收到ACK则重传</li>
<li>问题：如果分组（或ACK ）只是被延迟了<ul>
<li>重传将会导致数据重复，但利用序列号可以处理这个问题</li>
<li>接收方必须指明被正确接收的序列号</li>
</ul>
</li>
<li>需要一个倒计数定时器</li>
</ul>
<p>rdt3.0发送方FSM描述：</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820084716025.png" alt="image-20210820084716025"></p>
<p>rdt3.0运行过程</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820084743656.png" alt="image-20210820084743656"></p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820084813574.png" alt="image-20210820084813574"></p>
<ul>
<li>过早超时（延迟的ACK）也能够正常工作；但是效率较低，一半的分组和确认是重复的</li>
<li>设置一个合理的超时时间是比较重要的</li>
</ul>
<p><strong>rdt3.0的性能</strong></p>
<p>rdt3.0可以工作，但链路容量比较大的情况下，性能很差</p>
<ul>
<li>链路容量比较大，一次发一个PDU的不能够充分利用链路的传输能力</li>
</ul>
<p><br><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820090145229.png" alt="image-20210820090145229"></p>
<ul>
<li><p>$U_{sender}$：利用率，即忙于发送的时间比例</p>
</li>
<li><p>每30ms发送1KB的分组 –&gt;270kbps=33.75kB/s 的吞吐量（在1Gbps 链路上）</p>
</li>
<li><p>瓶颈在于：网络协议限制了物理资源的利用</p>
</li>
<li><p>此例子体现了rdt3.0的停-等操作</p>
</li>
</ul>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820090616698.png" alt="image-20210820090616698"></p>
<ul>
<li><p>通过流水线提高链路利用率，下图展示同时发送3个分组的情况</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820090917997.png" alt="image-20210820090917997"></p>
<ul>
<li>增加n，能提高链路利用率</li>
<li>但当达到某个n，其u=100%时，无法再通过增加n，提高利用率</li>
<li>瓶颈变成了链路带宽</li>
</ul>
</li>
</ul>
<p><strong>流水线协议</strong></p>
<p>流水线：允许发送方在未得到对方确认的情况下一次发送多个分组</p>
<ul>
<li>必须增加序号的范围：用多个bit表示分组的序号</li>
<li>在发送方/接收方要有缓冲区<ul>
<li>发送方缓冲：未得到确认，可能需要重传</li>
<li>接收方缓存：上层用户取用数据的速率≠接收到的数据速率；接收到的数据可能乱序，排序交付（可靠）</li>
</ul>
</li>
<li>两种通用的流水线协议：回退N步（GBN）和选择重传（SR）</li>
</ul>
<p>滑动窗口（slide window）协议</p>
<ul>
<li><p>发送缓冲区</p>
<ul>
<li>形式：内存中的一个区域，落入缓冲区的分组可以发送</li>
<li>功能：用于存放已发送，但是没有得到确认的分组</li>
<li>必要性：需要重发时可用</li>
</ul>
</li>
<li><p>发送缓冲区的大小：一次最多可以发送多少个未经确认的分组</p>
<ul>
<li>停止等待协议=1</li>
<li>流水线协议&gt;1，合理的值，不能很大，链路利用率不能够超100%</li>
</ul>
</li>
<li><p>发送缓冲区中的分组</p>
<ul>
<li>未发送的：落入发送缓冲区的分组，可以连续发送出去</li>
<li>已经发送出去的、等待对方确认的分组：发送缓冲区的分组只有得到确认才能删除</li>
</ul>
</li>
<li><p>发送窗口：发送缓冲区内容的一个范围</p>
<ul>
<li>那些已发送但是未经确认分组的序号构成的空间</li>
</ul>
</li>
<li><p>发送窗口的最大值&lt;=发送缓冲区的值</p>
</li>
<li><p>一开始：没有发送任何一个分组</p>
<ul>
<li>后沿=前沿</li>
<li>之间为发送窗口的尺寸=0</li>
</ul>
</li>
<li><p>每发送一个分组，前沿前移一个单位；发送窗口前沿移动的极限：不能够超过发送缓冲区</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820091837025.png" alt="image-20210820091837025"></p>
</li>
<li><p>发送窗口后沿移动</p>
<ul>
<li><p>条件：收到老分组的确认</p>
</li>
<li><p>结果：发送缓冲区罩住新的分组，来了分组可以发送</p>
</li>
<li><p>移动的极限：不能够超过前沿</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820092208134.png" alt="image-20210820092208134"></p>
</li>
</ul>
</li>
<li><p>接收窗口（Receiving Window）= 接收缓冲区</p>
<ul>
<li>接收窗口用于控制哪些分组可以接收<ul>
<li>只有收到的分组序号落入接收窗口内才允许接收</li>
<li>若序号在接收窗口之外，则丢弃</li>
</ul>
</li>
<li>接收窗口尺寸RW=1，则只能顺序接收，即GBN协议</li>
<li>接收窗口尺寸RW&gt;1 ，则可以乱序接收，但提交给上层的分组，要按序，即SR协议</li>
</ul>
</li>
<li><p>接收窗口的滑动和发送确认</p>
<ul>
<li><p>滑动</p>
<ul>
<li><p>低序号的分组到来，接收窗口移动</p>
</li>
<li><p>高序号分组乱序到，缓存但不交付（因为要实现rdt，不允许失序），不滑动</p>
</li>
</ul>
</li>
<li><p>发送确认</p>
<ul>
<li>接收窗口尺寸=1 ； 发送连续收到的最大的分组确认（累计确认）</li>
<li>接收窗口尺寸&gt;1 ； 收到分组，发送那个分组的确认（非累计确认）</li>
</ul>
</li>
</ul>
</li>
<li><p>正常情况下的2个窗口互动</p>
<ul>
<li>发送窗口<ul>
<li>有新的分组落入发送缓冲区范围，发送且前沿滑动</li>
<li>来了老的低序号分组的确认-&gt;后沿向前滑动-&gt;新的分组可以落入发送缓冲区的范围</li>
</ul>
</li>
<li>接收窗口<ul>
<li>收到分组，落入到接收窗口范围内，接收</li>
<li>是低序号，发送确认给对方</li>
</ul>
</li>
<li>发送端上面来了分组-&gt;发送窗口滑动-&gt;接收窗口滑动-&gt;发确认</li>
</ul>
</li>
<li><p>异常情况下GBN的2窗口互动</p>
<ul>
<li>发送窗口<ul>
<li>新分组落入发送缓冲区范围，发送-&gt;前沿滑动</li>
<li>超时重发机制让发送端将发送窗口中的所有分组发送出去</li>
<li>来了老分组的重复确认-&gt;后沿不向前滑动-&gt;新的分组无法落入发送缓冲区的范围（此时如果发送缓冲区有新的分组可以发送）</li>
</ul>
</li>
<li>接收窗口<ul>
<li>收到乱序分组，没有落入到接收窗口范围内，抛弃</li>
<li>（重复）发送老分组的确认，累计确认；</li>
</ul>
</li>
</ul>
</li>
<li><p>异常情况下SR的2窗口互动</p>
<ul>
<li>发送窗口<ul>
<li>新分组落入发送缓冲区范围，发送-&gt;前沿滑动</li>
<li>超时重发机制让发送端将超时的分组重新发送出去</li>
<li>来了乱序分组的确认-&gt;后沿不向前滑动-&gt;新的分组无法落入发送缓冲区的范围（此时如果发送缓冲区有新的分组可以发送）</li>
</ul>
</li>
<li>接收窗口<ul>
<li>收到乱序分组，落入到接收窗口范围内，接收</li>
<li>发送该分组的确认，单独确认；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>GBN协议和SR协议的异同</p>
<ul>
<li>相同之处<ul>
<li>发送窗口&gt;1</li>
<li>一次能够可发送多个未经确认的分组</li>
</ul>
</li>
<li>不同之处<ul>
<li>GBN :接收窗口尺寸=1<ul>
<li>接收端：只能顺序接收</li>
<li>发送端：从表现来看，一旦一个分组没有发成功，如：0,1,2,3,4  ; 假如1未成功，234都发送出去了，要返回1再发送；GB1</li>
</ul>
</li>
<li>SR: 接收窗口尺寸&gt;1<ul>
<li>接收端：可以乱序接收</li>
<li>发送端：发送0,1,2,3,4，一旦1未成功，2,3,4,已发送，无需重发，选择性发送1</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>流水线协议总结</p>
<ul>
<li>Go-back-N<ul>
<li>发送端最多在流水线中有N个未确认的分组</li>
<li>接收端只是发送累计型确认cumulative ack<ul>
<li>接收端如果发现gap， 不确认新到来的分组</li>
</ul>
</li>
<li>发送端拥有对最老的 未确认分组的定时器<ul>
<li>只需设置一个定时器</li>
<li>当定时器到时时，重传所有未确认分组</li>
</ul>
</li>
</ul>
</li>
<li>Selective Repeat<ul>
<li>发送端最多在流水线中有N个未确认的分组</li>
<li>接收方对每个到来的分组单独确认individual ack （非累计确认）</li>
<li>发送方为每个未确认的分组保持一个定时器,当超时定时器到时，只重发到时的未确认分组</li>
</ul>
</li>
</ul>
<p>GBN：发送方扩展的FSM</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820095627060.png" alt="image-20210820095627060"></p>
<p>GBN：接收方扩展的FSM</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820095652709.png" alt="image-20210820095652709"></p>
<ul>
<li>只发送ACK：对顺序接收的最高序号的分组<ul>
<li>可能会产生重复的ACK</li>
<li>只需记住expectedseqnum；接收窗口=1，只一个变量就可表示接收窗口</li>
</ul>
</li>
<li>对乱序的分组<ul>
<li>丢弃（不缓存），在接收方不被缓存</li>
<li>对顺序接收的最高序号的分组进行确认——累计确认</li>
</ul>
</li>
</ul>
<p>选择重传SR</p>
<ul>
<li>接收方对每个正确接收的分组，分别发送 ACKn（非累积确认）<ul>
<li>接收窗口&gt;1，可以缓存乱序的分组</li>
<li>最终将分组按顺序交付给上层</li>
</ul>
</li>
<li>发送方只对那些没有收到ACK的分组进行重发-选择性重发<ul>
<li>发送方为每个未确认的分组设定一个定时器</li>
</ul>
</li>
<li>发送窗口的最大值（发送缓冲区）限制发送未确认分组的个数</li>
</ul>
<p>选择重传发送方：</p>
<ul>
<li><p>从上层接收数据，如果下一个可用于该分组的序号可在发送窗口中，则发送</p>
</li>
<li><p>timeout(n)：重新发送分组n，重新设定定时器 </p>
</li>
<li><p>ACK(n) in [sendbase,sendbase+N]：将分组n标记为已接收，如n为最小未确认的分组序号， 将base移到下一个未确认序号</p>
</li>
</ul>
<p>选择重传接收方：</p>
<ul>
<li>分组n [rcvbase, rcvbase+N-1]<ul>
<li>发送ACK(n)</li>
<li>乱序：缓存</li>
<li>有序：该分组及以前缓存的序号连续的分组交付给上层 ，然后将窗口移到下一个仍未被接收的分组</li>
</ul>
</li>
<li>分组n [rcvbase-N, rcvbase-1] <ul>
<li>发送ACK(n) </li>
</ul>
</li>
<li>其它：忽略该分组</li>
</ul>
<p>GBN和SR</p>
<table>
<thead>
<tr>
<th></th>
<th>GBN</th>
<th>SR</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>简单，所需资源少（接收方一个 缓存单元）</td>
<td>出错时，重传一个代价小</td>
</tr>
<tr>
<td>缺点</td>
<td>一旦出错，回退N步代价大</td>
<td>复杂，所需要资源多（接收方多个缓存单元）</td>
</tr>
</tbody></table>
<p>适用范围</p>
<ul>
<li>出错率低：比较适合GBN，出错非常罕见，没有必要用复杂的SR，为罕见的事件做日常的准备和复杂处理</li>
<li>链路容量大（延迟大、带宽大）：比较适合SR而不是GBN，一点出错代价太大</li>
</ul>
<p>窗口的最大尺寸，若存在n个分组</p>
<ul>
<li>GBN：$2^n-1$</li>
<li>SR：$2^{n-1}$</li>
</ul>
<h2 id="面向连接的传输：TCP"><a href="#面向连接的传输：TCP" class="headerlink" title="面向连接的传输：TCP"></a>面向连接的传输：TCP</h2><h3 id="TCP：概述"><a href="#TCP：概述" class="headerlink" title="TCP：概述"></a>TCP：概述</h3><ul>
<li>点对点：一个发送方，一个接收方</li>
<li>可靠的、按顺序的字节流<ul>
<li>没有报文边界</li>
</ul>
</li>
<li>管道化（流水线）<ul>
<li>TCP拥塞控制和流量控制设置窗口大小</li>
</ul>
</li>
<li>发送和接收缓存</li>
<li>全双工数据<ul>
<li>在同一连接中数据流双向流动</li>
<li>MSS：最大报文段大小</li>
</ul>
</li>
<li>面向连接<ul>
<li>在数据交换之前，通过握手（交换控制报文）初始化发送方、接收方的状态变量</li>
</ul>
</li>
<li>有流量控制<ul>
<li>发送方不会淹没接收方</li>
</ul>
</li>
</ul>
<p>TCP报文段格式：</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820104619583.png" alt="image-20210820104619583"></p>
<ul>
<li>序号<ul>
<li>报文段首字节的在字节流的编号</li>
</ul>
</li>
<li>确认号<ul>
<li>期望从另一方收到的下一个字节的序号</li>
<li>累积确认</li>
</ul>
</li>
</ul>
<p><strong>TCP往返延时（RTT）和超时</strong></p>
<p>怎样设置TCP超时</p>
<ul>
<li>比RTT要长，但RTT是变化的</li>
<li>太短：太早超时会造成不必要的重传</li>
<li>太长：对报文段丢失反应太慢，消极</li>
</ul>
<p>怎样估计RTT？</p>
<ul>
<li><p>SampleRTT：测量从报文段发出到收到确认的时间</p>
<ul>
<li>如果有重传，忽略此次测量</li>
</ul>
</li>
<li><p>SampleRTT会变化，因此估计的RTT应该比较平滑</p>
<ul>
<li><p>对几个最近的测量值求平均，而不是仅用当前的SampleRTT</p>
</li>
<li><p>$EstimatedRTT(SampleRTT均值) = (1-\alpha)\times EstimatedRTT + \alpha\times SampleRTT$</p>
<ul>
<li>指数加权移动平均（Exponential Weighted Moving Average，EWMA）</li>
<li>过去样本的影响呈指数衰减</li>
<li>推荐值：$\alpha= 0.125$</li>
</ul>
</li>
<li><p>SampleRTT会偏离EstimatedRTT多远，即偏差</p>
<p>$DevRTT =(1-\beta)\times DevRTT+\beta\times|SampleRTT-EstimatedRTT|$</p>
<ul>
<li>推荐值：$\beta= 0.25$</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>超时时间间隔设置为： $TimeoutInterval = EstimatedRTT + 4*DevRTT$，初始设置为1s</p>
<h3 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h3><ul>
<li>TCP在IP不可靠服务的基础上建立了rdt<ul>
<li>管道化的报文段<ul>
<li>GBN or SR</li>
</ul>
</li>
<li>累积确认（像GBN）</li>
<li>单个重传定时器（像GBN）</li>
<li>对于乱序的，没有规范，可以丢弃或缓存</li>
</ul>
</li>
<li>通过以下事件触发重传<ul>
<li>超时（只重发那个最早的未确认段：SR）</li>
<li>快速重传：重复的确认，如收到了ACK50，之后又收到3个ACK50</li>
</ul>
</li>
</ul>
<p>首先考虑简化的TCP发送方</p>
<ul>
<li>忽略重复的确认</li>
<li>忽略流量控制和拥塞控制</li>
</ul>
<p>TCP发送方事件：</p>
<ul>
<li>从应用层接收数据<ul>
<li>用nextseq创建报文段</li>
<li>序号nextseq为报文段首字节的字节流编号</li>
<li>如果还没有运行，启动定时器<ul>
<li>定时器与最早未确认的报文段关联</li>
<li>过期间隔： TimeOutInterval </li>
</ul>
</li>
</ul>
</li>
<li>超时<ul>
<li>重传后沿最老的报文段</li>
<li>重新启动定时器 </li>
</ul>
</li>
<li>收到确认<ul>
<li>如果是对尚未确认的报文段确认<ul>
<li>更新已被确认的报文序号</li>
<li>如果当前还有未被确认的报文段，重新启动定时器</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>TCP重传情况：</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820161745890.png" alt="image-20210820161745890"></p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820161805269.png" alt="image-20210820161805269"></p>
<p>快速重传</p>
<ul>
<li><p>超时周期往往太长</p>
<ul>
<li>在重传丢失报文段之前的延时太长</li>
</ul>
</li>
<li><p>通过重复的ACK来检测报文段丢失</p>
<ul>
<li>发送方通常连续发送大量报文段</li>
<li>如果报文段丢失，通常会引起多个重复的ACK</li>
</ul>
</li>
<li><p>如果发送方收到同一数据的3个冗余ACK，重传最小序号的段</p>
<ul>
<li>快速重传：在定时器过时之前重发报文段</li>
<li>它假设跟在被确认的数据后面的数据丢失了<ul>
<li>第一个ACK是正常的</li>
<li>收到第二个该段的ACK，表示接收方收到一个该段后的乱序段</li>
<li>收到第3，4个该段的ack，表示接收方收到该段之后的2个 ，3个乱序段，段丢失可能性非常大</li>
</ul>
</li>
</ul>
</li>
<li><p>算法</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">event: ACK received, with ACK field value of y </span><br><span class="line"><span class="built_in">	if </span>(y &gt; SendBase) &#123; </span><br><span class="line">		SendBase = y</span><br><span class="line"><span class="built_in">	if </span>(there are currently<span class="built_in"> not-yet-acknowledged </span>segments)</span><br><span class="line">		start timer </span><br><span class="line">	&#125; </span><br><span class="line">	else &#123; </span><br><span class="line">		increment count of dup ACKs received for y</span><br><span class="line">	<span class="built_in">	if </span>(count of dup ACKs received for y = 3) &#123;</span><br><span class="line">		resend segment with sequence number y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>接收方控制发送方，通过<strong>捎带技术</strong>不让发送方发送的太多、太快以至于让接收方的缓冲区溢出</p>
<p>Piggybacking（捎带）：在发送数据的同时携带确认报文</p>
<ul>
<li>接收方在其向发送方的TCP段头部的rwnd字段“通告”其空闲buffer大小<ul>
<li>RcvBuffer大小通过socket选项设置（典型默认大小为4096 字节）</li>
<li>很多操作系统自动调整 RcvBuffer</li>
</ul>
</li>
<li>发送方限制未确认(“in-flight”)字节的个数≤接收方发送过来的 rwnd 值</li>
<li>保证接收方不会被淹没</li>
</ul>
<h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><p>在正式交换数据之前，发送方和接收方握手建立通信关系</p>
<ul>
<li>同意建立连接（每一方都知道对方愿意建立连接）</li>
<li>同意连接参数</li>
</ul>
<p>2次握手连接建立的问题</p>
<ul>
<li><p>变化的延迟（连接请求的段没有丢，但可能超时）</p>
</li>
<li><p>由于丢失造成的重传</p>
</li>
<li><p>报文乱序</p>
</li>
<li><p>相互看不到对方</p>
</li>
<li><p>存在的情况</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820211326552.png" alt="image-20210820211326552"></p>
</li>
</ul>
<p>TCP 3次握手</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820211512381.png" alt="image-20210820211512381"></p>
<p>3次握手解决：半连接和接收老数据问题</p>
<p>方法：若连接不存在， 没建立起来；连接的序号不在当前连接的范围内，则丢弃数据</p>
<p>TCP：关闭连接</p>
<ul>
<li><p>客户端，服务器分别关闭它自己这一侧的连接</p>
<ul>
<li><p>发送FIN bit = 1的TCP段</p>
<blockquote>
<p>FIN：关闭连接</p>
<p>SYN表示建立连接，FIN表示关闭连接，ACK表示响应</p>
</blockquote>
</li>
</ul>
</li>
<li><p>一旦接收到FIN，用ACK回应</p>
<ul>
<li>接到FIN段，ACK可以和它自己发出的FIN段一起发送</li>
</ul>
</li>
<li><p>可以处理同时的FIN交换</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820212852535.png" alt="image-20210820212852535"></p>
</li>
</ul>
<h2 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h2><ul>
<li>拥塞：太多的数据需要网络传输，超过了网络的处理能力</li>
<li>与流量控制不同</li>
<li>拥塞的表现<ul>
<li>分组丢失（路由器缓冲区溢出）</li>
<li>分组经历比较长的延迟（在路由器的队列中排队）</li>
</ul>
</li>
</ul>
<h3 id="拥塞原因与代价"><a href="#拥塞原因与代价" class="headerlink" title="拥塞原因与代价"></a>拥塞原因与代价</h3><p>情况1 ：两个发送方和一台具有无穷大缓存的路由器，输出链路带宽为R且没有重传</p>
<p>吞吐量上限由两条连接之间共享链路容量造成，即最大为R/2，当发送速率在0~R/2之间，接收方的吞吐量等于发送方的发送速率</p>
<p>当发送速率接近R/2，排队时延陡增，平均时延陡增</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210821080358267.png" alt="image-20210821080358267"></p>
<p>情况2：两个发送方和一台具有有限缓存的路由器</p>
<ul>
<li>分组丢失时，发送端重传<ul>
<li>应用层的输入=应用层输出：$\lambda_{in}=\lambda_{out}$</li>
<li>传输层的输入包括重传：$\lambda_{in}\geq\lambda_{out}$</li>
</ul>
</li>
</ul>
<p>理想化1：发送端知道什么时候路由器的缓冲是可用的</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210821081124973.png" alt="image-20210821081124973"></p>
<ul>
<li>只在缓冲可用时发送</li>
<li>不会丢失：$\lambda_{in^{‘}}=\lambda_{in}$</li>
</ul>
<p>理想化2：掌握丢失信息，分组可以丢失，在路由器由于缓冲器满而被丢弃，若知道分组丢失了，发送方重传分组</p>
<p>当以R/2的速度发送时 , 一些分组是重传的 ，有效输出渐进逼近R/2，在发送方不仅包括发送的数据还包括重传数据</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210821081546986.png" alt="image-20210821081546986"></p>
<p>现实情况：重复</p>
<ul>
<li><p>分组可能丢失，由于缓冲器满而被丢弃</p>
</li>
<li><p>发送端最终超时，发送第2个拷贝，2个分组都被传出</p>
</li>
<li><p>输出比输入少原因</p>
<ul>
<li>重传的丢失分组</li>
<li>没有必要重传的重复分组</li>
</ul>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210821082126992.png" alt="image-20210821082126992"></p>
</li>
<li><p>拥塞的“代价”</p>
<ul>
<li>为了达到一个有效输出，网络需要做更多的工作（重传）</li>
<li>没有必要的重传，链路中包括了多个分组的拷贝，是那些没有丢失，经历的时间比较长（拥塞状态）但是超时的分组</li>
</ul>
</li>
</ul>
<p>情况3：4个发送方和具有有限缓存的多台路由器及多跳路径</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210821082535145.png" alt="image-20210821082535145"></p>
<p>当分组丢失时，任何“关于这个分组的上游传输能力” 都被浪费了，最终形成死锁</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210821082948105.png" alt="image-20210821082948105"></p>
<h3 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h3><p>端到端拥塞控制</p>
<ul>
<li>没有来自网络的显式反馈</li>
<li>端系统根据延迟和丢失事件推断是否有拥塞</li>
<li>TCP采用的方法</li>
</ul>
<p>网络辅助的拥塞控制</p>
<ul>
<li>路由器提供给端系统以反馈信息<ul>
<li>单个bit置位，显示有拥塞（SNA, DECbit,  TCP/IP ECN, ATM）</li>
<li>显式提供发送端可以采用的速率</li>
</ul>
</li>
</ul>
<p>案例分析：ATM ABR 拥塞控制（网络辅助的拥塞控制）</p>
<p>ATM发送的数据为信元</p>
<p>ABR: available bit rate</p>
<ul>
<li>“弹性服务”</li>
<li>如果发送端的路径“轻载 ”，发送方使用可用带宽</li>
<li>如果发送方的路径拥塞了，发送方限制其发送的速度到一个最小保障速率上</li>
</ul>
<p>RM (资源管理) 信元（显示通知）</p>
<ul>
<li>由发送端发送，在数据信元中间隔插入</li>
<li>RM信元中的比特被交换机设置（“网络辅助”）<ul>
<li>NI bit: no increase in  rate (轻微拥塞)速率不要增加</li>
<li>CI bit: congestion  indication 拥塞指示</li>
</ul>
</li>
<li>发送端发送的RM信元被接收端返回，接收端不做任何改变</li>
<li>在RM信元中的2个字节 ER (explicit rate)字段<ul>
<li>拥塞的交换机可能会降低信元中ER的值</li>
<li>发送端发送速度因此是最低的可支持速率</li>
</ul>
</li>
<li>数据信元中的EFCI bit: 被拥塞的交换机设置成1，如果在管理信元RM前面的数据信元EFCI被设置成了1, 接收端在返回的RM信元中设置CI bit</li>
</ul>
<h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>端到端的拥塞控制机制</p>
<ul>
<li>路由器不向主机有关拥塞的反馈信息<ul>
<li>路由器的负担较轻</li>
<li>符合网络核心简单的 TCP/IP架构原则</li>
</ul>
</li>
<li>端系统根据自身得到的信息 ，判断是否发生拥塞，从而采取动作</li>
</ul>
<p><strong>拥塞感知（发送端如何探测到拥塞）</strong></p>
<ul>
<li><p>某个段超时了（丢失事件 ）：拥塞</p>
<ul>
<li>超时时间到，某个段的确认没有来</li>
<li>原因1：网络拥塞（某个路由器缓冲区没空间了，被丢弃）概率大</li>
<li>原因2：出错被丢弃了（各级错误，没有通过校验，被丢弃）概率小</li>
<li>一旦超时，就认为拥塞了，有一定误判，但是总体控制方向是对的</li>
</ul>
</li>
<li><p>有关某个段的3次重复ACK：轻微拥塞</p>
<img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20211228184915293.png" alt="image-20211228184915293" style="zoom:50%;">

<ul>
<li>段的第1个ack，正常，确认绿段，期待红段</li>
<li>段的第2个重复ack，意味着红段的后一段收到了，蓝段乱序到达</li>
<li>段的第2、3、4个ack重复，意味着红段的后第2、3、4个段收到了 ，橙段乱序到达，同时红段丢失的可能性很大（后面3个段都到了， 红段都没到）</li>
<li>网络这时还能够进行一定程度的传输，拥塞但情况要比第一种好</li>
</ul>
</li>
</ul>
<p><strong>速率控制方法（如何控制发送端发送的速率）</strong></p>
<ul>
<li><p>维持一个拥塞窗口的值：Congestion window，cwnd</p>
</li>
<li><p>发送端限制已发送但是未确认的数据量（的上限）：$LastByteSent-LastByteAcked\leq \min{cwnd,rwnd}$</p>
</li>
<li><p>从而粗略地控制发送方的往网络中注入的速率：$rate\approx \frac{cwnd}{RTT}$</p>
</li>
<li><p>cwnd是动态的，是感知到的网络拥塞程度的函数</p>
<ul>
<li><p>超时或者3个重复ack，cwnd 下降</p>
<ul>
<li><p>超时时：cwnd降为1MSS，进入SS阶段然后再倍增到 cwnd/2（每个RTT），从而进入CA（拥塞避免）阶段</p>
<blockquote>
<p>MSS（最大报文段长度）=MTU - IP head- TCP head</p>
</blockquote>
</li>
<li><p>3个重复ack ：cwnd降为cwnd/2，CA阶段</p>
</li>
</ul>
</li>
<li><p>否则（正常收到Ack，没有发送以上情况）：cwnd上升</p>
<ul>
<li>SS阶段：加倍增加（每个RTT）</li>
<li>CA阶段：线性增加（每个RTT）</li>
</ul>
</li>
</ul>
</li>
<li><p>联合控制的方法</p>
<ul>
<li>发送端控制发送但是未确认的量同时也不能够超过接收窗口，满足流量控制要求</li>
<li>同时满足拥塞控制和流量控制要求</li>
</ul>
</li>
</ul>
<p><strong>拥塞控制策略</strong></p>
<p>TCP 慢启动（slow-start，SS）</p>
<ul>
<li>连接刚建立，cwnd = 1 MSS</li>
<li>可用带宽可能接近MSS/RTT，此时应该尽快加速，到达希望的速率</li>
<li>当连接开始时，指数性增加发送速率，直到发生丢失的事件<ul>
<li>启动初值很低</li>
<li>增加速度很快</li>
</ul>
</li>
<li>当连接开始时，指数性增加（每个RTT）发送速率直到发生丢失事件<ul>
<li>每一个RTT，cwnd加倍</li>
<li>每收到一个ACK时，cwnd加1</li>
<li>慢启动阶段：只要不超时或3个重复ack，一个RTT，cwnd加倍</li>
</ul>
</li>
<li>总结：初始速率很慢，但是加速却是指数性的<ul>
<li>指数增加，SS时间很短，长 期来看可以忽略</li>
</ul>
</li>
<li>例子：喝酒</li>
</ul>
<p>TCP 拥塞控制：AIMD</p>
<ul>
<li><p>乘性减：丢失事件后将cwnd降为1，将cwnd/2作为阈值，进入慢启动阶段（倍增直到 cwnd/2） </p>
</li>
<li><p>加性增：当cwnd&gt;阈值时，一个RTT如没有发生丢失事件，将cwnd加1MSS进行探测</p>
</li>
<li><p>在超时之前，当cwnd变成上次发生超时的窗口的一半，将指数性增长变成线性<img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210821091932885.png" alt="image-20210821091932885"></p>
</li>
<li><p>变量：Threshold</p>
</li>
<li><p>出现丢失，Threshold设置成cwnd的1/2</p>
</li>
</ul>
<p>TCP拥塞控制总结：</p>
<ul>
<li>当cwnd＜Threshold，发送端处于慢启动阶段（ slow-start）, 窗口指数性增长</li>
<li>当cwnd &gt; Threshold，发送端处于拥塞避免阶段 （congestion-avoidance）, 窗口线性增长</li>
<li>当收到三个重复的ACKs（triple duplicate ACK），Threshold设置成 cwnd/2，cwnd = Threshold+3</li>
<li>当超时事件发生时timeout，Threshold = cwnd/2  cwnd=1MSS，进入SS阶段</li>
</ul>
<table>
<thead>
<tr>
<th>事件</th>
<th>状态</th>
<th>TCP 发送端行为</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>以前没有收到 ACK的data  被ACKed</td>
<td>慢启动 (SS)</td>
<td>cwnd = cwnd + MSS if（cwnd &gt; Threshold）状态变成“CA”</td>
<td>每一个RTT cwnd 加倍</td>
</tr>
<tr>
<td>以前没有收到 ACK的data  被ACKed</td>
<td>拥塞避 免 (CA)</td>
<td>cwnd = cwnd + MSS *（MSS/cwnd）</td>
<td>加性增加，每一个RTT对 cwnd 加一个1 MSS</td>
</tr>
<tr>
<td>通过收到3个重 复的ACK，发现 丢失的事件</td>
<td>SS or CA</td>
<td>Threshold = cwnd/2，cwnd = Threshold+3</td>
<td>快速重传，实现乘性的减. cwnd 没有变成1  MSS</td>
</tr>
<tr>
<td>超时</td>
<td>SS or CA</td>
<td>Threshold = cwnd/2，cwnd = 1MSS，状态变为SS</td>
<td>进入slow start</td>
</tr>
<tr>
<td>重复的 ACK</td>
<td>SS or CA</td>
<td>对被ACKed 的segment，增加重复ACK的计数</td>
<td>cwnd和Threshold不变</td>
</tr>
</tbody></table>
<p>TCP 吞吐量：忽略慢启动阶段，假设发送端总有数据传输</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210821094010456.png" alt="image-20210821094010456"></p>
<ul>
<li><p>W：发生丢失事件时的窗口尺寸（单位：字节）</p>
</li>
<li><p>平均窗口尺寸：3/4W</p>
</li>
<li><p>平均吞吐量：RTT时间吞吐3/4W</p>
<blockquote>
<p>$T=\frac{\frac{W}{2}+W}{2RTT}=\frac{3}{4}\frac{W}{RTT}$</p>
</blockquote>
</li>
</ul>
<p><strong>TCP公平性</strong></p>
<p>若K个TCP会话分享一个链路带宽为R的瓶颈，每一个会话的有效带宽为 R/K</p>
<p>2个竞争的TCP会话</p>
<ul>
<li>加性增加，斜率为1, 吞吐量增加</li>
<li>乘性减，吞吐量比例减少</li>
</ul>
<p>公平性和 UDP</p>
<ul>
<li>多媒体应用通常不是用 TCP，应用发送的数据速率希望不受拥塞控制的节制</li>
<li>使用UDP：音视频应用泵出数据的速率是恒定的, 忽略数据的丢失</li>
<li>研究领域：TCP友好性</li>
</ul>
<p>公平性和并行TCP连接</p>
<ul>
<li>2个主机间可以打开多个并行的TCP连接</li>
<li>如Web浏览器</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" rel="tag"># 大学课程</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/" rel="prev" title="应用层">
                  <i class="fa fa-chevron-left"></i> 应用层
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/" rel="next" title="网络层：数据平面">
                  网络层：数据平面 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fab fa-optin-monster"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">从此在回忆里</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
