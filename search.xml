<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JS对象</title>
    <url>/2021/10/11/JS/JS%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>JavaScript 中，任何不是字符串、数值、符号、布尔值、<code>null</code>、<code>undefined</code> 的值都是对象</p>
<p>JavaScript 的主要特性是“<strong>原型式继承</strong>”，JavaScript 使用术语“自由属性”指代非继承属性</p>
<span id="more"></span>

<p>对象属性除了名字和值之外，还有三个属性特性</p>
<ul>
<li><code>writable</code>（可写）特性指定是否可以设置属性的值</li>
<li><code>enumerate</code>（可枚举）特性指定是否可以在 <code>for/in</code> 循环中返回属性的名字</li>
<li><code>configurable</code>（可配置）特性指定是否可以删除属性，以及是否可修改其特性</li>
</ul>
<p>默认情况下，创建的对象的所有属性都是可写、可枚举和可配置的</p>
<p>很多 JavaScript 内置对象拥有只读、不可枚举或不可配置的属性</p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h4 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a><strong>对象字面量</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> empty = &#123;&#125;;                             <span class="comment">// 没有属性的对象</span></span><br><span class="line"><span class="keyword">let</span> point = &#123;<span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>&#125;;                   <span class="comment">// 包含两个数值属性</span></span><br><span class="line"><span class="keyword">let</span> p2 = &#123;<span class="attr">x</span>: point.x, <span class="attr">y</span>: point.y+<span class="number">1</span>&#125;;        <span class="comment">// 值比较复杂</span></span><br><span class="line"><span class="keyword">let</span> book = &#123;</span><br><span class="line">    <span class="string">&quot;main title&quot;</span>: <span class="string">&quot;JavaScript&quot;</span>,             <span class="comment">// 属性名包含空格</span></span><br><span class="line">    <span class="string">&quot;sub-title&quot;</span>: <span class="string">&quot;The Definitive Guide&quot;</span>,    <span class="comment">// 和连字符，使用字符串字面量</span></span><br><span class="line">    <span class="attr">for</span>: <span class="string">&quot;all audiences&quot;</span>,                   <span class="comment">// for 是保留字，不用引号</span></span><br><span class="line">    <span class="attr">author</span>:&#123;                                <span class="comment">// 对象</span></span><br><span class="line">        <span class="attr">firstname</span>: <span class="string">&quot;David&quot;</span>，</span><br><span class="line">        <span class="attr">surname</span>: <span class="string">&quot;Flanagan&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="new-关键字"><a href="#new-关键字" class="headerlink" title="new 关键字"></a><strong><code>new</code> 关键字</strong></h4><p><code>new</code> 操作符用于创建和初始化一个新对象</p>
<p><code>new</code> 关键字后必须跟一个函数调用，这种方式使用的函数被称为构造函数（constructor）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JavaScript 内置类型构造函数</span></span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();      <span class="comment">// 创建一个空对象，与 &#123;&#125; 相同</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>();       <span class="comment">// 创建一个空数组，与 [] 相同</span></span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();        <span class="comment">// 创建一个表示当前时间的日期对象</span></span><br><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> <span class="built_in">Map</span>();         <span class="comment">// 创建一个映射对象，用于存储键/值映射</span></span><br></pre></td></tr></table></figure>

<h4 id="Object-create-函数"><a href="#Object-create-函数" class="headerlink" title="Object.create() 函数"></a><strong><code>Object.create()</code> 函数</strong></h4><p><code>Object.create()</code> 用于创建一个对象，使用其第一个参数作为新对象的原型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o1 = <span class="built_in">Object</span>.create(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;);    <span class="comment">// o1 继承属性 x 和 y</span></span><br><span class="line">o1.x + o1.y                              <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure>

<p>传入 <code>null</code> 可以创建一个没有原型的新对象，不继承任何属性或方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o2 = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>创建普通的空对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o3 = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype);    <span class="comment">// o3与 &#123;&#125; 或 new Object&#123;&#125; 类似</span></span><br></pre></td></tr></table></figure>







<h2 id="查询对象"><a href="#查询对象" class="headerlink" title="查询对象"></a>查询对象</h2><p>查询不存在的属性不会报错，返回 <code>undefined</code></p>
<p>查询不存在对象的属性报错</p>
<h2 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h2><p><code>delete</code> 操作符用于从对象中移出属性</p>
<p><code>delete</code> 操作符只删除自有属性，不删除继承属性（要删除继承属性，需从定义属性的原型对象上删除）</p>
<h2 id="测试属性"><a href="#测试属性" class="headerlink" title="测试属性"></a>测试属性</h2><p>测试对象属性成员关系，即检查对象是否有一个给定名字的属性</p>
<ul>
<li><p><code>in</code> 操作符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="string">&quot;x&quot;</span> <span class="keyword">in</span> o       <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>hasOwnProperty()</code> 方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line">o.hasOwnProperty(<span class="string">&quot;x&quot;</span>)             <span class="comment">// =&gt; true</span></span><br><span class="line">o.hasOwnProperty(<span class="string">&quot;toString&quot;</span>)      <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure>

<p>此方法对继承的属性返回 <code>false</code></p>
</li>
<li><p><code>propertyIsEnumerable()</code> 方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line">o.propertyIsEnumerable(<span class="string">&quot;x&quot;</span>)                          <span class="comment">// =&gt; true</span></span><br><span class="line">o.propertyIsEnumerable(<span class="string">&quot;toString&quot;</span>)                   <span class="comment">// =&gt; false</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.propertyIsEnumerable(<span class="string">&quot;toString&quot;</span>)    <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure>

<p>传入的命名属性时自有属性且这个属性可枚举，返回 <code>true</code></p>
</li>
</ul>
<h2 id="枚举属性"><a href="#枚举属性" class="headerlink" title="枚举属性"></a>枚举属性</h2><ul>
<li>用 <code>for/in</code> 循环返回可枚举的自由或继承属性</li>
<li>先获取对象所有属性名的数组，再通过 <code>for/of</code> 循环遍历该数组</li>
<li><code>Object.keys()</code> ：返回对象可枚举自有属性名的数组，不包含不可枚举属性、继承属性或名字是符号的属性</li>
<li><code>Object.getOwnPropertyNames()</code> ：返回自有属性名的数组，只要其名字为字符串</li>
<li><code>Object.getOwnPropertySymbols()</code> ：返回名字是符号的自由属性，无论是否可枚举</li>
<li><code>Reflect.ownKeys()</code> ：返回所有属性名</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端学习</tag>
      </tags>
  </entry>
  <entry>
    <title>JS数组</title>
    <url>/2021/10/17/JS/JS%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><ul>
<li><p>数组字面量</p>
</li>
<li><p>对可迭代对象使用 <code>...</code> 扩展操作符</p>
</li>
<li><p><code>Array()</code> 构造函数</p>
</li>
<li><p>工厂方法 <code>Array.of()</code> 和 <code>Array.from()</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用参数作为数组元素来创建并返回新数组</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)    <span class="comment">// =&gt; [1,2,3]</span></span><br><span class="line"><span class="comment">// 将类数组对象创建真正的数组副本</span></span><br><span class="line"><span class="keyword">let</span> truearray = <span class="built_in">Array</span>.from(arraylike)</span><br></pre></td></tr></table></figure></li>
</ul>
<span id="more"></span>



<h2 id="迭代数组"><a href="#迭代数组" class="headerlink" title="迭代数组"></a>迭代数组</h2><p>通过 <code>for/of</code> 循环迭代，使用内置数组迭代器按照升序返回数组元素，对于稀疏数组，不存在的元素返回 <code>undefined</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> letters = [...<span class="string">&quot;Hello world&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> string = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> letter <span class="keyword">of</span> letters)&#123;</span><br><span class="line">    string += letter;</span><br><span class="line">&#125;</span><br><span class="line">string        <span class="comment">// =&gt; &quot;Hello world&quot;</span></span><br></pre></td></tr></table></figure>

<p>若通过 <code>for/of</code> 循环且想知道每个数组元素的索引，可以使用数组的 <code>entries()</code> 方法和解构赋值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> everyother = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [index, letter] <span class="keyword">of</span> letters.entries())&#123;</span><br><span class="line">    <span class="keyword">if</span>(index % <span class="number">2</span> === <span class="number">0</span>) everyother += letter;  <span class="comment">// 偶书索引的字母</span></span><br><span class="line">&#125;</span><br><span class="line">everyother        <span class="comment">// =&gt; &quot;Hlowrd&quot;</span></span><br></pre></td></tr></table></figure>



<p>乘法表</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个多维数组</span></span><br><span class="line"><span class="keyword">let</span> table = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; table.length; i++)&#123;</span><br><span class="line">    table[i] = <span class="keyword">new</span> <span class="built_in">Array</span>[<span class="number">10</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> row = <span class="number">0</span>; row &lt; table.length; row++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> col = <span class="number">0</span>; col &lt; table[row].length; col++)&#123;</span><br><span class="line">        table[row][col] = row*col;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><p><code>Array</code> 类定义的方法</p>
<h3 id="数组迭代器方法"><a href="#数组迭代器方法" class="headerlink" title="数组迭代器方法"></a>数组迭代器方法</h3><p>这些方法都接收一个函数作为第一个参数，且对数组的每个元素（或某些元素）都调用一次这个函数，若是稀疏数组，不会对不存在的数组调用传入的这个函数</p>
<p>这些方法都不会修改调用它们的数组，但是，传入的参数可能会修改这个数组</p>
<ul>
<li><p><code>forEach()</code></p>
<p><code>forEach()</code> 在调用第一个参数的函数时会给还函数传入 3 个参数：数组元素的值、数组元素的索引和数组本身</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], sum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 计算数组元素和</span></span><br><span class="line">data.forEach(<span class="function"><span class="params">value</span> =&gt;</span> &#123;sum += value; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递增每个元素的值</span></span><br><span class="line">data.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">v, i, a</span>)</span>&#123;</span><br><span class="line">    a[i] = v + <span class="number">1</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>forEach()</code> 不提供提前终止迭代的方式</p>
</li>
<li><p><code>map()</code></p>
<p><code>map()</code> 把调用它的数组的每个元素分别传给指定的函数，返回这个函数的返回值构成的数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span>  a = [<span class="number">1</span> ,<span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.map(<span class="function"><span class="params">x</span> =&gt;</span> x*x)        <span class="comment">// =&gt; [1, 4, 9]</span></span><br></pre></td></tr></table></figure>

<p><code>map()</code> 返回一个新数组，若原数组是稀疏的，缺失元素不调用函数，但返回的数组会与原数组一样稀疏</p>
</li>
<li><p><code>filter()</code></p>
<p><code>filter()</code> 返回一个包含调用此方法的数组的子数组，传给此方法的函数是断言函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">a.filter(<span class="function"><span class="params">x</span> =&gt;</span> x &lt; <span class="number">3</span>)           <span class="comment">// =&gt; [2, 1]</span></span><br><span class="line">a.filter(<span class="function">(<span class="params">x,i</span>) =&gt;</span> i%<span class="number">2</span> === <span class="number">0</span>)   <span class="comment">// =&gt; [5, 3, 1]</span></span><br></pre></td></tr></table></figure>

<p><code>filter()</code> 会跳过稀疏数组中缺失的元素，返回的是稠密数组，可以利用此方法清理稀疏数组的空隙</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dense = sparse.filter(<span class="function">() =&gt;</span> <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>若即要清理稀疏数组的空隙，也要删除值为 <code>undefined</code> 和 <code>null</code> 的元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = a.filter(<span class="function"><span class="params">x</span> =&gt;</span> x !== <span class="literal">undefined</span> &amp;&amp; x !== niull);</span><br></pre></td></tr></table></figure></li>
<li><p><code>find()</code> 与 <code>findIndex()</code></p>
<p><code>find()</code> 与 <code>findIndex()</code> 和 <code>filter()</code> 类似，不同在于，这两个方法在断言函数找到第一个元素时停止迭代，<code>find()</code>  返回匹配元素，<code>findIndex()</code> 返回匹配元素的索引，若没有找到匹配元素，<code>find()</code>  返回 <code>undefined</code>，<code>findIndex()</code> 返回 -1</p>
</li>
<li><p><code>every()</code> 与 <code>some()</code></p>
<p><code>every()</code> 与 <code>some()</code> 是数组断言方法，<code>every()</code> 只在断言函数对数组的所有元素都为 <code>true</code> 才返回 <code>true</code>，<code>some()</code> 在断言函数对数组的一个元素为 <code>true</code> 返回 <code>true</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">a.every(<span class="function"><span class="params">x</span> =&gt;</span> x &lt; <span class="number">10</span>)    <span class="comment">// =&gt; true</span></span><br><span class="line">a.some(<span class="function"><span class="params">x</span> =&gt;</span> x%<span class="number">2</span> ===<span class="number">0</span>)   <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>

<p>在空数组上调用，<code>every()</code> 返回 <code>true</code>，<code>some()</code> 返回 <code>false</code></p>
</li>
<li><p><code>reduce()</code> 与 <code>reduceRight()</code></p>
<p><code>reduce()</code> 与 <code>reduceRight()</code> 方法使用指定函数归并数组元素，最终产生一个值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">a.reduce(<span class="function">(<span class="params">x,y</span>) =&gt;</span> x+y, <span class="number">0</span>)             <span class="comment">// =&gt; 15</span></span><br><span class="line">a.reduce(<span class="function">(<span class="params">x,y</span>) =&gt;</span> x*y, <span class="number">1</span>)             <span class="comment">// =&gt; 120</span></span><br><span class="line">a.reduce(<span class="function">(<span class="params">x,y</span>) =&gt;</span> (x &gt; y) ? x : y)    <span class="comment">// =&gt; 5：最大值</span></span><br></pre></td></tr></table></figure>

<p><code>reduce()</code> 接收两个参数</p>
<ul>
<li>执行归并的函数</li>
<li>传给归并函数的初始值（可选）</li>
</ul>
<p><code>reduceRight()</code> 与 <code>reduce()</code> 类似，只是从高索引引向低索引处理索引</p>
</li>
</ul>
<h3 id="flat-和-flatMap-打平数组"><a href="#flat-和-flatMap-打平数组" class="headerlink" title="flat() 和 flatMap() 打平数组"></a>flat() 和 flatMap() 打平数组</h3><p>ES2019 新定义方法，falt() 方法用于创建并返回一个新数组，返回元素是数组的会被打平填充到返回的数组中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>]].flat()     <span class="comment">// =&gt; [1, 2, 3]</span></span><br><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>]]].flat()   <span class="comment">// =&gt; [1, 2, [3]]</span></span><br><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>]]].flat(<span class="number">2</span>)  <span class="comment">// =&gt; [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p><code>flatMap()</code> 方法与 <code>map()</code> 相似，但返回的数组会自动打平</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> phrases = [<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;the definitive guide&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> words = phrases.flatMap(<span class="function"><span class="params">phrase</span> =&gt;</span> phrase.split(<span class="string">&quot; &quot;</span>));</span><br><span class="line">words        <span class="comment">// =&gt; [&quot;hello&quot;, &quot;world&quot;, &quot;the&quot;, &quot;definitive&quot;, &quot;guide&quot;];</span></span><br></pre></td></tr></table></figure>



<h3 id="栈和队列操作"><a href="#栈和队列操作" class="headerlink" title="栈和队列操作"></a>栈和队列操作</h3><ul>
<li><p><code>push()</code>：在数组末尾添加一个或多个新元素，返回数组的新长度</p>
<p><code>push()</code> 不会打平传入的数组，若想打平，可以使用扩展操作符 <code>a.push(...values)</code></p>
</li>
<li><p><code>pop()</code>：在数组末尾删除一个或多个新元素，返回删除的元素</p>
</li>
<li><p><code>shift()</code>：在数组开头删除一个或多个新元素，返回删除的元素</p>
</li>
<li><p><code>unshift()</code>：在数组开头添加一个或多个新元素，返回数组的新长度</p>
</li>
</ul>
<p><code>pop()</code> 与 <code>push()</code> 组合实现先进后出的栈；<code>shift()</code> 与 <code>push()</code> 组合实现先进先出的队列</p>
<h3 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h3><ul>
<li><p><code>slice()</code> ：返回一个数组的切片或子数组，不会修改调用它的数组</p>
<p><code>slice()</code> 接收两个参数，分别用于指定要返回切片的起止位置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">a.slice(<span class="number">0</span>,<span class="number">2</span>);        <span class="comment">// 返回 [1,2,3]</span></span><br><span class="line">a.slice(<span class="number">3</span>);          <span class="comment">// 返回 [4,5]</span></span><br><span class="line">a.slice(<span class="number">1</span>,-<span class="number">1</span>);       <span class="comment">// 返回 [2,3.4]</span></span><br><span class="line">a.slice(-<span class="number">3</span>,-<span class="number">2</span>);      <span class="comment">// 返回 [3]</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>splice()</code> ：对数组进行插入和删除的通用方法，会修改调用它的数组，返回删除的子数组</p>
<p><code>splice()</code> 接收两个参数，第一个参数指定插入或删除的起点位置，第二个参数指定删除的元素个数，这两个参数后跟任意多个参数表示在第一个参数指定的位置插入到数组的元素</p>
</li>
<li><p><code>fill()</code> ：将数组的元素或切片设置为指定的值，会修改调用它的数组，返回修改后的数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>);</span><br><span class="line">a.fill(<span class="number">0</span>)        <span class="comment">// =&gt; [0,0,0,0,0]：用 0 填充数组</span></span><br><span class="line">a.fill(<span class="number">9</span>,<span class="number">1</span>)      <span class="comment">// =&gt; [0,9,9,9,9]：从索引 1 开始填充 9</span></span><br><span class="line">a.fill(<span class="number">8</span>,<span class="number">2</span>,-<span class="number">1</span>)   <span class="comment">// =&gt; [0,9,8,8,9]：在索引 2、3 填充 8</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>copyWithin()</code> ：将数组切片复制到数组中的新位置，会修改调用它的数组，返回修改后的数组，不会改变数组长度</p>
<p><code>copyWithin()</code> 第一个参数指定要把第一个元素复制到的目的索引，第二个参数指定要复制的第一个元素的索引，第三个参数指定要复制的元素切片的终止索引</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">a.copyWithin(<span class="number">1</span>)        <span class="comment">// =&gt; [1,1,2,3,4]：把数组元素复制到索引 1 及之后</span></span><br><span class="line">a.copyWithin(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>)    <span class="comment">// =&gt; [1,1,3,4,4]：把最后两个元素复制到索引 2</span></span><br><span class="line">a.copyWithin(<span class="number">0</span>,-<span class="number">2</span>)     <span class="comment">// =&gt; [4,4,3,4,4]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="数组索引和排序"><a href="#数组索引和排序" class="headerlink" title="数组索引和排序"></a>数组索引和排序</h3><ul>
<li><p><code>indexOf()</code> 和 <code>lastIndexOf()</code> ：从数组中搜索指定值并返回第一个找到的元素的索引，未找到返回 -1</p>
<p><code>indexOf()</code> 从前往后，<code>lastIndexOf()</code> 从后往前搜索</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用 indexOf() 的第二个参数找除第一个以外的匹配值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findall</span>(<span class="params">a,x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> results = [],</span><br><span class="line">        len = a.length,</span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(pos &lt; len)&#123;</span><br><span class="line">        pos = a.indexOf(x, pos);</span><br><span class="line">        <span class="keyword">if</span>(pos === -<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        result.push(pos);</span><br><span class="line">        pos = pos++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>includes()</code> ：ES2016新增，接收一个参数，若数组包含该值返回 <code>true</code>，否则返回 <code>false</code></p>
</li>
<li><p><code>sort()</code> ：对数组元素就地排序并返回排序后的数组，若数组包含未定义元素，排到数组末尾</p>
<p>对数组元素执行非字母顺序的排序，给此方法传一个比较函数作为参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">33</span>, <span class="number">4</span>, <span class="number">1111</span>, <span class="number">222</span>];</span><br><span class="line">a.sort();                <span class="comment">// =&gt; [1111, 222, 33, 4]，字母顺序</span></span><br><span class="line">a.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;    <span class="comment">// 传入一个比较函数</span></span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;);                      <span class="comment">// =&gt; [4, 33, 222, 1111]，数值顺序</span></span><br><span class="line">a.sort(<span class="function">(<span class="params">a,b</span>) =&gt;</span> b-a);    <span class="comment">// =&gt; [1111, 222, 33, 4]，相反的数值顺序</span></span><br></pre></td></tr></table></figure>

<p>对字符串数组做不区分大小写的字母排序</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&quot;ant&quot;</span>, <span class="string">&quot;Bug&quot;</span>, <span class="string">&quot;cat&quot;</span>, <span class="string">&quot;Dog&quot;</span>];</span><br><span class="line">a.sort();               <span class="comment">// =&gt; [&quot;Bug&quot;, &quot;Dog&quot;, &quot;ant&quot;, &quot;cat&quot;]，区分大小写的排序</span></span><br><span class="line">a.sort(<span class="function"><span class="keyword">function</span>(<span class="params">s,t</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = s.toLowerCase();</span><br><span class="line">    <span class="keyword">let</span> b = t.toLowerCase();</span><br><span class="line">    <span class="keyword">if</span>(a &lt; b) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;);                     <span class="comment">// =&gt; [&quot;ant&quot;, &quot;Bug&quot;, &quot;cat&quot;, &quot;Dog&quot;]</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>reverse()</code> ：反转数组元素的顺序</p>
</li>
</ul>
<h3 id="数组到字符串转换"><a href="#数组到字符串转换" class="headerlink" title="数组到字符串转换"></a>数组到字符串转换</h3><ul>
<li><p><code>join()</code> ：将数组的所有元素转换为字符串，拼接，可以指定一个参数，用于分隔字符串的元素</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">let a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.join()           <span class="regexp">//</span> =&gt; <span class="string">&quot;1,2,3&quot;</span></span><br><span class="line">a.join(<span class="string">&quot; &quot;</span>)        <span class="regexp">//</span> =&gt; <span class="string">&quot;1 2 3&quot;</span></span><br><span class="line">a.join(<span class="string">&quot;&quot;</span>)         <span class="regexp">//</span> =&gt; <span class="string">&quot;123&quot;</span></span><br><span class="line">let b = new Array(<span class="number">10</span>);</span><br><span class="line">b.join(<span class="string">&quot;-&quot;</span>)        <span class="regexp">//</span> =&gt; <span class="string">&quot;---------&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>toString()</code> ：与无参数的 <code>join()</code> 方法一样</p>
</li>
<li><p><code>toLocaleString()</code> </p>
</li>
</ul>
<h3 id="静态数组函数"><a href="#静态数组函数" class="headerlink" title="静态数组函数"></a>静态数组函数</h3><ul>
<li><code>Array.of()</code></li>
<li><code>Array.from()</code></li>
<li><code>Array.isArray()</code> ：用于确定一个未知值是不是数组</li>
</ul>
<h2 id="类数组对象"><a href="#类数组对象" class="headerlink" title="类数组对象"></a>类数组对象</h2><p>数组不同于对象的特殊特性</p>
<ul>
<li>数组的 <code>length</code> 属性会在新元素假如时自动更新</li>
<li>设置 <code>length</code> 为更小的值会截断数组</li>
<li>数组从 <code>Array.prototype</code> 继承有用的方法</li>
<li><code>Array.isArray()</code> 对数组返回 <code>true</code></li>
</ul>
<p>当对象有一个数值属性 <code>length</code>，且有相应的非负整数属性，即为类数组对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"><span class="comment">// 添加属性使其成为类数组对象</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; <span class="number">10</span>)&#123;</span><br><span class="line">    a[i] = i * i;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line">a.length = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 像数组一样遍历这个对象</span></span><br><span class="line"><span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> j =<span class="number">0</span>; j &lt; a.length; j++)&#123;</span><br><span class="line">    total += a[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在客户端中，很多操作HTML文档的方法（如 <code>document.querySelectorAll()</code>）都返回类数组对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试对象是不是类数组对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArrayLike</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(o &amp;&amp;                           <span class="comment">// o 不是 null、undefined 等假值</span></span><br><span class="line">       <span class="keyword">typeof</span> o === <span class="string">&quot;object&quot;</span> &amp;&amp;       <span class="comment">// o 是对象</span></span><br><span class="line">       <span class="built_in">Number</span>.isFinite(o.length) &amp;&amp;   <span class="comment">// o.length 是有限数值</span></span><br><span class="line">       o.length &gt;= <span class="number">0</span> &amp;&amp;               <span class="comment">// o.length 是非负数值</span></span><br><span class="line">       <span class="built_in">Number</span>.isInteger(o.length) &amp;&amp;  <span class="comment">// o.length 是整数</span></span><br><span class="line">       o.length &lt; <span class="number">4294967295</span>)&#123;        <span class="comment">// o.length &lt; 2^32 - 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;                  <span class="comment">// o 是类数组对象</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类数组对象不继承 <code>Array.prototype</code> 可以使用 <code>Function.call()</code> 方法来调用数组方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;<span class="string">&quot;0&quot;</span>: <span class="string">&quot;a&quot;</span>, <span class="string">&quot;1&quot;</span>: <span class="string">&quot;b&quot;</span>, <span class="attr">length</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">Array</span>.prototype.join.call(a, <span class="string">&quot;+&quot;</span>)    <span class="comment">// =&gt; &quot;a+b&quot;</span></span><br><span class="line"><span class="built_in">Array</span>.from(a)                        <span class="comment">// =&gt; [&quot;a&quot;,&quot;b&quot;]</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端学习</tag>
      </tags>
  </entry>
  <entry>
    <title>JS模块</title>
    <url>/2021/10/24/JS/JS%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>模块化编程的目标是能够使用不同作者和来源的代码模块组装成大型程序</p>
<p>实践中，模块化的作用主要体现在封装和隐藏私有实现细节，以及保证全局命名空间清结上，因而模块之间不会意外修改各自定义的变量、函数和类</p>
<span id="more"></span>

<h2 id="基于类、对象的模块"><a href="#基于类、对象的模块" class="headerlink" title="基于类、对象的模块"></a>基于类、对象的模块</h2><p>类有一个重要特性，即类充当自己方法的模块。</p>
<p>不相关的类的方法都被定义为独立原型对象的属性，因此这些方法相互独立</p>
<p>在函数中声明的局部变量和嵌套函数是函数私有的，即可以使用立即调用的函数表达式来实现某种模块化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个小型统计模块，暴露mean()和stddev()函数，隐藏实现细节</span></span><br><span class="line"><span class="keyword">const</span> stats = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 模块私有的辅助函数</span></span><br><span class="line">    <span class="keyword">const</span> sum = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br><span class="line">    <span class="keyword">const</span> square = <span class="function"><span class="params">x</span> =&gt;</span> x * x;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 要导出的两个公有函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">mean</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.reduce(sum)/data.length;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">stddev</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> m = mean(data);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(</span><br><span class="line">        	data.map(<span class="function"><span class="params">x</span> =&gt;</span> x - m).map(square).reduce(sum)/(data.length-<span class="number">1</span>);</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将公有函数作为一个对象的属性导出</span></span><br><span class="line">    <span class="keyword">return</span> &#123;mean, stddev&#125;;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">stats.mean([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])      <span class="comment">// =&gt; 5</span></span><br><span class="line">stats.stddev([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])    <span class="comment">// =&gt; Math.sqrt(10)</span></span><br></pre></td></tr></table></figure>







<h2 id="基于闭包的自动化模块"><a href="#基于闭包的自动化模块" class="headerlink" title="基于闭包的自动化模块"></a>基于闭包的自动化模块</h2><p>若存在一个工具，能解析代码文件，将每个文件的内容包装在一个立即调用的函数表达式中，还可以跟踪每个函数的返回值，并将所有内容拼接为一个大文件，即针对浏览器的代码打包工具（如 Webpack 和 Parcel）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> modules = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">moduleName</span>) </span>&#123; <span class="keyword">return</span> modules[moduleName]; &#125;</span><br><span class="line"></span><br><span class="line">modules[<span class="string">&quot;sets.js&quot;</span>] = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">exports</span> = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sets.js文件的内容在这里</span></span><br><span class="line">    <span class="built_in">exports</span>.BitSet = <span class="class"><span class="keyword">class</span> <span class="title">BitSet</span> </span>&#123; ... &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">exports</span>;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">modules[<span class="string">&quot;stats.js&quot;</span>] = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">exports</span> = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// stats.js文件的内容在这里</span></span><br><span class="line">    <span class="keyword">const</span> sum = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br><span class="line">    <span class="keyword">const</span> square = <span class="function"><span class="params">x</span> =&gt;</span> x * x;</span><br><span class="line">    <span class="built_in">exports</span>.mean = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123; ... &#125;;</span><br><span class="line">    <span class="built_in">exports</span>.stddev = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123; ... &#125;;</span><br><span class="line">                                     </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">exports</span>;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<p>将所有模块打包到类似上面的单个文件之中，即可如下操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取得对所需模块（或模块内容）的引用</span></span><br><span class="line"><span class="keyword">const</span> stats = <span class="built_in">require</span>(<span class="string">&quot;stats.js&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> BitSet = <span class="built_in">require</span>(<span class="string">&quot;sets.js&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用这些模块</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> BitSet(<span class="number">100</span>);</span><br><span class="line">s.insert(<span class="number">10</span>);</span><br><span class="line">s.insert(<span class="number">20</span>);</span><br><span class="line">s.insert(<span class="number">30</span>);</span><br><span class="line"><span class="keyword">let</span> average = stats.mean([...s]);</span><br></pre></td></tr></table></figure>







<h2 id="Node中的模块"><a href="#Node中的模块" class="headerlink" title="Node中的模块"></a>Node中的模块</h2><p>编写 Node 程序时，可以随意将程序拆分到任意多个文件中</p>
<p>在 Node 中，每个文件都是一个拥有私有命名空间的独立模块，在一个文件中定义的常量、变量、函数和类对该文件是私有的，除非文件导出它们，被该模块导出的值只有被另一个模块显式导入后才会在此模块可见</p>
<p>Node 使用 <code>require()</code> 函数导入其他模块，通过设置 <code>Exports</code> 对象的属性或完全替换 <code>module.exports</code> 对象来导出公共 API</p>
<p><code>module.exports</code> 的默认值与 <code>exports</code> 引用同一个对象</p>
<h3 id="Node-的导出"><a href="#Node-的导出" class="headerlink" title="Node 的导出"></a>Node 的导出</h3><p>Node定义一个全局 exports 对象，这个对象始终有定义</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 若要导出多个值的 Node 模块，可以直接将这些值设为此对象的属性</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">x</span> =&gt;</span> x * x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.mean = <span class="function"><span class="params">data</span> =&gt;</span> data.reduce(sum)/data.length;</span><br><span class="line"><span class="built_in">exports</span>.stddev = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> m = <span class="built_in">exports</span>.mean(d);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(</span><br><span class="line">        	data.map(<span class="function"><span class="params">x</span> =&gt;</span> x - m).map(square).reduce(sum)/(data.length-<span class="number">1</span>);</span><br><span class="line">        );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 让模块导出一个函数或类,直接将想导出的值赋给module.exports</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">BitSet</span> <span class="keyword">extends</span> <span class="title">AbstractWritableSet</span></span>&#123;</span><br><span class="line">    <span class="comment">// .......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 还可以在模块末尾导出一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义所有公有函数和私有函数</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">x</span> =&gt;</span> x * x;</span><br><span class="line"><span class="keyword">const</span> mean = <span class="function"><span class="params">data</span> =&gt;</span> data.reduce(sum)/data.length;</span><br><span class="line"><span class="keyword">const</span> stddev = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> m = <span class="built_in">exports</span>.mean(d);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(</span><br><span class="line">        	data.map(<span class="function"><span class="params">x</span> =&gt;</span> x - m).map(square).reduce(sum)/(data.length-<span class="number">1</span>);</span><br><span class="line">        );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后只导出公有函数</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;mean, stddev&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Node-的导入"><a href="#Node-的导入" class="headerlink" title="Node 的导入"></a>Node 的导入</h3><p>Node 模块通过调用 <code>require()</code> 函数导入其他模块，这个函数的参数时要导入模块的名字，返回值是该模块导出的值（通常是一个函数、类或对象）</p>
<p>若要导入 Node 内置的系统模块或通过包管理器安装在系统上的模块，可以使用模块的非限定名（不带会被解析为文本系统路径的”/“字符的模块名）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Node内置的模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);       <span class="comment">// 内置的文件系统模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);   <span class="comment">// 内置的HTTP模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Express HTTP 服务器框架是第三方模块</span></span><br><span class="line"><span class="comment">// 不属于Node，但已安装在本地</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>若要导入自己代码的模块，利用文件路径导入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> stats = <span class="built_in">require</span>(<span class="string">&#x27;./stats.js&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> BitSet = <span class="built_in">require</span>(<span class="string">&#x27;./utils/bitset.js&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>若模块只导出一个函数或类，只要调用 <code>require()</code> 取得返回值即可</p>
<p>若模块导出一个带多个属性的对象，则可以有以下两种选择</p>
<ul>
<li>导入整个对象</li>
<li>通过解构赋值只导入打算使用的特点属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入整个对象，包含所有函数</span></span><br><span class="line"><span class="keyword">const</span> stats = <span class="built_in">require</span>(<span class="string">&#x27;./stats.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然导入用不到的函数，但这些函数都隐藏在命名空间之后</span></span><br><span class="line"><span class="keyword">let</span> average = stats.mean(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用解构赋值直接向本地命名空间导入想用的函数</span></span><br><span class="line"><span class="keyword">const</span> &#123; stddev &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./stats.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样简洁，只是stddev()函数没有‘stats’前缀作为命名空间，少了上下文信息</span></span><br><span class="line"><span class="keyword">let</span> sd = stddev(data);</span><br></pre></td></tr></table></figure>







<h2 id="ES6-中的模块"><a href="#ES6-中的模块" class="headerlink" title="ES6 中的模块"></a>ES6 中的模块</h2><p>ES6 为 JavaScript 添加了 <code>import</code> 和 <code>export</code> 关键字，用于支持模块作为核心语法</p>
<h3 id="ES6-的导出"><a href="#ES6-的导出" class="headerlink" title="ES6 的导出"></a>ES6 的导出</h3><p>要从 ES6 模块导出常量、变量、函数和类，在声明前加上 <code>export</code> 关键字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> PI = <span class="built_in">Math</span>.PI;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">degreesToRadians</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> d * PI / <span class="number">180</span>; &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">r</span>)</span> &#123; <span class="built_in">this</span>.r = r; &#125;;</span><br><span class="line">    <span class="function"><span class="title">area</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> PI * <span class="built_in">this</span>.r * <span class="built_in">this</span>.r; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以先正常定义常量、变量、函数和类，再通过export导出想要的值</span></span><br><span class="line"><span class="keyword">export</span> &#123;Circle, degressToRadians, PI &#125;;</span><br></pre></td></tr></table></figure>

<p>若一个模块只导出一个值（通常是一个函数或类），通常使用默认导出（export default）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">BitSet</span> </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认导出在导入时稍微简单些，在只要一个导出值的情况，使用 <code>export default</code> 可以简化使用导出值的模块代码</p>
<p>使用 <code>export</code> 的常规导出只对有名字的声明有效，使用 <code>export default</code> 则可以导出任意表达式，包括匿名函数表达式和匿名表达式</p>
<p><code>export</code> 关键字只能出现在 JavaScript 代码的顶层，不能在类、函数、循环或条件内部导出值</p>
<h3 id="ES6-的导入"><a href="#ES6-的导入" class="headerlink" title="ES6 的导入"></a>ES6 的导入</h3><p>导入其他模块导出的值使用 <code>import</code> 关键字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入定义默认导出的模块</span></span><br><span class="line"><span class="keyword">import</span> BitSet <span class="keyword">from</span> <span class="string">&#x27;./bitset.js&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><code>import</code> 关键字只能出现在 JavaScript 代码的顶层，不能在类、函数、循环或条件内部导出值，非强制性，导入与函数声明类型，会被提升到顶部</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从导出多个值的模块导入想要的值</span></span><br><span class="line"><span class="keyword">import</span> &#123;mean, stddev&#125; <span class="keyword">from</span> <span class="string">&quot;./stats.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入所有值</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> stats <span class="keyword">from</span> <span class="string">&quot;./stats.js&quot;</span></span><br></pre></td></tr></table></figure>

<p>导入所有值会将模块里的每个非默认导出都变为这个 <code>stats</code> 对象的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入没有任何导出的模块</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./analytics.js&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="导入和导出时重命名"><a href="#导入和导出时重命名" class="headerlink" title="导入和导出时重命名"></a>导入和导出时重命名</h3><p>若两个模块使用相同的名字导入两个不同的值，且希望同时导入这两个值，那必须在导入时对其中至少一个进行重命名</p>
<p>若导入某个值时发现已有同名，也需要重命名这个导入值</p>
<p>在命名导入时使用 <code>as</code> 关键字对导入值重命名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; render <span class="keyword">as</span> renderImage &#125; <span class="keyword">from</span> <span class="string">&quot;./imageutils.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; render <span class="keyword">as</span> renderUI&#125; <span class="keyword">from</span> <span class="string">&quot;./ui.js&quot;</span></span><br></pre></td></tr></table></figure>

<p>同时导入默认导出和命名导出的方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> Histogram, mean, stddev &#125; <span class="keyword">from</span> <span class="string">&quot;./histogram-stats.js&quot;</span></span><br></pre></td></tr></table></figure>

<p>导出值也可以进行重命名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    layout <span class="keyword">as</span> calculateLayout,</span><br><span class="line">    render <span class="keyword">as</span> renderLayout</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>export</code> 关键字需要 <code>as</code> 前面是一个标识符，而非表达式，即不能如下重命名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; <span class="built_in">Math</span>.sin <span class="keyword">as</span> sin, <span class="built_in">Math</span>.cos <span class="keyword">as</span> cos &#125;;       <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure>



<h3 id="再导出"><a href="#再导出" class="headerlink" title="再导出"></a>再导出</h3><p>ES6 模块通过组合 <code>expor</code>t 和 <code>from</code> 关键字构造一个“再导出”语句</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; mean &#125; <span class="keyword">from</span> <span class="string">&quot;./stats/mean.js&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; stddev &#125; <span class="keyword">from</span> <span class="string">&quot;./stats/stddev.js&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>若不需要选择性地再导出，而是希望到处另一个模块地所有命名值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&quot;./stats/mean.js&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&quot;./stats/stddev.js&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>若要将另一个模块的命名符号再导出为当前模块地默认导出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; mean <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./stats.js&quot;</span></span><br></pre></td></tr></table></figure>

<p>若要将另一个模块的默认导出再导出为当前模块地默认导出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./stats/mean.js&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="Web-使用-JavaScript-模块"><a href="#Web-使用-JavaScript-模块" class="headerlink" title="Web 使用 JavaScript 模块"></a>Web 使用 JavaScript 模块</h3><p>在浏览器中以原生方式使用 <code>import</code> 指令，必须通过 <code>&lt;scripe type=&quot;module&quot;&gt;</code> 标签告诉浏览器这是一个模块</p>
<p>ES6 模块的重要特性是每个模块的导入都是静态的，即只要有一个起始模块，浏览器就可以加载它导入的所有模块</p>
<p>添加 <code>async</code> 属性可以改变执行模块代码的时机</p>
<p>支持 <code>&lt;scripe type=&quot;module&quot;&gt;</code> 的浏览器必须也支持 <code>&lt;scripe nomodule&gt;</code></p>
<p>支持模块的浏览器会忽略 <code>nomodule</code> 属性的脚本，不支持模块的浏览器不认识 <code>nomodule</code> 属性，会忽略这个属性运行其脚本，可以兼容旧版本浏览器</p>
<p>常规脚本和模块脚本的另一个重要区别涉及跨源加载</p>
<h3 id="通过-import-动态导入"><a href="#通过-import-动态导入" class="headerlink" title="通过 import() 动态导入"></a>通过 import() 动态导入</h3><p>ES6 的 <code>import</code> 和 <code>export</code> 指令都是静态的，静态导入的模块可以保证导入的值在任何模块代码运行之前就可以使用</p>
<p>若代码在 CPU 相对较慢的移动设备上执行，不适用于静态模块导入的场景，静态模块导入需要先加载完全部程序再执行，通过动态导入可以解决</p>
<p>传给 <code>import()</code>  一个模块标识符，会返回一个期约对象，表示加载和运行指定模块的异步过程，动态导入完成后，这个期约会“兑现”并产生一个对象，与使用静态导入语句 <code>import * as</code> 得到的对象类似</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态导入</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> stats <span class="keyword">from</span> <span class="string">&quot;./stats.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态导入</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">&quot;./stats.js&quot;</span>).then(<span class="function"><span class="params">stats</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> average = stats.mean(data);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 或在一个async函数中</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">analyzeData</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stats = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&quot;./stats.js&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        <span class="attr">average</span>: stats.mean(data),</span><br><span class="line">        <span class="attr">stddev</span>: stats.stddev(data)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="import-meta-url"><a href="#import-meta-url" class="headerlink" title="import.meta.url"></a>import.meta.url</h3><p>在 ES6 模块中，<code>import.meta</code> 引用一个对象，这个对象包含当前正在执行模块的元数据，这个对象的 url 属性是加载模块时使用的 url（在 Node 中是 <code>file://URL</code>）</p>
<p><code>import.meta.url</code> 的主要使用场景是引用与模块位于同一（或相对）目录下的图片、数据文件或其他资源</p>
<p>使用 <code>URL()</code> 构造函数可以非常方便地相对于 <code>import.meta.url</code> 这样地绝对 URL 来解析相对 URL</p>
<p>示例：若要写一个模块，其中包含需要本地化的字符串，而相关地本地化文件保存在 l10n/ 目录下，这个目录也保存着模块本身，则你的模块可以通过使用如下的函数创建的 URL 来加载字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">localStringURL</span>(<span class="params">locale</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> URL(<span class="string">`l10n/<span class="subst">$&#123;local&#125;</span>.json`</span>, <span class="keyword">import</span>.meta.url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端学习</tag>
      </tags>
  </entry>
  <entry>
    <title>JS表达式与操作符</title>
    <url>/2021/10/10/JS/JS%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="属性访问"><a href="#属性访问" class="headerlink" title="属性访问"></a>属性访问</h2><p>属性访问表达式求值为对象属性或数组元素的值，JavaScript 定义了两种访问属性的语法</p>
<ul>
<li><p><code>expression.identifier</code></p>
<blockquote>
<p>表达式后跟一个句点和一个标识符，表达式指定对象，标识符指定属性名</p>
</blockquote>
</li>
<li><p><code>expression [expression]</code></p>
<blockquote>
<p>表达式指定属性名或数组元素的索引</p>
</blockquote>
</li>
</ul>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: &#123;<span class="attr">z</span>: <span class="number">3</span>&#125;&#125;;            <span class="comment">// 示例对象</span></span><br><span class="line"><span class="keyword">let</span> a = [o, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]];               <span class="comment">// 包含前面对象的示例数组</span></span><br><span class="line">o.x                                   <span class="comment">// =&gt; 1</span></span><br><span class="line">o.y.z                                 <span class="comment">// =&gt; 3</span></span><br><span class="line">o[<span class="string">&quot;x&quot;</span>]                                <span class="comment">// =&gt; 1</span></span><br><span class="line">a[<span class="number">1</span>]                                  <span class="comment">// =&gt; 4</span></span><br><span class="line">a[<span class="number">2</span>][<span class="string">&quot;1&quot;</span>]                             <span class="comment">// =&gt; 6</span></span><br><span class="line">a[<span class="number">0</span>].x                                <span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure>

<p>若求值结果为 <code>null</code> 或 <code>undefined</code>，则表达式会抛出 <code>TypeError</code></p>
<p>ES2020 新增条件式属性访问</p>
<ul>
<li><code>expression?.identifier</code></li>
<li><code>expression?.[expression]</code></li>
</ul>
<p>使用条件式属性访问可以防止因结果为 <code>null</code> 或 <code>undefined</code> 而引起的 <code>TypeError</code></p>
<p>若 <code>?.</code> 左侧的子表达式求值为 <code>null</code> 或 <code>undefined</code> ，整个表达式立即求值为 <code>undefined</code> ，不再进一步尝试访问属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a;                         <span class="comment">// 未初始化</span></span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    a[index++];                <span class="comment">// 抛出 TypeError</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    index                      <span class="comment">// 抛出 TypeError 之前发生了递增</span></span><br><span class="line">&#125;</span><br><span class="line">a?.[index++]                   <span class="comment">// =&gt; undefined</span></span><br><span class="line">index                          <span class="comment">// =&gt; 1：?.[] 短路所以没有发生递增</span></span><br><span class="line">a[index++]                     <span class="comment">// !TypeError：不能索引 undefined</span></span><br></pre></td></tr></table></figure>







<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>JavaScript 操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>操作</th>
<th>结合性</th>
<th>操作数</th>
<th>类型</th>
<th>优先级</th>
</tr>
</thead>
<tbody><tr>
<td>++</td>
<td>先或后递增</td>
<td>右</td>
<td>1</td>
<td>lval→num</td>
<td>1</td>
</tr>
<tr>
<td>–</td>
<td>先或后递减</td>
<td>右</td>
<td>1</td>
<td>lval→num</td>
<td>1</td>
</tr>
<tr>
<td>-</td>
<td>负值</td>
<td>右</td>
<td>1</td>
<td>num→num</td>
<td>1</td>
</tr>
<tr>
<td>+</td>
<td>转换未数值</td>
<td>右</td>
<td>1</td>
<td>any→num</td>
<td>1</td>
</tr>
<tr>
<td>~</td>
<td>反转二进制位</td>
<td>右</td>
<td>1</td>
<td>int→int</td>
<td>1</td>
</tr>
<tr>
<td>!</td>
<td>反转布尔值</td>
<td>右</td>
<td>1</td>
<td>bool→bool</td>
<td>1</td>
</tr>
<tr>
<td>delete</td>
<td>删除属性</td>
<td>右</td>
<td>1</td>
<td>lval→bool</td>
<td>1</td>
</tr>
<tr>
<td>typeof</td>
<td>确定操作数类型</td>
<td>右</td>
<td>1</td>
<td>any→str</td>
<td>1</td>
</tr>
<tr>
<td>void</td>
<td>返回 undefined</td>
<td>右</td>
<td>1</td>
<td>any→undef</td>
<td>1</td>
</tr>
<tr>
<td>**</td>
<td>幂</td>
<td>右</td>
<td>2</td>
<td>num，num→num</td>
<td>2</td>
</tr>
<tr>
<td>*、/、%</td>
<td>乘、除、取余</td>
<td>左</td>
<td>2</td>
<td>num，num→num</td>
<td>3</td>
</tr>
<tr>
<td>+、-</td>
<td>加、减</td>
<td>左</td>
<td>2</td>
<td>num，num→num</td>
<td>4</td>
</tr>
<tr>
<td>+</td>
<td>拼接字符串</td>
<td>左</td>
<td>2</td>
<td>str，str→str</td>
<td>4</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移位</td>
<td>左</td>
<td>2</td>
<td>int，int→int</td>
<td>5</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移位以符号填充</td>
<td>左</td>
<td>2</td>
<td>int，int→int</td>
<td>5</td>
</tr>
<tr>
<td>&gt;&gt;&gt;</td>
<td>右移位以零填充</td>
<td>左</td>
<td>2</td>
<td>int，int→int</td>
<td>5</td>
</tr>
<tr>
<td>&lt;、&lt;=、&gt;、&gt;=</td>
<td>按数值顺序比较</td>
<td>左</td>
<td>2</td>
<td>num，num→bool</td>
<td>6</td>
</tr>
<tr>
<td>&lt;、&lt;=、&gt;、&gt;=</td>
<td>按字母表顺序比较</td>
<td>左</td>
<td>2</td>
<td>str，str→bool</td>
<td>6</td>
</tr>
<tr>
<td>instanceof</td>
<td>测试对象类</td>
<td>左</td>
<td>2</td>
<td>obj，func→bool</td>
<td>6</td>
</tr>
<tr>
<td>in</td>
<td>测试属性是否存在</td>
<td>左</td>
<td>2</td>
<td>any，obj→bool</td>
<td>6</td>
</tr>
<tr>
<td>==</td>
<td>非严格相等测试</td>
<td>左</td>
<td>2</td>
<td>any，any→bool</td>
<td>7</td>
</tr>
<tr>
<td>!=</td>
<td>非严格不相等测试</td>
<td>左</td>
<td>2</td>
<td>any，any→bool</td>
<td>7</td>
</tr>
<tr>
<td>===</td>
<td>严格相等测试</td>
<td>左</td>
<td>2</td>
<td>any，any→bool</td>
<td>7</td>
</tr>
<tr>
<td>!==</td>
<td>严格不相等测试</td>
<td>左</td>
<td>2</td>
<td>any，any→bool</td>
<td>8</td>
</tr>
<tr>
<td>&amp;</td>
<td>计算按位与</td>
<td>左</td>
<td>2</td>
<td>int，int→int</td>
<td>9</td>
</tr>
<tr>
<td>^</td>
<td>计算按位异或</td>
<td>左</td>
<td>2</td>
<td>int，int→int</td>
<td>10</td>
</tr>
<tr>
<td>|</td>
<td>计算按位或</td>
<td>左</td>
<td>2</td>
<td>int，int→int</td>
<td>11</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>计算逻辑与</td>
<td>左</td>
<td>2</td>
<td>any，any→any</td>
<td>12</td>
</tr>
<tr>
<td>||</td>
<td>计算逻辑或</td>
<td>左</td>
<td>2</td>
<td>any，any→any</td>
<td>13</td>
</tr>
<tr>
<td>? ?</td>
<td>选择第一个有定义的操作数</td>
<td>左</td>
<td>2</td>
<td>any，any→any</td>
<td>14</td>
</tr>
<tr>
<td>? :</td>
<td>选择第二或第三个操作数</td>
<td>右</td>
<td>3</td>
<td>bool，any，any→any</td>
<td>15</td>
</tr>
<tr>
<td>=</td>
<td>为变量或属性赋值</td>
<td>右</td>
<td>2</td>
<td>lval，any→any</td>
<td>16</td>
</tr>
<tr>
<td>**=、/=、%= ……</td>
<td>操作并赋值</td>
<td>右</td>
<td>2</td>
<td>lval，any→any</td>
<td>16</td>
</tr>
<tr>
<td>,</td>
<td>丢弃第一个操作数，返回第二个</td>
<td>左</td>
<td>2</td>
<td>any，any→any</td>
<td>17</td>
</tr>
</tbody></table>
<ul>
<li><p>结合性：规定相同优先级操作的执行顺序</p>
</li>
<li><p>操作数：操作符期待的操作数个数</p>
</li>
<li><p>类型：操作数期待的类型 → 结果类型</p>
<blockquote>
<p>lval：即 lvalue（左值），包括变量、对象属性和数组元素</p>
</blockquote>
</li>
</ul>
<h3 id="算数表达式"><a href="#算数表达式" class="headerlink" title="算数表达式"></a>算数表达式</h3><p>基本的算术操作符：**（幂）、*（乘）、/（除）、%（模）、+（加）和 -（减）</p>
<p>基本操作符会对操作数转换为数值进行求值，无法转换的转换为 <code>NaN</code>，操作结果为 <code>NaN</code></p>
<p>在 JavaScript 中，所有数值都是浮点数，如 <code>5/2 = 2.5</code></p>
<h4 id="操作符-1"><a href="#操作符-1" class="headerlink" title="+ 操作符"></a>+ 操作符</h4><p>二元 + 操作符用于计算数值操作数的和或拼接字符串</p>
<p>严格讲，+ 操作符遵循以下行为</p>
<ul>
<li>若一个操作数为对象，则+ 操作符将对象转换为原始值。Date 对象用 <code>toString()</code> 方法转换，其他对象通过 <code>valueOf()</code> 转换（若此方法返回原始值），无此方法通过 <code>toString()</code> 方法转换</li>
<li>完成对象转换到原始值，若操作数有字符串，另一个操作数也转成字符串拼接</li>
<li>否则，两个操作数转超数值（或 <code>NaN</code>），计算加法</li>
</ul>
<h4 id="一元算术操作符"><a href="#一元算术操作符" class="headerlink" title="一元算术操作符"></a>一元算术操作符</h4><ul>
<li>一元加（+）</li>
<li>一元减（-）</li>
<li>递增（++）</li>
<li>递减（–）</li>
</ul>
<h4 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h4><p>位操作符将数值当成 32 位整数而不是 64 位浮点数，转换时会丢弃小数部分和 32 位以外的部分</p>
<p><code>NaN</code>、<code>Infinity</code>、<code>-Infinity</code> 作为位操作符的操作数转换为 0</p>
<p>除了 &gt;&gt;&gt; 的操作符都可用于 <code>BigInt</code> 操作数</p>
<ul>
<li><p>按位与（&amp;）</p>
</li>
<li><p>按位或（|）</p>
</li>
<li><p>按位异或（^）</p>
</li>
<li><p>按位非（~）</p>
<blockquote>
<p>因为 JavaScript表示用符号整数的方式，对一个值应用 ~ 操作符等于修改符号并减 1 </p>
<p>如：~0x0f 求值为 0xFFFFFFF0，即 -16</p>
</blockquote>
</li>
<li><p>左移（&lt;&lt;）</p>
</li>
<li><p>有符号右移（&gt;&gt;）</p>
<blockquote>
<p>若第一个操作数是正值，结果的高位填充 0</p>
<p>若第一个操作数是负值，结果的高位填充 1</p>
<p>右移 n 位等于这个值除以 $2^n$（丢弃余数）</p>
</blockquote>
</li>
<li><p>零填充右移（&gt;&gt;&gt;）</p>
<blockquote>
<p>无论第一个操作数的符号是什么，始终填充 0 </p>
</blockquote>
</li>
</ul>
<h3 id="关系表达式"><a href="#关系表达式" class="headerlink" title="关系表达式"></a>关系表达式</h3><p>关系操作符测试两个值之间的关系，并依据相应关系是否存在返回 <code>true</code> 或 <code>false</code></p>
<h4 id="相等和不相等操作符"><a href="#相等和不相等操作符" class="headerlink" title="相等和不相等操作符"></a>相等和不相等操作符</h4><p>严格相等（===）</p>
<ul>
<li>若两个值类型不同，不相等</li>
<li>两个值都是 <code>null</code> 或 <code>undefined</code>，相等</li>
<li>两个值都是 <code>true</code> 或 <code>false</code>，相等</li>
<li>一个值或两个值是 <code>NaN</code>，不相等</li>
<li>两个值都是数值且值相同，相等</li>
<li>两个值引用同一个对象、数组或函数，相等</li>
</ul>
<p>基于类型转换的相等（==）</p>
<ul>
<li>两个值类型相同，按严格相等测试</li>
<li>两个值类型不同<ul>
<li>一个值为 <code>null</code>，另一个值为 <code>undefined</code>，相等</li>
<li>一个为数值，一个为字符串，将字符串转为数值，比较</li>
<li>一个值为 <code>true</code>，转换为 1，比较；一个值为 <code>false</code>，转换为 0，比较</li>
<li>一个值为对象，另一个值为数值或字符串，用对象转原始值，比较</li>
</ul>
</li>
</ul>
<h4 id="in-操作符"><a href="#in-操作符" class="headerlink" title="in 操作符"></a>in 操作符</h4><p>in 操作符期待左侧操作数是字符串、符号或可以转换为字符串的值，右侧操作数是对象</p>
<p>若左侧的值是右侧的对象的属性名，则 in 返回 <code>true</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> point = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="string">&quot;x&quot;</span> <span class="keyword">in</span> point                    <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="string">&quot;z&quot;</span> <span class="keyword">in</span> point                    <span class="comment">// =&gt; false</span></span><br><span class="line"><span class="string">&quot;toString&quot;</span> <span class="keyword">in</span> point             <span class="comment">// =&gt; true：对象继承了 toString方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line"><span class="string">&quot;0&quot;</span> <span class="keyword">in</span> data                     <span class="comment">// =&gt; true：数组有元素 0</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">in</span> data                       <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">in</span> data                       <span class="comment">// =&gt; false：没有元素 3</span></span><br></pre></td></tr></table></figure>



<h4 id="instanceof-操作符"><a href="#instanceof-操作符" class="headerlink" title="instanceof 操作符"></a>instanceof 操作符</h4><p>instanceof 操作符期待左侧操作数是对象，右侧操作数是对象类的标识</p>
<p>左侧对象是右侧类的实例时返回 <code>true</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();      <span class="comment">// 通过 Date() 构造函数创建一个对象</span></span><br><span class="line">d <span class="keyword">instanceof</span> <span class="built_in">Date</span>        <span class="comment">// =&gt; true：d 是通过 Date() 创建的</span></span><br><span class="line">d <span class="keyword">instanceof</span> <span class="built_in">Object</span>      <span class="comment">// =&gt; true：所有对象都是 Object 的示例</span></span><br><span class="line">d <span class="keyword">instanceof</span> <span class="built_in">Number</span>      <span class="comment">// =&gt; false：d 不是 Number 对象</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];         <span class="comment">// 通过数组字面量语法创建一个数组</span></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Array</span>       <span class="comment">// =&gt; true：a 是个数组</span></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Object</span>      <span class="comment">// =&gt; true：所有数组都是对象</span></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>      <span class="comment">// =&gt; false：a 不是正则表达式</span></span><br></pre></td></tr></table></figure>

<p>若左侧操作数不是对象，返回 <code>false</code></p>
<p>若右侧操作数不是对象的类，抛出 <code>TypeError</code></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端学习</tag>
      </tags>
  </entry>
  <entry>
    <title>JS语句</title>
    <url>/2021/10/10/JS/JS%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<p>JavaScript 程序即一系列待执行的语句</p>
<span id="more"></span>

<p>JavaScript语句语法</p>
<table>
<thead>
<tr>
<th>语句</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>break</td>
<td>退出最内部循环、switch 或有名字的闭合语句</td>
</tr>
<tr>
<td>case</td>
<td>在 switch 中标记一条语句</td>
</tr>
<tr>
<td>class</td>
<td>声明一个类</td>
</tr>
<tr>
<td>const</td>
<td>声明并初始化一个或多个常量</td>
</tr>
<tr>
<td>continue</td>
<td>开始最内部循环或命名循环的下一次迭代</td>
</tr>
<tr>
<td>debugger</td>
<td>调试器断点</td>
</tr>
<tr>
<td>default</td>
<td>在 switch 中标记默认语句</td>
</tr>
<tr>
<td>do/while</td>
<td>替代 while 循环的一种结构</td>
</tr>
<tr>
<td>export</td>
<td>声明可以被导入其他模块的值</td>
</tr>
<tr>
<td>for</td>
<td>一种方便好用的循环</td>
</tr>
<tr>
<td>for/await</td>
<td>异步迭代异步迭代器的值</td>
</tr>
<tr>
<td>for/in</td>
<td>枚举对象的属性名</td>
</tr>
<tr>
<td>for/of</td>
<td>枚举可迭代对象（如数组）的值</td>
</tr>
<tr>
<td>function</td>
<td>声明一个函数</td>
</tr>
<tr>
<td>if/else</td>
<td>根据某个条件执行一个或另一个语句</td>
</tr>
<tr>
<td>import</td>
<td>为在其他模块中定义的值声明名字</td>
</tr>
<tr>
<td>label</td>
<td>标签名，为语句起名，以便与 break 和 continue 一起使用</td>
</tr>
<tr>
<td>let</td>
<td>声明并初始化一个或多个块作用域的变量（新语法）</td>
</tr>
<tr>
<td>return</td>
<td>从函数中返回一个值</td>
</tr>
<tr>
<td>switch</td>
<td>包含 case 或 default 标签的多分支结构</td>
</tr>
<tr>
<td>throw</td>
<td>抛出一个异常</td>
</tr>
<tr>
<td>try/catch/finally</td>
<td>处理异常和代码清理</td>
</tr>
<tr>
<td>”use strict“</td>
<td>对脚本或函数应用严格模式</td>
</tr>
<tr>
<td>var</td>
<td>声明并初始化一个或多个变量（老语法）</td>
</tr>
<tr>
<td>while</td>
<td>一种基本的循环结构</td>
</tr>
<tr>
<td>with</td>
<td>扩展作用域链（在严格模式下被废弃并禁止）</td>
</tr>
<tr>
<td>yield</td>
<td>提供一个被迭代的；只用在生成器函数中</td>
</tr>
</tbody></table>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>条件语句根据指定表达式的值执行或跳过执行某些语句</p>
<p><strong><code>if</code> 语句格式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (expression)</span><br><span class="line">    statement1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    statement2</span><br></pre></td></tr></table></figure>



<p><strong><code>else if</code> 语句格式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (expression1)&#123;</span><br><span class="line">    statement1</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(expression2)&#123;</span><br><span class="line">    statement2</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    statement3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><code>switch</code> 语句格式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> value1 :</span><br><span class="line">        statement1</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value2 :</span><br><span class="line">        statement2</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span> :</span><br><span class="line">        statement3</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>switch</code> 语句实例：根据值的类型决定怎么转换字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convert</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(<span class="keyword">typeof</span> x)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;number&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> x.toString(<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;string&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&quot;&#x27;</span>+ x + <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">String</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>循环语句可以重复执行代码中的某些部分</p>
<p><strong><code>while</code> 语句格式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (expression)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>



<p><strong><code>do/while</code> 语句格式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">    statement</span><br><span class="line"><span class="keyword">while</span> (expression)</span><br></pre></td></tr></table></figure>

<p><code>do/while</code> 保证循环体至少执行一次，<code>do/while</code> 语句实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printArray</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = a.length, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(len === <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Empty Array&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(a[i]);</span><br><span class="line">        &#125;<span class="keyword">while</span>(++i &lt; len)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><code>for</code> 语句格式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(initialize ; test ; increment)&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>initialize</code>：初始化</li>
<li><code>test</code>：测试</li>
<li><code>increment</code>：递增循环变量</li>
</ul>
<p><code>for</code> 语句实例：遍历链表，返回列表最后一个对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tail</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; o.next; o = o.next);   <span class="comment">// 空循环体，o.next 为真值时遍历</span></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><code>for/of</code> 语句</strong></p>
<p>ES6 新增循环语句，专门用于可迭代对象</p>
<ul>
<li><p><code>for/of</code> 与对象</p>
<p>对象（默认）不可迭代，运行 <code>for/of</code> 语句会抛出 <code>TypeError</code>，若想迭代对象属性，可以使用 <code>for/in</code> 循环，或者基于 <code>Object.keys()</code> 方法</p>
<blockquote>
<p><code>Object.keys()</code> 返回一个对象属性名的数组</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> keys = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="function"><span class="title">fot</span>(<span class="params"><span class="keyword">let</span> k <span class="keyword">of</span> <span class="built_in">Object</span>.keys(o)</span>)</span>&#123;</span><br><span class="line">    keys += k;</span><br><span class="line">&#125;</span><br><span class="line">keys    <span class="comment">// =&gt; &quot;xyz&quot;</span></span><br></pre></td></tr></table></figure>

<p>若不考虑对象的键，可以调用<code>Object.values()</code> 方法迭代每个键对应的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> <span class="built_in">Object</span>.values(o))&#123;</span><br><span class="line">    sum += v;</span><br><span class="line">&#125;</span><br><span class="line">sum     <span class="comment">// =&gt; 6</span></span><br></pre></td></tr></table></figure>

<p>若及想要对象属性的键，也想要属性的值，可以基于<code>Object.entries()</code> 方法和解构赋值得</p>
<blockquote>
<p><code>Object.entries()</code> 返回一个数组的数组，每个内部数组表示对象的一个属性键值对</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pairs = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [k,v] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(o))&#123;</span><br><span class="line">    pairs += k + v;</span><br><span class="line">&#125;</span><br><span class="line">pairs    <span class="comment">// =&gt; &quot;x1y2z3&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>for/of</code> 与字符串</p>
<p>字符串在 ES6 中是可以逐个字符迭代的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> frequency = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> letter <span class="keyword">of</span> <span class="string">&quot;mississippi&quot;</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(frequency[letter])&#123;</span><br><span class="line">        frequency[letter]++;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        frequency[letter] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">frequency    <span class="comment">// =&gt; &#123;m: 1, i: 4, s: 4, p: 2&#125;</span></span><br></pre></td></tr></table></figure>

<p>字符串迭代是按照 <code>Unicode</code> 码点而不是 <code>UTF-16</code> 字符迭代</p>
</li>
<li><p><code>for/of</code> 与 <code>Set</code> 和 <code>Map</code></p>
<p>ES6 内置的  <code>Set</code>（集合） 和 <code>Map</code>（映射）类是可迭代的</p>
<p>迭代 <code>Set</code> 时，循环体对集合中的每个元素都运行一次</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;Na na na na na na na na Batman!&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> wordSet = <span class="keyword">new</span> <span class="built_in">Set</span>(text.split(<span class="string">&quot; &quot;</span>));</span><br><span class="line"><span class="keyword">let</span> unique = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> word <span class="keyword">of</span> wordSet)&#123;</span><br><span class="line">    unique.push(word);</span><br><span class="line">&#125;</span><br><span class="line">unique    <span class="comment">// =&gt; [&quot;Na&quot;, &quot;na&quot;, &quot;Batman!&quot;]</span></span><br></pre></td></tr></table></figure>

<p> <code>Map</code> 对象迭代器迭代的是键值对，每次迭代，迭代器返回一个数组，其第一个元素是键，第一个元素是对应的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&quot;one&quot;</span>]]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key, value] <span class="keyword">of</span> m)&#123;</span><br><span class="line">    key        <span class="comment">// =&gt; 1</span></span><br><span class="line">    value      <span class="comment">// =&gt; &quot;one&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>for/await</code> 与异步迭代</p>
<p>ES2018 新增异步迭代器和使用异步迭代器的 <code>for/await</code> 循环</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从异步可迭代流中读取数据块并将其打印出来</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">printStream</span>(<span class="params">stream</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> chunk <span class="keyword">of</span> stream)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(chunk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong><code>for/in</code> 语句格式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(variable <span class="keyword">in</span> object)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>

<ul>
<li><code>variable</code>：通常是一个变量名，也可以是左值</li>
<li><code>object</code>：求值为对象的表达式，若求值为 <code>null</code> 或 <code>undefined</code> 解释器跳过循环</li>
<li><code>statement</code>：语句块</li>
</ul>
<p><code>for/in</code> 循环的 <code>in</code> 后面可以是任意对象，<code>for/in</code> 语句实例：把一个对象的所有属性复制到数组中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> a = [], i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(a[i++] <span class="keyword">in</span> o)</span><br><span class="line">a       <span class="comment">// [ &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27; ]</span></span><br></pre></td></tr></table></figure>

<p><code>for/in</code> 循环不会枚举对象的所有属性，如名字为符号的属性</p>
<h2 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h2><p>跳转语句会导致 JavaScript 解释器跳转到源代码的新位置</p>
<p><strong>语义标签格式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">identifier: statement</span><br></pre></td></tr></table></figure>

<p>通常前置一个标识符和一个冒号，为语句添加标签，语义标签实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mainloop: <span class="keyword">while</span>(token !== <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="comment">// 省略的代码</span></span><br><span class="line">    <span class="keyword">continue</span> mainloop;    <span class="comment">// 跳到命名循环的下一次迭代</span></span><br><span class="line">    <span class="comment">// 省略的其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>identifier</code> 可以是任何合法的 JavaScript 标识符（非保留字）</p>
<p>这些标签与变量和函数不在同一命名空间，则同一标识符既可以作为标签，也可以作为变量名或函数名</p>
<p>若两条语句有嵌套关系，不能使用相同的标签</p>
<p>任何语句都可以有多个标签</p>
<p><strong><code>break</code> 语句</strong></p>
<p><code>break</code> 语句用于退出某个语句块，如包含它的循环或 <code>switch</code> 语句立即退出</p>
<p>JavaScript 允许<code>break</code> 关键字后面跟一个语句标签 <code>break labelname;</code>，当后面跟标签后，跳转到指定标签的包含语句的末尾或终止该语句</p>
<p><code>break</code> 语句示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> matrix = getData();    <span class="comment">// 从某个地方取得一个数值的二维数组</span></span><br><span class="line"><span class="comment">// 计算矩阵中所有数值之和</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>, success = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 从一个加标签的语句开始，出错就中断</span></span><br><span class="line">computeSum: <span class="keyword">if</span>(matrix)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> x = <span class="number">0</span>; x &lt; matrix.length; x++)&#123;</span><br><span class="line">        <span class="keyword">let</span> row = matrix[x];</span><br><span class="line">        <span class="keyword">if</span>(!row) <span class="keyword">break</span> computeSum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> y = <span class="number">0</span>; y &lt; row.length; y++)&#123;</span><br><span class="line">            <span class="keyword">let</span> cell = row[y];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isNaN</span>(cell)) <span class="keyword">break</span> computeSum;</span><br><span class="line">            sum += cell;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    success = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// break 语句跳转到这，若此时 success == false</span></span><br><span class="line"><span class="comment">// 表明得到的 matrix 有问题</span></span><br><span class="line"><span class="comment">// 否则，sum 包含矩阵所有元素之和</span></span><br></pre></td></tr></table></figure>



<p><strong><code>continue</code> 语句</strong></p>
<p><code>continue</code> 语句不会退出循环，而是从头开始执行循环的下一次迭代</p>
<p>JavaScript 允许<code>continue</code> 关键字后面跟一个语句标签 <code>continue labelname;</code>，无论带不带标签，<code>continue</code> 语句只能在循环体内使用</p>
<p><strong><code>return</code> 语句</strong></p>
<p><code>return</code> 语句指定函数调用的返回值</p>
<p><strong><code>yield</code> 语句</strong></p>
<p><code>yield</code> 语句类似于 <code>return</code> 语句，但只用在 ES6 新增的生成器函数中，以回送生成的值序列中的下一个值，同时又不会真正返回</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回送一系列整数的生成器函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">range</span>(<span class="params"><span class="keyword">from</span>, to</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="keyword">from</span>; i &lt;= to; i++)&#123;</span><br><span class="line">        <span class="keyword">yield</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><code>throw</code> 语句格式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> expression;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>expression</code>：可以为任何类型的值，可以抛出一个表示错误码的数值或者包含可读的错误消息的字符串</li>
</ul>
<p>异常是一种信号，表示发生了某种意外情形或错误</p>
<p>抛出（throw）异常是为了表明发生了这种错误或意外情形</p>
<p>捕获（catch）异常则是要处理它，采取必要或对应的措施以从异常中恢复</p>
<p>JavaScript 解释器在抛出错误时会使用 <code>Error</code> 类及其子类，<code>Error</code> 对象有一个 <code>name</code> 属性和 <code>message</code> 属性，分别用于指定错误类型和保存传入构造函数的字符串</p>
<p><code>throw</code> 语句示例：收到无效参数时抛出一个 <code>Error</code> 对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 如果收到的参数无效，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;x must not be negatice&quot;</span>);</span><br><span class="line">    <span class="comment">// 否则，计算一个值并正常返回</span></span><br><span class="line">    <span class="keyword">let</span> f;</span><br><span class="line">    <span class="keyword">for</span>(f = <span class="number">1</span>; x &gt; <span class="number">1</span>; f *= x, x--)  <span class="comment">/* 空语句 */</span>;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">factorial(<span class="number">4</span>);    <span class="comment">// =&gt; 24</span></span><br></pre></td></tr></table></figure>



<p><strong><code>try/catch/finally</code> 语句格式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 正常情况下，这里的代码顺序执行</span></span><br><span class="line">    <span class="comment">// 遇到异常，通过 throw 抛出异常</span></span><br><span class="line">    <span class="comment">// 或由于调用一个抛出异常的方法而抛出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    <span class="comment">// 当且仅当 try 块抛出异常时，才会执行catch语句</span></span><br><span class="line">    <span class="comment">// 可以使用局部变量 e 引用被抛出的 Error 对象</span></span><br><span class="line">    <span class="comment">// 也可以忽略异常</span></span><br><span class="line">    <span class="comment">// 还可以通过 throw 重新抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// 无论 try 块中发生什么，这里的代码都会执行</span></span><br><span class="line">    <span class="comment">// 无论 try 块是否终止，这些语句都会执行</span></span><br><span class="line">    <span class="comment">//    1）正常情况下，在到达 try 块底部时执行</span></span><br><span class="line">    <span class="comment">//    2）由于 break、continue 或 return 语句而执行</span></span><br><span class="line">    <span class="comment">//    3）由于上面的 catch 子句处理了异常而执行</span></span><br><span class="line">    <span class="comment">//    4）由于异常未被处理而继续传播而执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>try/catch/finally</code> 语句是 JavaScript 的异常处理机制</p>
<p><code>catch</code> 关键字跟着个标识符 e。这个标识符类似函数的参数。捕获异常时，与异常关联的值（如 <code>Error</code> 对象）会被赋给这个参数</p>
<h2 id="其他语句"><a href="#其他语句" class="headerlink" title="其他语句"></a>其他语句</h2><p><strong><code>debugger</code> 语句</strong></p>
<p>使用浏览器并且打开开发者控制台，可以使用<code>debugger</code> 语句设置断点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(o === <span class="literal">undefined</span>) <span class="keyword">debugger</span>;    <span class="comment">// 仅为调试添加</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上述例子，调用 <code>f()</code> 而不传参数，执行会停止，使用调试器检查调用栈，可以找到这个错误的调用来源</p>
<p><strong><code>use strict</code> 语句</strong></p>
<p><code>use strict</code> 语句开启严格模式</p>
<p>严格模式与非严格模式的区别</p>
<ul>
<li>严格模式下不允许使用 <code>with</code> 语句</li>
<li>在严格模式下，所有变量必须声明，若不声明会抛出 <code>ReferenceError</code> （非严格模式下，给全局对象的属性赋值会隐式声明一个全局变量，即给全局对象添加一个新属性）</li>
<li>在严格模式下，函数若作为函数（非方法）被调用，其 <code>this</code> 值为 <code>undefined</code>（非严格模式下，作为函数调用的函数始终以全局对象作为 <code>this</code> 的值），并且，若函数通过 <code>cell()</code> 或 <code>apply()</code> 调用，则 <code>this</code> 值就是作为第一个参数传给 <code>cell()</code> 或 <code>apply()</code> 的值（非严格模式下，<code>null</code> 或 <code>undefined</code> 值会被替换为全局对象，而非对象值会被转换为对象）</li>
<li>在严格模式下，给不可写的属性赋值或尝试在不可扩展的对象上创建新属性会抛出 <code>TypeError</code>（非严格模式下，静默失败）</li>
<li>在严格模式下，传给 <code>eval()</code> 的代码不能再调用者的作用域声明变量或定义函数，会存在于一个为 <code>eval()</code> 创建的新作用域，这个作用域在 <code>eval()</code> 返回时销毁</li>
<li>在严格模式下，函数中的 <code>Arguments()</code> 对象保存着以跟传给函数的值的静态副本</li>
<li>在严格模式下，若 <code>delete</code> 后跟变量、函数或函数参数，会导致抛出 <code>SyntaxError</code>（非严格模式下，返回 <code>false</code>）</li>
<li>在严格模式下，尝试删除一个不可配置的属性会导致抛出 <code>TypeError</code></li>
<li>在严格模式下，对象字面量定义两个或多个同名属性是语法错误</li>
<li>在严格模式下，函数声明中有两个或多个同名参数是语法错误</li>
<li>在严格模式下，不允许使用八进制整数字面量</li>
<li>在严格模式下，标识符 <code>eval</code> 和 <code>arguments</code> 被当作关键字，不允许修改</li>
<li>在严格模式下，检查调用栈的能力受限</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端学习</tag>
      </tags>
  </entry>
  <entry>
    <title>JS迭代器与生成器</title>
    <url>/2021/10/30/JS/JS%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<p>可迭代对象及其相关的迭代器是 ES6 的一个特性，数组（包括 Typed Array）、字符串、Set 对象和 Map 对象都是可迭代的，即可以通过 <code>for/of</code> 循环来迭代</p>
<span id="more"></span>

<p>迭代器让 <code>...</code> 操作符能展开或“扩展”可迭代对象，如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> chars = [...<span class="string">&quot;abcd&quot;</span>];        <span class="comment">// =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span></span><br><span class="line"><span class="keyword">let</span> data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">Math</span>.max(...data)               <span class="comment">// =&gt; 5</span></span><br></pre></td></tr></table></figure>

<p>迭代 Map 对象时，返回值是 [key, value] 对，在 <code>for/of</code> 循环中可直接使用解构赋值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&quot;one&quot;</span>, <span class="number">1</span>], [<span class="string">&quot;two&quot;</span>, <span class="number">2</span>]]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [k,v] <span class="keyword">of</span> m) <span class="built_in">console</span>.log(k, v);      <span class="comment">// 打印&#x27;one 1&#x27;和&#x27;two 2&#x27;</span></span><br></pre></td></tr></table></figure>

<p>若只想迭代键或值，可以使用 <code>keys()</code> 或 <code>values()</code> 方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[...m]                <span class="comment">// =&gt; [[&quot;one&quot;, 1], [&quot;two&quot;, 2]]:默认迭代</span></span><br><span class="line">[...m.entries()]      <span class="comment">// =&gt; [[&quot;one&quot;, 1], [&quot;two&quot;, 2]]:entries()方法相同</span></span><br><span class="line">[...m.keys()]         <span class="comment">// =&gt; [&quot;one&quot;, &quot;two&quot;]:keys()方法只迭代键</span></span><br><span class="line">[...m.values()]       <span class="comment">// =&gt; [1, 2]:values()方法只迭代值</span></span><br></pre></td></tr></table></figure>



<h2 id="迭代器原理"><a href="#迭代器原理" class="headerlink" title="迭代器原理"></a>迭代器原理</h2><ul>
<li><p>可迭代对象</p>
<p>可迭代对象指的是任何具有专门迭代器方法，且该方法返回迭代器对象的对象</p>
</li>
<li><p>迭代器对象</p>
<p>迭代器对象指的是任何具有 <code>next()</code> 方法，且该方法返回迭代结果对象的对象</p>
</li>
<li><p>迭代结果对象</p>
<p>迭代结果对象是具有属性 <code>value</code> 和 <code>done</code> 的对象</p>
</li>
</ul>
<p>迭代一个可迭代对象，首先要调用其迭代器方法获得一个迭代器对象，然后重复调用这个迭代器对象的 <code>next()</code> 方法，直至返回 <code>done</code> 属性为 <code>true</code> 的迭代结果对象</p>
<p>可迭代对象的迭代器方法使用符号 <code>Symbol.iterator</code> 作为名字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单for/of循环也可以写成如下形式（可迭代对象iterator）</span></span><br><span class="line"><span class="keyword">let</span> iterable = [<span class="number">99</span>];</span><br><span class="line"><span class="keyword">let</span> iterator = iterable[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> result = iterator.next(); !result.done; result = iterator.next())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result.value)      <span class="comment">// result.value == 99</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内置可迭代数据类型的迭代器对象本身也是可迭代的，即其有一个名为 <code>Symbol.iterator</code> 的方法，返回它们自己</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 迭代“部分使用”的迭代器</span></span><br><span class="line"><span class="keyword">let</span> list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> iter = list[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="keyword">let</span> head = iter.next().value;        <span class="comment">// head == 1</span></span><br><span class="line"><span class="keyword">let</span> tail = [...iter];                <span class="comment">// tail == [2,3,4,5]</span></span><br></pre></td></tr></table></figure>







<h2 id="实现可迭代对象"><a href="#实现可迭代对象" class="headerlink" title="实现可迭代对象"></a>实现可迭代对象</h2><p>实现类可迭代，需要定义一个名为 <code>Symbol.iterator</code> 的方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可迭代的数值Range类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Range对象表示一个数值范围&#123;x: from &lt;= x &lt;= to&#125;</span></span><br><span class="line"><span class="comment"> * Range定义了has()方法用于测试给定数值是不是该范围的成员</span></span><br><span class="line"><span class="comment"> * Range是可迭代的，迭代其范围内的所有整数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Range</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">from</span>, to</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.from = <span class="keyword">from</span>;</span><br><span class="line">        <span class="built_in">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 让Range对象像数值的集合一样</span></span><br><span class="line">    <span class="function"><span class="title">has</span>(<span class="params">x</span>)</span> &#123; <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">&quot;number&quot;</span> &amp;&amp; <span class="built_in">this</span>.from &lt;= x &amp;&amp; x &lt;= <span class="built_in">this</span>.to; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用集合表示法返回当前范围的字符串表示</span></span><br><span class="line">    <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> <span class="string">`&#123; x | <span class="subst">$&#123;<span class="built_in">this</span>.<span class="keyword">from</span>&#125;</span> &lt;= x &lt;= &#123;this.to&#125;&#125;`</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过返回一个迭代器对象，让Range对象可迭代</span></span><br><span class="line">    <span class="comment">// 这个方法的名字是一个特殊符号，不是字符串</span></span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]()&#123;</span><br><span class="line">        <span class="comment">// 每个迭代器示例必须相互独立、互不影响地迭代自己的范围</span></span><br><span class="line">        <span class="comment">// 需要一个状态变量跟踪迭代的位置，从第一个大于等于from的整数开始</span></span><br><span class="line">        <span class="keyword">let</span> next = <span class="built_in">Math</span>.ceil(<span class="built_in">this</span>.from);         <span class="comment">// 下一个要返回的值</span></span><br><span class="line">        <span class="keyword">let</span> last = <span class="built_in">this</span>.to;                      <span class="comment">// 不会返回大于这个值的值</span></span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            <span class="comment">// next()方法是迭代器对象的标志，必须返回一个迭代器结果对象</span></span><br><span class="line">            <span class="function"><span class="title">next</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (next &lt;= last)            <span class="comment">// 若还没有返回last </span></span><br><span class="line">                    ? &#123; <span class="attr">value</span>: next++ &#125;          <span class="comment">// 返回next并给它加1</span></span><br><span class="line">                	: &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;            <span class="comment">// 否则返回表示完成的对象</span></span><br><span class="line">            &#125;,</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 为了方便，让迭代器本身也可迭代</span></span><br><span class="line">            [<span class="built_in">Symbol</span>.iterator]() &#123; <span class="keyword">return</span> <span class="built_in">this</span>; &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">of</span> <span class="keyword">new</span> Range(<span class="number">1</span>, <span class="number">10</span>)) <span class="built_in">console</span>.log(x);   <span class="comment">// 打印数值1到10</span></span><br><span class="line">[...new Range(-<span class="number">2</span>, <span class="number">2</span>)];                           <span class="comment">// =&gt; [-2, -1, 0, 1, 2]</span></span><br></pre></td></tr></table></figure>

<p>定义返回可迭代值的函数，以下两个函数可以代替 JavaScript 数组的 <code>map()</code> 和 <code>filter()</code> 方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个可迭代对象，迭代的结果是对传入的</span></span><br><span class="line"><span class="comment">// 可迭代对象的每个值应用f()的结果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params">iterable, f</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> iterator = iterable[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">    <span class="keyword">return</span>&#123;            <span class="comment">// 这个对象既是迭代器也是可迭代对象</span></span><br><span class="line">        [<span class="built_in">Symbol</span>.iterator]() &#123; <span class="keyword">return</span> <span class="built_in">this</span>; &#125;,</span><br><span class="line">        <span class="function"><span class="title">next</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> v = iterator.next();</span><br><span class="line">            <span class="keyword">if</span>(v.done)&#123;</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123; <span class="attr">value</span>: f(v,value) &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把一个范围内的整数映射为它们的平方并转换为一个数组</span></span><br><span class="line">[..map(<span class="keyword">new</span> Range(<span class="number">1</span>,<span class="number">4</span>), <span class="function"><span class="params">x</span> =&gt;</span> x * x)]     <span class="comment">// =&gt; [1, 4, 9, 16]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个可迭代对象</span></span><br><span class="line"><span class="comment">// 只迭代predicate返回true的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params">iterable,predicate</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> iterator = iterable[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">    <span class="keyword">return</span> &#123;           <span class="comment">// 这个对象既是迭代器也是可迭代对象</span></span><br><span class="line">        [<span class="built_in">Symbol</span>.iterator]() &#123; <span class="keyword">return</span> <span class="built_in">this</span>; &#125;,</span><br><span class="line">        <span class="function"><span class="title">next</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">                <span class="keyword">let</span> v = iterator.next();</span><br><span class="line">                <span class="keyword">if</span>(v.done || predicate(v.value))&#123;</span><br><span class="line">                    <span class="keyword">return</span> v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 筛选整数范围，只保留偶数</span></span><br><span class="line">[...filter(<span class="keyword">new</span> Range(<span class="number">1</span>,<span class="number">10</span>), <span class="function"><span class="params">x</span> =&gt;</span> x % <span class="number">2</span> === <span class="number">0</span>)]      <span class="comment">// =&gt; [2,4,6,8,10]</span></span><br></pre></td></tr></table></figure>

<p>可迭代对象和迭代器有一个重要的特点，即天性懒惰：如果计算下一个值需要一定计算量，则相应计算会推迟到实际需要下一个值的时候再发生</p>
<p>示例：存在一个很长的字符串，要对其进行分词，返回以空格分隔的单词，若使用字符串的 <code>split()</code> 方法，哪怕一个单词不用也要处理整个字符串，这样可能会占用很多内存来保存返回的数组和其中的字符串。如下定义一个函数，对字符串的单词懒惰迭代，不必将其全部保存在内存里</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">words</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> r = <span class="regexp">/\s+|$/g</span>;                           <span class="comment">// 匹配一个或多个空格或末尾</span></span><br><span class="line">    r.lastIndex = s.match(<span class="regexp">/[^ ]/</span>).index;        <span class="comment">// 开始匹配第一个非空格</span></span><br><span class="line">    <span class="keyword">return</span>&#123;                                     <span class="comment">// 返回一个可迭代的迭代器对象</span></span><br><span class="line">        [<span class="built_in">Symbol</span>.iterator]() &#123; <span class="keyword">return</span> <span class="built_in">this</span>; &#125;,   <span class="comment">// 这个方法是可迭代对象必需的</span></span><br><span class="line">        <span class="function"><span class="title">next</span>(<span class="params"></span>)</span>&#123;                                 <span class="comment">// 这个方法是迭代器必需的</span></span><br><span class="line">            <span class="keyword">let</span> start = r.lastIndex;            <span class="comment">// 从上次匹配结束的地方恢复</span></span><br><span class="line">            <span class="keyword">if</span>(start &lt; s.length)&#123;               <span class="comment">// 若还没处理完</span></span><br><span class="line">                <span class="keyword">let</span> match = r.exec(s);          <span class="comment">// 匹配下一个单词边界</span></span><br><span class="line">                <span class="keyword">if</span>(match)&#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123; <span class="attr">value</span>: s.substring(start, match.index) &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;              <span class="comment">// 否则，返回表示处理完成的结果</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[...words(<span class="string">&quot; abc deff  ghi! &quot;</span>)]                  <span class="comment">// =&gt; [&quot;abc&quot;, &quot;def&quot;, &quot;ghi!&quot;]</span></span><br></pre></td></tr></table></figure>



<p><strong>关闭迭代器：<code>return()</code> 方法</strong></p>
<p>若迭代在 <code>next()</code> 返回 <code>done</code> 属性为 <code>true</code> 的迭代结果之前停止（通常是因为通过 <code>break</code> 语句提前退出 <code>for/of</code> 循环），解释器就会检测迭代器对象是否有 <code>return()</code> 方法，若有，解释器会调用它（不传参），让迭代器有机会关闭文件、释放内存，或者做一些其他清理工作</p>
<p><code>return()</code> 方法必须返回一个迭代器结果对象</p>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>生成器是一种用新 ES6 语法定义的迭代器，适合与要迭代的值不是某个数据结构的元素，而是计算结果的场景</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个生成器函数回送一组素数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">oneDigitPrimes</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 调用这个函数不会运行函数体</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;                <span class="comment">// 只会返回一个生成器对象。调用</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;                <span class="comment">// 该对象的next()开始运行，直至一个yield语句</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;                <span class="comment">// 为next()方法提供返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用生成器函数，得到一个生成器</span></span><br><span class="line"><span class="keyword">let</span> primes = oneDigitPrimes();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成器是一个迭代器对象，可以迭代回送的值</span></span><br><span class="line">primes.next(). value        <span class="comment">// =&gt; 2</span></span><br><span class="line">primes.next(). value        <span class="comment">// =&gt; 3</span></span><br><span class="line">primes.next(). value        <span class="comment">// =&gt; 5</span></span><br><span class="line">primes.next(). done         <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成器有一个Symbol.iterator方法，因此也是可迭代对象</span></span><br><span class="line">primes[<span class="built_in">Symbol</span>.iterator]()   <span class="comment">// =&gt; primes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以像使用其他可迭代对象一样使用生成器</span></span><br><span class="line">[...oneDigitPrimes()]       <span class="comment">// =&gt; [2,3,5]</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> prime <span class="keyword">of</span> oneDigitPrimes()) sum += prime;</span><br><span class="line">sum                         <span class="comment">// =&gt; 10</span></span><br></pre></td></tr></table></figure>

<p>生成器函数用 <code>function*</code> 定义，与常规函数一样，也可以使用表达式定义生成器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> seq = <span class="function"><span class="keyword">function</span>*(<span class="params"><span class="keyword">from</span>, to</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="keyword">from</span>; i &lt;= to; i++) <span class="keyword">yield</span> i;</span><br><span class="line">&#125;;</span><br><span class="line">[...seq(<span class="number">3</span>,<span class="number">5</span>)]        <span class="comment">// =&gt; [3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p>在类和对象字面量中，定义方法时可以使用件写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="comment">// 这个生成器会回送当前对象的每个键</span></span><br><span class="line">    *<span class="function"><span class="title">g</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>))&#123;</span><br><span class="line">            <span class="keyword">yield</span> key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">[...o.g()]      <span class="comment">// =&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;g&quot;]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>不能使用箭头函数语法定义生成器函数</p>
</blockquote>
<h3 id="生成器示例"><a href="#生成器示例" class="headerlink" title="生成器示例"></a>生成器示例</h3><p>回送斐波那契数列</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibonacciSequence</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">0</span>, y = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="keyword">yield</span> y;</span><br><span class="line">        [x, y] = [y, x+y];     <span class="comment">// 注意，解构赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个生成器永远回送值而不返回，若通过扩展操作符使用它，会一直循环到内存耗尽，程序崩溃，可以设置退出条件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回第n个斐波那契数列</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> f <span class="keyword">of</span> fibonacciSequence())&#123;</span><br><span class="line">        <span class="keyword">if</span>(n-- &lt;= <span class="number">0</span>) <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fibonacci(<span class="number">20</span>)          <span class="comment">// =&gt; 10946</span></span><br></pre></td></tr></table></figure>

<p>配合如下的 <code>take()</code> 生成器，可以用更大用处</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回送指定可迭代对象的前n个元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">take</span>(<span class="params">n, iterable</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> it = iterable[<span class="built_in">Symbol</span>.iterator]();   <span class="comment">// 取得可迭代对象的生成器</span></span><br><span class="line">    <span class="keyword">while</span>(n-- &gt; <span class="number">0</span>)&#123;                         <span class="comment">// 循环n次</span></span><br><span class="line">        <span class="keyword">let</span> next = it.next();               <span class="comment">// 从迭代器中取得下一项</span></span><br><span class="line">        <span class="keyword">if</span>(next.done) <span class="keyword">return</span>;               <span class="comment">// 若没有更多的值，直接返回</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">yield</span> next.value;              <span class="comment">// 否则，回送这个值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含前5个斐波那契数列</span></span><br><span class="line">[...take(<span class="number">5</span>, fibonacciSequence())]           <span class="comment">// =&gt; [1, 1, 2, 3, 5]</span></span><br></pre></td></tr></table></figure>



<p>交替回送多个可迭代对象的元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拿到一个可迭代对象的数组，交替回送元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">zip</span>(<span class="params">...iterables</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 取得每个可迭代对象的迭代器</span></span><br><span class="line">    <span class="keyword">let</span> iterators = iterables.map(<span class="function"><span class="params">i</span> =&gt;</span> i[<span class="built_in">Symbol</span>.iterator]());</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(iterators.length &gt; <span class="number">0</span>)&#123;              <span class="comment">// 还有迭代器</span></span><br><span class="line">        <span class="keyword">if</span>(index &gt;= iterators.length)&#123;        <span class="comment">// 如果到了最后一个迭代器</span></span><br><span class="line">            index = <span class="number">0</span>;                        <span class="comment">// 返回至第一个迭代器</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> item = iterators[index].next();   <span class="comment">// 从一个迭代器中取得下一项</span></span><br><span class="line">        <span class="keyword">if</span>(item.done)&#123;                        <span class="comment">// 如果该迭代器完成</span></span><br><span class="line">            iterators.splice(index, <span class="number">1</span>);       <span class="comment">// 则从数组中删除它</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;                                <span class="comment">// 否则</span></span><br><span class="line">            <span class="keyword">yield</span> item.value;                 <span class="comment">// 回送迭代的值</span></span><br><span class="line">            index++;                          <span class="comment">// 并前进到下一个迭代器</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交替3个可迭代对象</span></span><br><span class="line">[...zip(oneDigitPrimes(),<span class="string">&quot;ab&quot;</span>,[<span class="number">0</span>])]           <span class="comment">// =&gt; [2,&quot;a&quot;,0,3,&quot;b&quot;,5]</span></span><br></pre></td></tr></table></figure>



<h3 id="yield-与递归生成器"><a href="#yield-与递归生成器" class="headerlink" title="yield* 与递归生成器"></a>yield* 与递归生成器</h3><p><code>yield*</code> 迭代可迭代对象并回送得到的每个值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">sequence</span>(<span class="params">...iterables</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> iterable <span class="keyword">of</span> iterables)&#123;</span><br><span class="line">        <span class="keyword">yield</span>* iterable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[...sequence(<span class="string">&quot;abc&quot;</span>,oneDigitPrimes())]   <span class="comment">// =&gt; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,2,3,5]</span></span><br></pre></td></tr></table></figure>

<p><code>yield*</code> 可以用于迭代任何可迭代对象，包括通过生成器实现的，即使用 <code>yield*</code> 可以定义递归生成器，利用这个特性可以通过简单的非递归迭代遍历递归定义的树结构</p>
<h2 id="高级生成器特性"><a href="#高级生成器特性" class="headerlink" title="高级生成器特性"></a>高级生成器特性</h2><p>生成器最常用于创建迭代器，生成器的基本特征是可以暂停计算，回送中间结果，在某个时刻恢复计算</p>
<h3 id="生成器函数的返回值"><a href="#生成器函数的返回值" class="headerlink" title="生成器函数的返回值"></a>生成器函数的返回值</h3><p>生成器函数的 <code>return</code> 语句多用于提前退出，而不是返回值，但是，生成器函数也可以返回值</p>
<p>手动迭代时可以通过显示调用返回</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">oneAndDone</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;done&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常迭代中不会出现返回值</span></span><br><span class="line">[...oneAndDone()]           <span class="comment">// =&gt; [1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式调用next()时可以得到</span></span><br><span class="line"><span class="keyword">let</span> generator = oneAndDone();</span><br><span class="line">generator.next()            <span class="comment">// =&gt; &#123; value: 1, done: false&#125;</span></span><br><span class="line">generator.next()            <span class="comment">// =&gt; &#123; value: &quot;done&quot;, done: true&#125;</span></span><br><span class="line"><span class="comment">// 如果生成器已经完成，则不再返回值</span></span><br><span class="line">generator.next()            <span class="comment">// =&gt; &#123; value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端学习 JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL存储引擎与数据库操作管理</title>
    <url>/2021/10/04/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>存储引擎即如何存储数据、如何为存储的数据建立索引和如何更新、查询数据的机制</p>
<p>在关系数据库中数据的存储以表的形式存储，所以存储引擎也可以称为表类型</p>
<span id="more"></span>

<p>MySQL提供插件式的存储引擎</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查看当前MySQL数据库支持的存储引擎</span></span><br><span class="line"><span class="keyword">SHOW</span> ENGINES ;</span><br><span class="line"><span class="keyword">SHOW</span> ENGINES \G</span><br><span class="line"><span class="comment">--查看当前数据库存储引擎</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%storage_engine%&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="InnoDB存储引擎（OLTP）"><a href="#InnoDB存储引擎（OLTP）" class="headerlink" title="InnoDB存储引擎（OLTP）"></a>InnoDB存储引擎（OLTP）</h4><p>InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键</p>
<ul>
<li>InnoDB给MySQL提供具有提交、回滚和崩溃恢复能力的事务安全（ACID兼容）存储引擎</li>
<li>InnoDB是为处理巨大数据量提供最大性能而设计的</li>
<li>InnoDB存储引擎完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池</li>
<li>InnoDB支持外键完整性约束</li>
<li>InnoDB被用在众多需要高性能的大型数据库站点上</li>
</ul>
<h4 id="MyISAM存储引擎（OLAP"><a href="#MyISAM存储引擎（OLAP" class="headerlink" title="MyISAM存储引擎（OLAP)"></a>MyISAM存储引擎（OLAP)</h4><p>MyISAM拥有较高的插入、查询速度，但不支持事务</p>
<ul>
<li>大文件（达63位文件长度）</li>
<li>当把删除和更新及插入操作混合使用时，动态尺寸的行产生更少碎片</li>
<li>每个MyISAM表最大索引数时64，可以通过重新编译来改变</li>
<li>BLOB和TEXT列可以被索引</li>
<li>NULL值被允许在索引的列中，占每个键的0或1个字节</li>
<li>所有数字键值以高字节优先为原则被存储，以允许一个更高的索引压缩</li>
<li>MyISAM类型表的<code>AUTO_INCREMENT</code>列更新比InnoDB类型的<code>AUTO_INCREMENT</code>更快</li>
<li>可以把数据文件和索引文件存储在不同的目录</li>
<li>每个字符列可以有不同的字符集</li>
<li><code>VARGHAR</code>的表可以固定或动态地记录长度</li>
</ul>
<p>使用该引擎会生成三个文件 ：  .FRM  .MYD  .MYI</p>
<h4 id="MEMORY存储引擎"><a href="#MEMORY存储引擎" class="headerlink" title="MEMORY存储引擎"></a>MEMORY存储引擎</h4><p>适合用于存储临时数据的临时表，以及数据仓库中的维度表（默认使用哈希索引）</p>
<ul>
<li>每个表可以有多达32个索引，每个索引16列，以及500字节的最大键长度</li>
<li>执行HASH和BTREE索引</li>
<li>在一个MEMORY表中可以有非唯一键</li>
<li>表使用一个固定的记录长度格式</li>
<li>不支持<code>BLOB</code>和<code>TEXT</code>列</li>
<li>支持<code>AUTO_INCREMENT</code>列和对可包含<code>NULL</code>值的列的索引</li>
</ul>
<h4 id="MERGE存储引擎"><a href="#MERGE存储引擎" class="headerlink" title="MERGE存储引擎"></a>MERGE存储引擎</h4><p>是一组MyISAM表的组合，这些表必须结构完全相同，MERGE表本身没有数据。查询、更新、删除实际是对内部的MyISAM表进行</p>
<p>对MERGE表进行<code>DROP</code>操作，只是删除MERGE定义，对内部的表没有影响</p>
<h4 id="BLACKHOLE存储引擎"><a href="#BLACKHOLE存储引擎" class="headerlink" title="BLACKHOLE存储引擎"></a>BLACKHOLE存储引擎</h4><p>不能存储数据，会记录Binlog（二进制日志）</p>
<ul>
<li>验证存储文件语法的正确性</li>
<li>来自二进制日志记录的开销测量，通过比较，允许与禁止二进制日志功能的BLACKHOLE的性能</li>
<li>用来查找与存储和引擎自身不相关的性能瓶颈</li>
</ul>
<h4 id="CSV存储引擎"><a href="#CSV存储引擎" class="headerlink" title="CSV存储引擎"></a>CSV存储引擎</h4><p>该引擎实际上操作的就是一个标准的CSV文件，不支持索引</p>
<h4 id="ARCHIVE存储引擎"><a href="#ARCHIVE存储引擎" class="headerlink" title="ARCHIVE存储引擎"></a>ARCHIVE存储引擎</h4><p>主要用于通过较小的存储空间来存储过期的很少访问的历史数据</p>
<p>不支持索引</p>
<p>不支持删除，修改操作，仅支持插入和查询操作    行级锁定</p>
<h4 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h4><p>MyISAM：适用于不需要事务支持、并发相对较低、数据修改相对较少、以读为主、数据一致性要求不是非常高</p>
<p>InnoDB：适用于需要事务支持，行级锁定对高并发有很好的适应能力，但需要确保查询时通过索引完成的，数据更新较为频繁</p>
<p>MEMORY：适用于需要很快的读写速度、对数据的安全性要求较低的场景</p>
<h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span>       <span class="comment">--查看所有可以使用的字符集</span></span><br><span class="line">information_schema. CHARACTER_SETS   <span class="comment">--显示所有的字符集和对应的校对规则</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">COLLATION</span> <span class="keyword">LIKE</span> <span class="string">&#x27;***&#x27;</span>    <span class="comment">--查看相关字符集的校对规则</span></span><br></pre></td></tr></table></figure>

<p>MySQL字符集包括<strong>字符集</strong>和<strong>校对规则</strong></p>
<p>字符集和校对规则是一对多的关系，两个不同的字符集不能有相同的校对规则</p>
<p>每个字符集有一个默认校对规则，每个字符集至少对应一个校对规则</p>
<h4 id="选择-1"><a href="#选择-1" class="headerlink" title="选择"></a>选择</h4><ul>
<li>应用处理的语言种类多，选择Unicode字符集，MySQL选择UTF-8</li>
<li>应用中涉及已有数据的导入，若已有数据为GBK文字，选择UTF-8</li>
<li>数据库只需支持一般中文，数据量大，性能要求高，选择GBK</li>
<li>数据库需要做大量的字符运算，选择定长字符集</li>
<li>考虑客户端所使用的字符集编码格式</li>
</ul>
<h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><p>服务器字符集和校对规则</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;character_set_server&#x27;</span>    <span class="comment">--查询当前服务器字符集</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;collation_server&#x27;</span> 		  <span class="comment">--查看校对规则</span></span><br><span class="line"></span><br><span class="line">mysqld <span class="operator">-</span><span class="type">character</span><span class="operator">-</span><span class="keyword">set</span><span class="operator">-</span>server<span class="operator">=</span>gbk              <span class="comment">--启动时指定字符集为gbk</span></span><br></pre></td></tr></table></figure>

<p>数据库字符集和校对规则</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE									  <span class="comment">--修改字符集</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;character_set_database&#x27;</span>      <span class="comment">--查询当前数据库字符集</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;collation_database&#x27;</span> 		  <span class="comment">--查看校对规则</span></span><br></pre></td></tr></table></figure>

<p>表字符集和校对规则</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span>					<span class="comment">--修改字符集</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名       <span class="comment">--查看当前表的字符集和校对规则</span></span><br></pre></td></tr></table></figure>

<p>列字符集和校对规则</p>
<p>针对相同的表不同字段需要使用不同字符集的情况</p>
<h3 id="MySQL数据库操作管理"><a href="#MySQL数据库操作管理" class="headerlink" title="MySQL数据库操作管理"></a>MySQL数据库操作管理</h3><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] db_name       <span class="comment">--创建数据库</span></span><br><span class="line"><span class="keyword">SHOW</span> DATABASES								  <span class="comment">--查看所有的数据库</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE 数据库名称 \G			   <span class="comment">--查看数据库详细信息</span></span><br></pre></td></tr></table></figure>



<h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h5><p>数据库名称可以进行修改，当存储引擎为MyISAM时，修改DATA目录下的库名文件夹，若存储引擎为InnoDB，无法修改库名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE [db_name]					</span><br><span class="line">[<span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> charset_name] 		<span class="comment">--修改数据库字符集</span></span><br><span class="line"><span class="operator">|</span> [[<span class="keyword">DEFAULT</span>] <span class="keyword">COLLATE</span> collation_name]		<span class="comment">--修改数据库校对规则</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE db_name				<span class="comment">--查看数据库详细信息</span></span><br></pre></td></tr></table></figure>



<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE [IF <span class="keyword">EXISTS</span>] db_name   		<span class="comment">--删除数据库</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>大学课程</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据操作管理</title>
    <url>/2021/10/04/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>对MySQL的数据进行操作</p>
</blockquote>
<span id="more"></span>

<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--为表的所有字段插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span>(值<span class="number">1</span>，值<span class="number">2</span>，……，值n)              <span class="comment">--不指定具体的字段名</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名(字段名<span class="number">1</span>，字段名<span class="number">2</span>，……，字段名n) <span class="keyword">VALUES</span>(值<span class="number">1</span>，值<span class="number">2</span>，……，值n)        <span class="comment">--列出所有字段，每个值必须与相应字段对应</span></span><br><span class="line"><span class="comment">--为表的指定字段插入字段</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名(字段名<span class="number">1</span>，字段名<span class="number">2</span>，……，字段名m) <span class="keyword">VALUES</span>(值<span class="number">1</span>，值<span class="number">2</span>，……，值n)</span><br><span class="line"><span class="comment">--同时插入多条记录</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名[(字段名列表)] <span class="keyword">VALUES</span>(取值列表<span class="number">1</span>)，(取值列表<span class="number">2</span>)，……，(取值列表n)   </span><br><span class="line"><span class="comment">--从目标表中插入值</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名[列名列表] <span class="keyword">SELECT</span> 列名列表 <span class="keyword">FROM</span> 表名 </span><br><span class="line"><span class="comment">--REPLACE语句</span></span><br><span class="line">REPLACE [<span class="keyword">INTO</span>] 表名 <span class="keyword">VALUES</span>(值列表)     <span class="comment">--若新纪录的主键值或唯一性约束字段值已有记录相同，则已有记录被删除后再添加新纪录</span></span><br></pre></td></tr></table></figure>



<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE 表名 <span class="keyword">SET</span> 字段名<span class="number">1</span><span class="operator">=</span>取值<span class="number">1</span>，字段名<span class="number">2</span><span class="operator">=</span>取值<span class="number">2</span>，……，字段名n<span class="operator">=</span>取值n  <span class="keyword">where</span> 条件表达式</span><br></pre></td></tr></table></figure>



<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--使用DELETE删除表数据</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名 [<span class="keyword">WHERE</span> 条件表达式]      <span class="comment">--DELETE 语句不加上“WHERE 条件表达式” ，数据库系统会删除指定表中的所有数据</span></span><br><span class="line"><span class="comment">--使用TRUNCATE清空表数据</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> [<span class="keyword">TABLE</span>] 表名                  <span class="comment">--TRUNCATE TABLE不带WHERE子句与DELETE语句相同</span></span><br><span class="line"><span class="comment">--TRUNCATE TABLE清空表记录后会重新设置自增型字段的计数起始值为1，DELETE会依次递增</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>TRUNCATE TABLE</code>：删除内容、释放空间但不删除定义</li>
<li><code>DELETE TABLE</code>：删除内容不删除定义，不释放空间</li>
<li><code>DROP TABLE</code>：删除内容和定义，释放空间</li>
</ul>
<h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><h4 id="SELECT语法"><a href="#SELECT语法" class="headerlink" title="SELECT语法"></a>SELECT语法</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列  		<span class="comment">--指定要查询的列名称，列与列之间用逗号隔开。 ALL显示所有行包括重复行，DISTINCT显示所有行(无重复)</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span>	  <span class="comment">--指定表，表与表之间用逗号隔开			</span></span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>]    <span class="comment">--指定查询条件，无WHERE子句，查询所有记录</span></span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span><span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span>]      <span class="comment">--对查询结构进行分组</span></span><br><span class="line">[<span class="keyword">HAVING</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>]   <span class="comment">--指定分组条件</span></span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span><span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span>[ <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]]         <span class="comment">--对查询结果排序。ASC升序，DESC降序，默认为ASC</span></span><br><span class="line">[LIMIT 子句]           <span class="comment">--限制查询输出结果的行数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--查询所有记录</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span><span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="comment">--避免重复数据查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 字段列 <span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="comment">--为表和字段取别名</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段名 [<span class="keyword">AS</span>] 别名，字段名 [<span class="keyword">AS</span>] 别名…… <span class="keyword">FROM</span> 表名</span><br></pre></td></tr></table></figure>

<h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件;	</span><br><span class="line"><span class="comment">--带IN关键字的查询</span></span><br><span class="line">[<span class="keyword">NOT</span>] <span class="keyword">IN</span> (元素<span class="number">1</span>，元素<span class="number">2</span>，……)			<span class="comment">--判断字段的值是否在集合内</span></span><br><span class="line"><span class="comment">--带BETWEEN AND关键字的查询</span></span><br><span class="line">[<span class="keyword">NOT</span>] <span class="keyword">BETWEEN</span> 取值<span class="number">1</span> <span class="keyword">AND</span> 取值<span class="number">2</span>         <span class="comment">--判断字段的值是否在指定范围内         范围包含两端    NOT范围小于取值1，大于取值2</span></span><br><span class="line"><span class="comment">--带IS NULL关键字的查询</span></span><br><span class="line"><span class="keyword">IS</span> [<span class="keyword">NOT</span>] <span class="keyword">NULL</span> 						<span class="comment">--判断字段的值是否为空值</span></span><br><span class="line"><span class="comment">--带LIKE关键字的查询</span></span><br><span class="line">[<span class="keyword">NOT</span>] <span class="keyword">LIKE</span> <span class="string">&#x27;字符串&#x27;</span>                  <span class="comment">--匹配字符串是否相等      &#x27;字符串&#x27;可以是一个完整的字符串，也可以是通配符</span></span><br><span class="line">									<span class="comment">--% 代表任意长度的字符串，长度可以为0</span></span><br><span class="line">									<span class="comment">--_ 只能表示单个字符</span></span><br><span class="line">									<span class="comment">--正则匹配  REGEXP关键字    属性名 REGEXP &#x27;匹配方式&#x27;</span></span><br><span class="line">	<span class="comment">--LIKE与REGEXP的区别：</span></span><br><span class="line">			<span class="keyword">LIKE</span>匹配整个列，如果被匹配的文本仅在列值中出现，<span class="keyword">LIKE</span>并不会找到它，相应的行也不会返回</span><br><span class="line">			REGEXP 在列值内进行匹配，如果被匹配的匹配的文本在列值中出现，REGEXP将会找到它，相应的行将被返回</span><br><span class="line">			<span class="keyword">Like</span>必须这个字段的所有内容满足条件，而REGEXP只需要有任何一个片段满足即可</span><br></pre></td></tr></table></figure>

<h4 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h4><h5 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 字段名				<span class="comment">--将查询结果按字段分组，字段值相等的为一组，单独使用只显示一个分组的一个记录  </span></span><br><span class="line">[<span class="keyword">HAVING</span> 条件表达式]			   <span class="comment">--限制分组后的显示，满足条件表达式的结果显示			 </span></span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>] 				  <span class="comment">--在所有记录最后加上一条记录，为上面所有记录的总和</span></span><br></pre></td></tr></table></figure>

<p><code>HAVING</code>，<code>WHERE</code>都是用来限制显示的</p>
<ul>
<li><code>WHERE</code>：作用于表或者视图，是表和视图的查询条件</li>
<li><code>HAVING</code>：作用于分组后的记录，用于选择满足条件的组</li>
</ul>
<h5 id="对查询结果排序"><a href="#对查询结果排序" class="headerlink" title="对查询结果排序"></a>对查询结果排序</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段名[<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure>



<h5 id="限制查询结果数量"><a href="#限制查询结果数量" class="headerlink" title="限制查询结果数量"></a>限制查询结果数量</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">LIMIT &#123;[<span class="keyword">OFFSET</span>,] row_count<span class="operator">|</span>row_count <span class="keyword">OFFSET</span> <span class="keyword">OFFSET</span>&#125;   <span class="comment">--OFFSET默认为0</span></span><br><span class="line">例：返回第<span class="number">3</span>条记录后<span class="number">3</span>条记录</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span><span class="keyword">FROM</span> 表名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段名 LIMIT <span class="number">2</span>,<span class="number">3</span></span><br></pre></td></tr></table></figure>



<h5 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h5><p>聚合函数与<code>GROUP BY</code> 联合使用</p>
<ul>
<li><code>COUNT</code>：统计记录的条数</li>
<li><code>SUM</code>：计算字段值的总和</li>
<li><code>AVG</code>：计算字段值的平均值</li>
<li><code>MAX</code>：查询字段的最大值</li>
<li><code>MIN</code>：查询字段的最小值</li>
</ul>
<p><code>SUM</code>、<code>AVG</code>、<code>MAX</code>、<code>MIN</code>规则</p>
<blockquote>
<p>列只有<code>NULL</code>，函数值为<code>NULL</code></p>
<p>列某些值为NULL，则函数值为非<code>NULL</code>值得平均值除以非<code>NULL</code>值的数量</p>
</blockquote>
<p><code>COUNT</code></p>
<blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">COUNT</span> (&#123;[<span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span>] <span class="operator">&lt;</span>表达式<span class="operator">&gt;</span>&#125; <span class="operator">|</span> <span class="operator">*</span>)     <span class="comment">--统计列中非NULL的数量</span></span><br><span class="line">例：统计表中不同字段值的记录数</span><br><span class="line"><span class="keyword">SELECT</span> 字段名,<span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> <span class="string">&#x27;别名&#x27;</span>  <span class="keyword">FROM</span>  表名  <span class="keyword">GROUP</span> <span class="keyword">BY</span>  字段名</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>SUM</code></p>
<blockquote>
<p><code>SUM</code>函数只能计算数值类型的字段</p>
<p>使用<code>SUM</code>函数计算字符类型字段时，计算结果都为0</p>
</blockquote>
<h5 id="合并查询结果"><a href="#合并查询结果" class="headerlink" title="合并查询结果"></a>合并查询结果</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ……</span><br><span class="line"><span class="keyword">UNION</span> [ <span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span>]</span><br><span class="line"><span class="keyword">SELECT</span> ……</span><br><span class="line">[<span class="keyword">UNION</span> [ <span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span>]</span><br><span class="line"><span class="keyword">SELECT</span> ……</span><br></pre></td></tr></table></figure>

<p>不使用ALL关键字，则返回所有行都是唯一的</p>
<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><ul>
<li><code>INNER JOIN</code>操作：用于组合两个表中的记录。只要公共字段有相符的值，内部链接组合两个表的记录</li>
<li><code>LEFT JOIN</code>操作：用于在任何<code>FROM</code>子句中组合来源表的记录。左边外部连接包含从第一个开始的两个表中的全部记录，即使第二个表中并没有相符的值</li>
<li><code>RIGHT JOIN</code>操作：用于在任何<code>FROM</code>子句中组合来源表的记录。右边外部连接包含从第二个开始的两个表中的全部记录，即使第一个表中并没有相符的值</li>
</ul>
<p>多表查询使用连接查询，操作效率较低</p>
<h4 id="内连接查询"><a href="#内连接查询" class="headerlink" title="内连接查询"></a>内连接查询</h4><p>两表关系的笛卡尔积数据记录中，保留匹配数据，删除不匹配数据</p>
<ol>
<li><p>等值连接(INNER JOIN)：连接条件的连接运算符为=时，为等值连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span><span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> 表<span class="number">2</span>  <span class="keyword">ON</span> 表<span class="number">1.</span>字段<span class="operator">=</span>表<span class="number">2.</span>字段   LIMIT 显示行数</span><br></pre></td></tr></table></figure></li>
<li><p>自然连接(NATURAL JOIN)：在等值连接中把重复列删去</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span><span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> 表<span class="number">2</span>  LIMIT 显示行数</span><br></pre></td></tr></table></figure></li>
<li><p>不等值连接(INNER JOIN)：连接条件的连接运算符不为=时，为不等值连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span><span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> 表<span class="number">2</span>  <span class="keyword">ON</span> 表<span class="number">1.</span>字段<span class="operator">!=</span>表<span class="number">2.</span>字段   LIMIT 显示行数</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h4><p>外连接查询可以查询<strong>两个或两个以上</strong>的表</p>
<ol>
<li>左外连接(LEFT JOIN)：左表记录中按照条件与右表进行连接，右表无响应数据返回<code>NULL</code></li>
<li>右外连接(RIGHT JOIN)：右表记录中按照条件与左表进行连接，左表无响应数据返回<code>NULL</code></li>
</ol>
<p><img src="/2021/10/04/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%AE%A1%E7%90%86/image-20201223190010045.png" alt="image-20201223190010045"></p>
<blockquote>
<p>左外连接：其运算方式为：A左连接B的记录=图公共部分记录集C＋表A记录集A1。</p>
<p>右外连接：其运算方式为：A右连接B的记录=图公共部分记录集C＋表B记录集B1 。</p>
</blockquote>
<h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--带IN关键字的子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">WHERE</span> 字段<span class="number">1</span> [<span class="keyword">NOT</span>] <span class="keyword">IN</span> (<span class="keyword">SELECT</span> 字段<span class="number">1</span> <span class="keyword">FROM</span> 表<span class="number">2</span>)</span><br><span class="line"><span class="comment">--带EXISTS关键字的子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="operator">*</span><span class="keyword">FROM</span> 表<span class="number">2</span> <span class="keyword">WHERE</span> 字段<span class="operator">=</span><span class="string">&#x27;给定值&#x27;</span>)</span><br><span class="line">		<span class="comment">--EXISTS内循环返回一个真假值，真执行外查询，假不执行</span></span><br><span class="line"><span class="comment">--带ANY关键字的子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">WHERE</span> 字段<span class="number">1</span> 运算符 <span class="keyword">ANY</span>(条件)    <span class="comment">--满足任何一个条件</span></span><br><span class="line"><span class="comment">--带ALL关键字的子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">WHERE</span> 字段<span class="number">1</span> 运算符 <span class="keyword">ALL</span>(条件)     <span class="comment">--满足所有条件</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>ALL</code>、<code>ANY</code>：</p>
<p>大于<code>ALL</code>表示大于条件内最大值</p>
<p>小于<code>ALL</code>表示小于条件内最小值</p>
<p>大于<code>ANY</code>表示大于条件内最小值</p>
<p>小于<code>ALL</code>表示小于条件内最大值</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>大学课程</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL权限管理</title>
    <url>/2021/10/04/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h3 id="权限系统"><a href="#权限系统" class="headerlink" title="权限系统"></a>权限系统</h3><p>MySQL可以使用3种不同类型的安全检查</p>
<ol>
<li>登陆验证：用户名、密码验证</li>
<li>授权：对用户设置其具体权限</li>
<li>访问控制：是否允许操作</li>
</ol>
<span id="more"></span>

<p>存储控制阶段：</p>
<ol>
<li>服务器检查是否允许连接</li>
<li>若允许连接，服务器检查用户发出请求是否有相应的权限</li>
</ol>
<p>服务器在存取控制阶段使用user、db、host表</p>
<p>在执行数据库操作时，需要通过root用户账号登录，对整个MySQL服务器具有完全控制</p>
<h3 id="权限表"><a href="#权限表" class="headerlink" title="权限表"></a>权限表</h3><h4 id="user表"><a href="#user表" class="headerlink" title="user表"></a>user表</h4><p>user为MySQL中最终的一个权限表，可以使用<code>DESC</code>查看user的基本结构</p>
<p>user列分为：用户列、权限列、安全列、资源控制列</p>
<p>权限分为普通权限和管理权限：</p>
<blockquote>
<p>普通权限：主要用于对数据库的操作</p>
<p>管理权限：主要用于对数据库进行管理的操作</p>
</blockquote>
<p>用户连接时，权限表的存取过程：先从user表中的host、user、password判断来连接的ip、用户名称、密码是否存在，若存在，通过身份验证，否则拒绝连接</p>
<p>通过验证后，按照以下权限顺序得到数据库权限：user、db、table_priv、colums_priv，权限依次递减，全局覆盖局部</p>
<h5 id="用户字段"><a href="#用户字段" class="headerlink" title="用户字段"></a>用户字段</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查询user表的相关用户字段</span></span><br><span class="line"><span class="keyword">SELECT</span> Host ,<span class="keyword">User</span> , <span class="string">&#x27;Password&#x27;</span> <span class="keyword">FROM</span> mysql.<span class="string">&#x27;user&#x27;</span></span><br></pre></td></tr></table></figure>

<h5 id="权限字段"><a href="#权限字段" class="headerlink" title="权限字段"></a>权限字段</h5><p>权限字段以<code>priv</code>结尾，这些字段决定用户权限</p>
<p>权限字段的值只有<code>Y</code>或<code>N</code>，表示有权限和无权限，默认值为<code>N</code>，可以使用<code>GRANT</code>为用户赋予权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查看localhost主机下的用户的select、insert、update权限</span></span><br><span class="line"><span class="keyword">SELECT</span> SELECT_priv,insert_priv,update_priv,<span class="keyword">user</span>,host</span><br><span class="line"><span class="keyword">FROM</span> mysql.user <span class="keyword">WHERE</span> host <span class="operator">=</span> <span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="安全字段"><a href="#安全字段" class="headerlink" title="安全字段"></a>安全字段</h5><p>安全字段：ssl_type        ssl_cipher </p>
<p>​                   x509_issuer    x509_subject      </p>
<p>​                    另外两个与授权插件有关</p>
<p><code>ssl</code>可用于加密；<code>x509</code>标准可用于标识用户；<code>plugin</code>字段标识可用于验证用户身份的插件，若该字段为空，服务器使用内建授权机制验证</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查看hava_openssl是否具有ssl功能</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;hava_openssl&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="资源控制列"><a href="#资源控制列" class="headerlink" title="资源控制列"></a>资源控制列</h5><p>资源控制列用来限制用户使用的资源，有以下字段：</p>
<ul>
<li><code>max_question</code>：用户每小时允许执行的查询操作次数</li>
<li><code>max_updates</code>：用户每小时允许执行的更新操作次数</li>
<li><code>max_connections</code>：用户每小时允许执行的连接操作次数</li>
<li><code>max_user_connections</code>：单个用户可以同时具有的连接次数</li>
</ul>
<p>默认值都为0，表示无限制</p>
<h4 id="db表和host表"><a href="#db表和host表" class="headerlink" title="db表和host表"></a>db表和host表</h4><p>db表存储用户对某个数据库的操作权限，决定用户能从哪个主机存取哪个数据库</p>
<p>host表存储某个主机对数据库的操作权限</p>
<p>这两权限表不受<code>GRANT</code>和<code>REVOKE</code>语句影响，可以使用<code>DESC</code>语句查看两表的基本结构</p>
<h5 id="用户列"><a href="#用户列" class="headerlink" title="用户列"></a>用户列</h5><p>db表的用户列：</p>
<ul>
<li>host：主机名</li>
<li>db：数据库名</li>
<li>uesr：用户名</li>
</ul>
<p>host表的用户列：</p>
<ul>
<li>host：主机名</li>
<li>db：数据库名</li>
</ul>
<p>host为db的扩展，db表找不到host的值，需要到host表中寻找</p>
<h5 id="权限列"><a href="#权限列" class="headerlink" title="权限列"></a>权限列</h5><p>db表与host表的权限列大致相同，<code>create_routine_priv</code>和<code>alter_routine_priv</code>表示用户是否有创建和修改存储过程的权限</p>
<p>当希望用户只对某个数据库有操作权限，则将user表的对应权限设为<code>N</code>，在db表设置对应数据库的操作权限</p>
<h5 id="tables-priv表"><a href="#tables-priv表" class="headerlink" title="tables_priv表"></a>tables_priv表</h5><p>tables_priv表可以对单个表进行权限设置，用来指定表级权限，可以使用<code>DESC</code>语句查看两表的基本结构</p>
<p>tables_priv表字段：</p>
<ul>
<li>host：主机名</li>
<li>db：数据库名</li>
<li>uesr：用户名</li>
<li>table_name：表名</li>
<li>grantor：修改该记录的用户</li>
<li>timestamp：修改该记录的时间</li>
<li>table_priv：对表进行操作的权限，包括：select、insert、update、delete、create、drop、grant、reference、index、alter</li>
<li>column_priv：对表中的列进行操作的权限，包括：select、insert、update、reference</li>
</ul>
<h4 id="columns-priv表"><a href="#columns-priv表" class="headerlink" title="columns_priv表"></a>columns_priv表</h4><p>columns_priv表可以对表中的某一列进行权限设置</p>
<p>columns_priv表字段：</p>
<ul>
<li>host：主机名</li>
<li>db：数据库名</li>
<li>uesr：用户名</li>
<li>table_name：表名</li>
<li>column_name：指定对哪些数据列具有操作权限</li>
<li>timestamp：修改该记录的时间</li>
<li>column_priv：对表中的列进行操作的权限，包括：<code>select</code>、<code>insert</code>、<code>update</code>、<code>reference</code></li>
</ul>
<h4 id="procs-priv表"><a href="#procs-priv表" class="headerlink" title="procs_priv表"></a>procs_priv表</h4><p>procs_priv表可以对存储过程和存储函数进行权限设置，可以使用<code>DESC</code>语句查看两表的基本结构</p>
<p>procs_priv表字段：</p>
<ul>
<li>host：主机名</li>
<li>db：数据库名</li>
<li>uesr：用户名</li>
<li>routine_name：存储过程或存储函数的名称</li>
<li>routine_type：存储过程或存储函数的类型，该字段有两个值：<code>function</code>表示存储函数，<code>procedure</code>表示存储过程</li>
<li>grantor：存储插入或修改该记录的用户</li>
<li>proc_priv：拥有的权限，包括：execute、alter routine、grant</li>
<li>timestamp：存储记录更新的时间</li>
</ul>
<h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查看所有用户账号列表</span></span><br><span class="line">USE mysql；</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span> <span class="keyword">FROM</span> <span class="keyword">user</span>；</span><br></pre></td></tr></table></figure>

<h4 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h4><p>新的MySQL数据库系统，只有一个root用户</p>
<h5 id="使用CREATE-USER语句创建用户账号"><a href="#使用CREATE-USER语句创建用户账号" class="headerlink" title="使用CREATE USER语句创建用户账号"></a>使用<code>CREATE USER</code>语句创建用户账号</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span><span class="operator">&lt;</span>User_name<span class="operator">&gt;</span> [IDENTIFIED <span class="keyword">BY</span> <span class="operator">&lt;</span>password<span class="operator">&gt;</span>]</span><br><span class="line">[LOGIN POLICY <span class="operator">&lt;</span>policy_name<span class="operator">&gt;</span>]</span><br><span class="line">[FORCE PASSWORD CHANGE&#123; <span class="keyword">ON</span> <span class="operator">|</span> OFF &#125;]</span><br><span class="line"><span class="comment">--在MySQL服务器中添加新用户，用户名为zhangsan，主机名为localhost，口令设置为明文123</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;zhangsan&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIND <span class="keyword">BY</span> <span class="string">&#x27;123&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>User_name</code>：指定创建用户账号，格式为：‘user_name‘@’host name’，user_name为用户名，host name为主机名</li>
<li><code>IDENTIFIED BY</code>：用于指定用户账号对应的口令，无口令可省略</li>
<li><code>policy_name</code>：指派给用户的登录策略的名称，无策略可省略</li>
<li><code>password</code>：为用户指定口令，无口令的用户不能连接数据库</li>
</ul>
<p>用户ID和口令不能出现以下情况：</p>
<ul>
<li>以空格、单引号、双引号开头</li>
<li>以空格结尾</li>
<li>含有分号</li>
</ul>
<p><code>CREATE USER</code>语句使用说明：</p>
<ul>
<li>使用该语句，需要有MySQL数据库的<code>INSERT</code>权限或全局<code>CREATE USER</code>权限</li>
<li>使用该语句创建用户账号后，会在系统自身的user表添加一条新纪录</li>
<li>若两个用户具有相同的用户名和不同的主机名，MySQL会视为不同的用户，允许为两个用户分配不同权限</li>
<li>使用该语句未指定口令，MySQL允许该用户可以不使用口令登录（不推荐）</li>
<li>新创建的用户只允许进行不需要权限的操作，如查询所有存储引擎、字符串的列集等</li>
</ul>
<h5 id="使用INSERT语句新建普通用户"><a href="#使用INSERT语句新建普通用户" class="headerlink" title="使用INSERT语句新建普通用户"></a>使用<code>INSERT</code>语句新建普通用户</h5><p>使用<code>INSERT</code>语句需要有对user表的插入权限</p>
<p>使用<code>INSERT</code>语句至少要插入六个字段的值：host、user、password、ssl_cipher、x09_issuer、x509_subject</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--插入xiaohong用户，主机名为localhost，密码时password(123)</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mysql.user(host,<span class="keyword">user</span>,password,ssl_cipher,x09_issuer,x509_subject)</span><br><span class="line">	<span class="keyword">VALUES</span>(<span class="string">&#x27;localhost&#x27;</span>,<span class="string">&#x27;xiaohong&#x27;</span>,password(<span class="number">123</span>),<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">	</span><br><span class="line"><span class="comment">--执行上述语句后，要使用’FLUSH PRIVILEGES&#x27;使命令生效，需要reload权限</span></span><br><span class="line">FLUSH PRIVILEGES</span><br></pre></td></tr></table></figure>

<h5 id="使用GRANT语句新建普通用户"><a href="#使用GRANT语句新建普通用户" class="headerlink" title="使用GRANT语句新建普通用户"></a>使用<code>GRANT</code>语句新建普通用户</h5><h4 id="查看用户"><a href="#查看用户" class="headerlink" title="查看用户"></a>查看用户</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span><span class="keyword">FROM</span> mysql.user <span class="keyword">WHERE</span> host<span class="operator">=</span><span class="string">&#x27;host_name&#x27;</span> <span class="keyword">AND</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;user_name&#x27;</span>			<span class="comment">--*表示所有列，也可以指定特定列</span></span><br></pre></td></tr></table></figure>



<h4 id="修改用户账号"><a href="#修改用户账号" class="headerlink" title="修改用户账号"></a>修改用户账号</h4><p>修改用户账号需要有MySQL数据库的<code>update</code>权限或全局<code>create user</code>权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">RENAME <span class="keyword">USER</span> old_user <span class="keyword">TO</span> new_user [,old_user <span class="keyword">TO</span> new_user] ……     <span class="comment">--old_user：系统中已存在的用户账号</span></span><br><span class="line">																<span class="comment">--new_user：新的MySQL用户账号</span></span><br></pre></td></tr></table></figure>



<h4 id="修改用户口令"><a href="#修改用户口令" class="headerlink" title="修改用户口令"></a>修改用户口令</h4><p>使用<code>mysqladmin</code>命令修改密码</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqladmin <span class="operator">-</span>u username p password，根据提示先输入旧密码，在输入新密码</span><br></pre></td></tr></table></figure>

<p>使用<code>set</code>语句修改</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> PASSWORD [<span class="keyword">FOR</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;hostname&#x27;</span>]<span class="operator">=</span>password(<span class="string">&#x27;new_password&#x27;</span>)   <span class="comment">--不加FOR……，则修改当前用户密码</span></span><br><span class="line"><span class="comment">--修改xiaohong密码为 &#x27;123&#x27;</span></span><br><span class="line"><span class="keyword">SET</span> PASSWORD [<span class="keyword">FOR</span> <span class="string">&#x27;xiaohong&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>]<span class="operator">=</span>password(<span class="string">&#x27;123&#x27;</span>) </span><br></pre></td></tr></table></figure>

<p>修改user表，使用root登录，修改自己或普通用户密码</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE mysql.user <span class="keyword">SET</span> password<span class="operator">=</span>password(<span class="string">&#x27;new_password&#x27;</span>) <span class="keyword">WHERE</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;user_name&#x27;</span> <span class="keyword">AND</span> host<span class="operator">=</span><span class="string">&#x27;host_name&#x27;</span></span><br><span class="line"><span class="comment">--修改xiaohong的密码为 &#x27;123456&#x27;</span></span><br><span class="line">UPDATE mysql.user <span class="keyword">SET</span> password<span class="operator">=</span>password(<span class="string">&#x27;123456&#x27;</span>) <span class="keyword">WHERE</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;xiaohong&#x27;</span> <span class="keyword">AND</span> host<span class="operator">=</span><span class="string">&#x27;localhost&#x27;</span></span><br></pre></td></tr></table></figure>

<p>每次修改后，需要使用<code>FLUSH PRIVILEGES</code>命令重新加载权限</p>
<h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><p>使用<code>DROP USER</code>语句删除普通用户</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="keyword">user</span>[,<span class="keyword">user</span>]……</span><br><span class="line"><span class="comment">--删除名为xiaohong用户，host值为localhost</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> xiaohong<span class="variable">@localhost</span></span><br></pre></td></tr></table></figure>

<p>使用<code>DELETE</code>语句删除普通用户</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> mysql.user <span class="keyword">WHERE</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;user_name&#x27;</span> <span class="keyword">AND</span> host<span class="operator">=</span><span class="string">&#x27;host_name&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="账户权限管理"><a href="#账户权限管理" class="headerlink" title="账户权限管理"></a>账户权限管理</h3><h4 id="权限授予"><a href="#权限授予" class="headerlink" title="权限授予"></a>权限授予</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> priv_type[(column_list)][,priv_type[(column_list)]]……</span><br><span class="line"><span class="keyword">ON</span>[object_type] priv_level</span><br><span class="line"><span class="keyword">TO</span> user_sepcification[,user_sepcification]……</span><br><span class="line">[<span class="keyword">WITH</span> with_option]</span><br><span class="line"><span class="comment">--授予用户lili在数据库studentinfo的表student上拥有对列sno和列sname的select权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">select</span>(sno,sname) <span class="keyword">ON</span> student <span class="keyword">TO</span> <span class="string">&#x27;lili&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span></span><br><span class="line"><span class="comment">--不存在用户liming和用户huang，要求创建两个用户同时授予在数据库studentinfo的表student上拥有select和update权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">select</span>，update <span class="keyword">ON</span> studentinfo.student <span class="keyword">TO</span> </span><br><span class="line"><span class="string">&#x27;liming&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="string">&#x27;haung&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;789&#x27;</span>;</span><br><span class="line"><span class="comment">--授予用户lili可以在数据库studentinfo中执行所有操作的权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> studentinfo.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;lili&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>GRANT 权限级别：</p>
<ul>
<li>*：当前数据库中的所有表</li>
<li>*.*：所有数据库的所有表</li>
<li>db_name.*：某个数据库中的所有表</li>
<li>db_name.tbl_name：某个数据库的某个表或视图</li>
<li>tbl_name：某个表或视图</li>
<li>db_name.routine_name：某个数据库中的某个存储过程或函数</li>
</ul>
<p>GRANT中priv_type值：</p>
<ul>
<li><code>select</code>：授予用户可以使用<code>SELECT</code>语句访问特定表的权限</li>
<li><code>insert</code>：授予用户可以使用<code>INSERT</code>语句从一个特定表中添加数据行的权限</li>
<li><code>delete</code>：授予用户可以使用<code>DELETE</code>语句从一个特定表中删除数据行的权限</li>
<li><code>update</code>：授予用户可以使用<code>UPDATE</code>语句修改特定表中值的权限</li>
<li><code>reference</code>：授予用户可以创建一个外键来参照特定数据表的权限</li>
<li><code>create</code>：授予用户可以使用特定的名字创建一个数据表的权限</li>
<li><code>alter</code>：授予用户可以使用<code>ALTER TABLE</code>语句修改数据表的权限</li>
<li><code>index</code>：授予用户可以在表上定义索引的权限</li>
<li><code>drop</code>：授予用户可以删除数据表的权限</li>
<li><code>all</code>或<code>all privileges</code>：所有的权限</li>
</ul>
<p>授予列权限时，只能使用<code>select</code>、<code>insert</code>、<code>update</code>，权限还要加上列名列表<code>colimn_list</code></p>
<h4 id="权限的转移和限制"><a href="#权限的转移和限制" class="headerlink" title="权限的转移和限制"></a>权限的转移和限制</h4><p>通过<code>GRANT</code>语句中使用<code>WITH</code>子句实现</p>
<p>转移权限</p>
<p>将<code>WITH</code>子句指定为<code>WITH GRANT OPTION</code>,表示<code>TO</code>子句中所指定的所有用户都具有把自己权限授予其他用户的权利</p>
<p>限制权限</p>
<p>若<code>WITH</code>子句中<code>WITH</code>关键字后为以下四项，即拥有限制权限</p>
<ul>
<li><code>max_queries_per_hour count</code>：限制每小时可以查询数据库的次数</li>
<li><code>max_updates_per_hour count</code>：限制每小时可以修改数据库的次数</li>
<li><code>max_ccconnections_per_hour count</code>：限制每小时可以连接数据库的次数</li>
<li><code>max_user_connection count</code>：限制同时连接MySQL的最大用户数，<code>count</code>为用户数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--授予系统中的用户huang在数据库studentinfo的表student上每小时只能处理一条delete语句的权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">delete</span> <span class="keyword">ON</span> studentinfo.student <span class="keyword">TO</span> <span class="string">&#x27;huang&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="keyword">WITH</span> max_queries_per_hour <span class="number">1</span>;</span><br></pre></td></tr></table></figure>



<h4 id="权限的撤销"><a href="#权限的撤销" class="headerlink" title="权限的撤销"></a>权限的撤销</h4><p>使用<code>REVOKE</code>语句，要有MySQL数据库的全局<code>CREATE user</code>权限或<code>UPDATE</code>权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--回收某些特定的权限</span></span><br><span class="line"><span class="keyword">REVOKE</span> priv_type[(column_list)][,priv_type[(column_list)]]……</span><br><span class="line"><span class="keyword">ON</span>[object_type] priv_level</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">user</span>[,<span class="keyword">user</span>]……</span><br><span class="line"><span class="comment">--回收特定用户的所有权限</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> PRIVILECES,<span class="keyword">GRANT</span> OPTION</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">user</span>[,<span class="keyword">user</span>]……</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>大学课程</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引</title>
    <url>/2021/10/04/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>创建索引的目的是为了优化数据库的查询速度</p>
<p>所有MySQL列类型都可以被索引，对相关列使用索引是提高<code>SELECT</code>操作性能的<strong>最佳途径</strong></p>
<p>索引的两种存储类型：<strong>B型树索引</strong>，<strong>哈希索引</strong></p>
<span id="more"></span>

<p>索引的优点</p>
<ul>
<li>通过创建唯一性索引，可以保证数据库数据的唯一性</li>
<li>大大加快数据的检索速度</li>
<li>加速表之间的连接</li>
<li>使用分组和排序子句进行数据检索时，可以显著减少查询时间</li>
<li>通过使用索引，在查询过程可以使用优化隐藏器，提高系统性能</li>
</ul>
<p>索引的缺点</p>
<ul>
<li>创建索引和维护索引耗时，随数据量增加而增加</li>
<li>索引占据一定的物理空间</li>
<li>对表中的数据进行增删改时，索引也要动态维护，降低了数据的维护速度</li>
</ul>
<p>索引的特征：<strong>唯一性索引</strong>，<strong>复合索引</strong></p>
<blockquote>
<p>唯一性索引保证在索引列中的全部数据唯一，不包含冗余数据。</p>
<p>当表中有主键约束或唯一性键约束，当创建表或MySQL自动创建一个唯一性索引</p>
<p>当修改非空表中数据时，存在唯一性索引，表中存在冗余值，则修改操作失败</p>
</blockquote>
<blockquote>
<p>复合索引将一个索引创建在两个列或多列上</p>
<p>最多16个列合并为一个复合索引，列的总长度不超过900字节</p>
<p>复合索引的列必须来自同一个表</p>
<p>首先定义最唯一的列</p>
</blockquote>
<p>索引的分类</p>
<ul>
<li>普通索引：在创建普通索引时，不附加任何限制条件</li>
<li>唯一性索引：使用<code>UNIQUE</code>参数设置。通过唯一性索引，可以更快速地确定某条记录。<strong>主键就是一种特殊唯一性索引</strong></li>
<li>全文索引：使用<code>FULLTEXT</code>参数设置。只能创建在<code>CHAR</code>、<code>VARCHAR</code>、<code>TEXT</code>类型字段。查询数据量较大地字符串类型字段使用</li>
<li>单列索引：在表中地<strong>单个字段</strong>上创建一个索引。单列索引只根据该字段进行索引，可以是以上三种索引</li>
<li>多列索引：在表中地<strong>多个字段</strong>上创建一个索引。查询条件只有带有第一个字段，索引才会被使用</li>
<li>空间索引：使用<code>SPATIAL</code>参数设置。只能创建在<code>GEMETRY</code>、<code>POINT</code>、<code>LINESTRING</code>、<code>POLYGON</code>这些空间类型上，值不能为<code>NULL</code></li>
</ul>
<h3 id="索引的定义和管理"><a href="#索引的定义和管理" class="headerlink" title="索引的定义和管理"></a>索引的定义和管理</h3><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p>直接创建：</p>
<ul>
<li><p>创建表时创建索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name(</span><br><span class="line">	属性名，数据类型[完整性约束]，</span><br><span class="line">	属性名，数据类型[完整性约束]，</span><br><span class="line">	……</span><br><span class="line">	INDEX <span class="operator">|</span> KEY [索引名](属性名[(长度)] [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>])</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>在已存在的表上创建索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX 索引名 <span class="keyword">ON</span> 表名 (属性名 [ (长度) ] [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>])</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>ALTER TABLE</code>语句创建索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> INDEX <span class="operator">|</span> KEY [索引名](属性名[(长度)] [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>])</span><br></pre></td></tr></table></figure></li>
</ul>
<p>间接创建：</p>
<p>​    表中定义主键约束或唯一性键约束时，同时创建索引</p>
<p>​    若表中已有使用<code>CREATE INDEX</code>创建的标准索引时，由主键约束或唯一性键约束创建的索引会覆盖之前的标准索引</p>
<h5 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span><span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 字段<span class="operator">=</span><span class="string">&#x27;字段值&#x27;</span>        <span class="comment">--查看索引是否被使用，查看使用哪个索引</span></span><br><span class="line"><span class="comment">--使用ALTER TABLE在字段1的前五个记录上创建降序排序</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> INDEX 索引名 (字段<span class="number">1</span>(<span class="number">5</span>) <span class="keyword">DESC</span>)</span><br><span class="line"><span class="comment">--指定使用索引1用于字段查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span><span class="keyword">FROM</span> 表名 USE INDEX <span class="keyword">FOR</span> <span class="keyword">JOIN</span>(索引<span class="number">1</span>) <span class="keyword">WHERE</span> 字段<span class="operator">=</span><span class="string">&#x27;查询值&#x27;</span></span><br></pre></td></tr></table></figure>

<h5 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--使用CREATE INDEX 命令在表1的字段1上创建唯一性索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX 索引名 <span class="keyword">ON</span> 表<span class="number">1</span>(字段<span class="number">1</span>)</span><br><span class="line"><span class="comment">--使用ALTER TABLE 命令在表1的字段1上创建唯一性索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表<span class="number">1</span> <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> INDEX (字段<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h5 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--例：创建表1，并指定char(20)字段类型的字段1为全文索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表<span class="number">1</span>(</span><br><span class="line">	属性名，数据类型[完整性约束]，</span><br><span class="line">	……</span><br><span class="line">	字段<span class="number">1</span> <span class="type">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">	FULLTEXT INDEX 索引名(字段<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--例：创建表1，并指定char(20)字段类型的字段1和int类型的字段2上创建多列索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表<span class="number">1</span>(</span><br><span class="line">	属性名，数据类型[完整性约束]，</span><br><span class="line">	……</span><br><span class="line">	字段<span class="number">1</span> <span class="type">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">	字段<span class="number">2</span> <span class="type">INT</span> ，</span><br><span class="line">	INDEX 索引名(字段<span class="number">1</span>，字段<span class="number">2</span>);</span><br></pre></td></tr></table></figure>





<h4 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="operator">|</span> KEY <span class="keyword">FROM</span> table_name [<span class="keyword">FROM</span> db_name]</span><br></pre></td></tr></table></figure>

<p><code>SHOW INDEX</code> 返回信息：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Table</td>
<td>表示创建索引的数据表名。</td>
</tr>
<tr>
<td>Non_unique</td>
<td>表示该索引是否是唯一索引。若不是唯一索引，则该列的值为 1；若是唯一索引，则该列的值为 0。</td>
</tr>
<tr>
<td>Key_name</td>
<td>表示索引的名称。</td>
</tr>
<tr>
<td>Seq_in_index</td>
<td>表示该列在索引中的位置，如果索引是单列的，则该列的值为 1；如果索引是组合索引，则该列的值为每列在索引定义中的顺序。</td>
</tr>
<tr>
<td>Column_name</td>
<td>表示定义索引的列字段。</td>
</tr>
<tr>
<td>Collation</td>
<td>表示列以何种顺序存储在索引中。在 MySQL 中，升序显示值“A”（升序），若显示为 NULL，则表示无分类。</td>
</tr>
<tr>
<td>Cardinality</td>
<td>索引中唯一值数目的估计值。基数根据被存储为整数的统计数据计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，MySQL 使用该索引的机会就越大。</td>
</tr>
<tr>
<td>Sub_part</td>
<td>表示列中被编入索引的字符的数量。若列只是部分被编入索引，则该列的值为被编入索引的字符的数目；若整列被编入索引，则该列的值为 NULL。</td>
</tr>
<tr>
<td>Packed</td>
<td>指示关键字如何被压缩。若没有被压缩，值为 NULL。</td>
</tr>
<tr>
<td>Null</td>
<td>用于显示索引列中是否包含 NULL。若列含有 NULL，该列的值为 YES。若没有，则该列的值为 NO。</td>
</tr>
<tr>
<td>Index_type</td>
<td>显示索引使用过的类型和方法（BTREE、FULLTEXT、HASH、RTREE）。</td>
</tr>
<tr>
<td>Comment</td>
<td>显示评注。</td>
</tr>
</tbody></table>
<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> INDEX index_name</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY</span><br><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name</span><br></pre></td></tr></table></figure>

<p>第二条语句只删除<code>PRIMARY KEY</code>索引，一个表只可能有一个<code>PRIMARY KEY</code>索引，因此不需要指定索引名</p>
<p>多列索引，删除其中的某列，则该列也会从索引中删除，组成索引的所有列都被删除，则整个索引被删除</p>
<h3 id="设计原则和注意事项"><a href="#设计原则和注意事项" class="headerlink" title="设计原则和注意事项"></a>设计原则和注意事项</h3><h4 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h4><ul>
<li>选择唯一性索引</li>
<li>为经常需要排序、分组和联合操作的字段建立索引</li>
<li>为常作为查询条件的字段建立索引</li>
<li>限制索引的数目</li>
<li>尽量使用数据量少的索引</li>
<li>尽量使用前缀来索引</li>
<li>删除不在使用或很少使用的索引</li>
</ul>
<h4 id="合理使用索引的注意事项"><a href="#合理使用索引的注意事项" class="headerlink" title="合理使用索引的注意事项"></a>合理使用索引的注意事项</h4><p>一般<strong>在</strong>以下列上创建索引</p>
<ul>
<li>在经常需要搜索的列上，可以加快搜索速度</li>
<li>在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构</li>
<li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度</li>
<li>在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，指定范围时连续的</li>
<li>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间</li>
<li>经常使用在<code>WHERE</code>子句中的列上创建索引，加快条件的判断条件</li>
</ul>
<h4 id="不合理使用索引的注意事项"><a href="#不合理使用索引的注意事项" class="headerlink" title="不合理使用索引的注意事项"></a>不合理使用索引的注意事项</h4><p>一般<strong>不在</strong>以下列上创建索引</p>
<ul>
<li>对于在查询中很少使用或者参考的列不应该创建索引</li>
<li>对于只有很少数据值的列也不应该增加索引</li>
<li>对于定义为<code>text</code>、<code>image</code>和<code>bit</code>数据类型的列不应该增加索引</li>
<li>当修改性能远远大于检索性能时，不应该创建索引</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>大学课程</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL表定义与完整性约束控制</title>
    <url>/2021/10/04/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E8%A1%A8%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><p>数据库由各种数据表组成，数据表是用来存储和操作数据的逻辑结构</p>
<ul>
<li>每个表应该只包含关于一个主题的信息</li>
<li>表中不应包含重复信息</li>
</ul>
<span id="more"></span>

<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h5 id="数值数据类型："><a href="#数值数据类型：" class="headerlink" title="数值数据类型："></a>数值数据类型：</h5><ul>
<li><p>整数类型：<code>TINYINT</code>、<code>SMALLINT</code>、<code>MEDIUMINT</code>、<code>INT</code>、<code>BIGINT</code></p>
<table>
<thead>
<tr>
<th><strong>MySQL数据类型</strong></th>
<th><strong>含义（有符号）</strong></th>
</tr>
</thead>
<tbody><tr>
<td>TINYINT(m)</td>
<td>1个字节 范围(-128~127)                         小整数值</td>
</tr>
<tr>
<td>SMALLINT(m)</td>
<td>2个字节 范围(-32768~32767)                大整数值</td>
</tr>
<tr>
<td>MEDIUMINT(m)</td>
<td>3个字节 范围(-8388608~8388607)       大整数值</td>
</tr>
<tr>
<td>INT(m)</td>
<td>4个字节 范围(-2147483648~2147483647)               大整数值</td>
</tr>
<tr>
<td>BIGINT(m)</td>
<td>8个字节 范围(+-9.22*10的18次方)          极大整数值</td>
</tr>
</tbody></table>
</li>
<li><p>浮点数类型：<code>FLOAT</code>、<code>DOUBLE</code></p>
<table>
<thead>
<tr>
<th><strong>MySQL数据类型</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>FLOAT(m,d)</td>
<td>单精度浮点型 8位精度(4字节) m总个数，d小数位</td>
</tr>
<tr>
<td>DOUBLE(m,d)</td>
<td>双精度浮点型 16位精度(8字节) m总个数，d小数位</td>
</tr>
</tbody></table>
</li>
<li><p>定点小数类型：<code>DECIMAL</code></p>
<p>浮点型在数据库中存放的是近似值，而定点类型在数据库中存放的是精确值。</p>
<table>
<thead>
<tr>
<th><strong>MySQL数据类型</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>DECIMAL(m,d)</td>
<td>参数m&lt;65 是总个数，d&lt;30且 d&lt;m 是小数位。</td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="日期-时间类型："><a href="#日期-时间类型：" class="headerlink" title="日期/时间类型："></a>日期/时间类型：</h5><ul>
<li><p><code>YEAR</code>、<code>TIME</code>、<code>DATE</code>、<code>DATETIME</code>、<code>TIMESTAMP</code></p>
<table>
<thead>
<tr>
<th><strong>MySQL数据类型</strong></th>
<th align="left"><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>DATE</td>
<td align="left">日期 ‘2008-12-2’</td>
</tr>
<tr>
<td>TIME</td>
<td align="left">时间 ‘12:25:36’</td>
</tr>
<tr>
<td>DATETIME</td>
<td align="left">日期时间 ‘2008-12-2 22:06:44’</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td align="left">自动存储记录修改时间</td>
</tr>
<tr>
<td>YEAR</td>
<td align="left">年份值</td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="字符串类型："><a href="#字符串类型：" class="headerlink" title="字符串类型："></a>字符串类型：</h5><ul>
<li><p><code>CHAR</code>、<code>VARCHAR</code>、<code>BINARY</code>、<code>VARBINARY</code>、<code>BLOB</code>、<code>TEXT</code>、<code>ENUM</code>、<code>SET</code></p>
<table>
<thead>
<tr>
<th><strong>MySQL数据类型</strong></th>
<th>大小</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR</td>
<td>0-255字节</td>
<td>定长字符串</td>
</tr>
<tr>
<td>VARCHAR</td>
<td>0-255字节</td>
<td>变长字符串</td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>0-255字节</td>
<td>短文本字符串</td>
</tr>
<tr>
<td>TEXT</td>
<td>0-65 535字节</td>
<td>长文本数据</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>0-16 777 215字节</td>
<td>中等长度文本数据</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>0-4 294 967 295字节</td>
<td>极大文本数据</td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="二进制类型："><a href="#二进制类型：" class="headerlink" title="二进制类型："></a>二进制类型：</h5><ul>
<li><p><code>BIT</code>、<code>BINARY</code>、<code>VARBINARY</code>、<code>TINYBLOB</code>、<code>BLOB</code>、<code>MEDIUMBLOB</code>、<code>LONGBLOB</code></p>
<table>
<thead>
<tr>
<th><strong>MySQL数据类型</strong></th>
<th>大小</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>TINYBLOB</td>
<td>0-255字节</td>
<td>不超过 255 个字符的二进制字符串</td>
</tr>
<tr>
<td>BLOB</td>
<td>0-65 535字节</td>
<td>二进制形式的长文本数据</td>
</tr>
<tr>
<td>MEDIUMBLOB</td>
<td>0-16 777 215字节</td>
<td>二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td>LOGNGBLOB</td>
<td>0-4 294 967 295字节</td>
<td>二进制形式的极大文本数据</td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="选择："><a href="#选择：" class="headerlink" title="选择："></a>选择：</h5><ul>
<li>在符合应用要求（取值范围、精度）的前提下，尽量使用“短”数据类型</li>
<li>数据类型越简单越好</li>
<li>尽量采用精确小数类型，而不采用浮点数类型</li>
<li>使用内置的日期和时间数据类型，而不是使用字符串来存储</li>
<li>尽量避免<code>NULL</code>字段，建议将字段指定为<code>NOT NULL</code> 约束</li>
</ul>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h5 id="算术运算符："><a href="#算术运算符：" class="headerlink" title="算术运算符："></a>算术运算符：</h5><table>
<thead>
<tr>
<th>算术运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加法运算</td>
</tr>
<tr>
<td>-</td>
<td>减法运算</td>
</tr>
<tr>
<td>*</td>
<td>乘法运算</td>
</tr>
<tr>
<td>/</td>
<td>除法运算，返回商</td>
</tr>
<tr>
<td>%</td>
<td>求余运算，返回余数</td>
</tr>
</tbody></table>
<h5 id="比较运算符："><a href="#比较运算符：" class="headerlink" title="比较运算符："></a>比较运算符：</h5><table>
<thead>
<tr>
<th>比较运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>等于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
</tr>
<tr>
<td>&lt;=&gt;</td>
<td>安全的等于，不会返回 UNKNOWN</td>
</tr>
<tr>
<td>&lt;&gt; 或!=</td>
<td>不等于</td>
</tr>
<tr>
<td>IS NULL 或 ISNULL</td>
<td>判断一个值是否为 NULL</td>
</tr>
<tr>
<td>IS NOT NULL</td>
<td>判断一个值是否不为 NULL</td>
</tr>
<tr>
<td>LEAST</td>
<td>当有两个或多个参数时，返回最小值</td>
</tr>
<tr>
<td>GREATEST</td>
<td>当有两个或多个参数时，返回最大值</td>
</tr>
<tr>
<td>BETWEEN AND</td>
<td>判断一个值是否落在两个值之间</td>
</tr>
<tr>
<td>IN</td>
<td>判断一个值是IN列表中的任意一个值</td>
</tr>
<tr>
<td>NOT IN</td>
<td>判断一个值不是IN列表中的任意一个值</td>
</tr>
<tr>
<td>LIKE</td>
<td>通配符匹配</td>
</tr>
<tr>
<td>REGEXP</td>
<td>正则表达式匹配</td>
</tr>
</tbody></table>
<h6 id="正则匹配："><a href="#正则匹配：" class="headerlink" title="正则匹配："></a>正则匹配：</h6><ul>
<li>’ ^ ’  匹配以该字符后面的字符开头的字符串</li>
<li>‘ $ ’  匹配以该字符前面的字符结尾的字符串</li>
<li>‘ . ‘   匹配任何一个单字符</li>
<li>“ [ … ] ”  匹配在方括号内的任何字符        如” [ abc ] “ 表示匹配a、b或c        范围可用’ - ‘ 表示        如“ [ a-z ] “  表示匹配任意字母</li>
<li>’ * ’  匹配零个或多个在其前面的字符       如” x* “ 表示匹配任意数量的” x ” 字符</li>
</ul>
<h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><table>
<thead>
<tr>
<th>逻辑运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NOT 或者 !</td>
<td>逻辑非</td>
</tr>
<tr>
<td>AND 或者 &amp;&amp;</td>
<td>逻辑与</td>
</tr>
<tr>
<td>OR 或者 ||</td>
<td>逻辑或</td>
</tr>
<tr>
<td>XOR</td>
<td>逻辑异或（相同为零，相异为一）</td>
</tr>
</tbody></table>
<h5 id="位运算符："><a href="#位运算符：" class="headerlink" title="位运算符："></a>位运算符：</h5><table>
<thead>
<tr>
<th>位运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>|</td>
<td>按位或</td>
</tr>
<tr>
<td>&amp;</td>
<td>按位与</td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>按位左移</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>按位右移</td>
</tr>
<tr>
<td>~</td>
<td>按位取反，反转所有比特</td>
</tr>
</tbody></table>
<h3 id="数据表操作"><a href="#数据表操作" class="headerlink" title="数据表操作"></a>数据表操作</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE<span class="operator">&lt;</span>数据库名<span class="operator">&gt;</span>											<span class="comment">--使用数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] table_name(			   <span class="comment">--创建表</span></span><br><span class="line">	属性名 属性值</span><br><span class="line">	id <span class="type">int</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span> COMMENT <span class="string">&#x27;编号&#x27;</span>，</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span>  TABLES					<span class="comment">--查看数据库所有表名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--查看表的结构</span></span><br><span class="line"><span class="keyword">DESCRIBE</span> 表名</span><br><span class="line"><span class="keyword">DESC</span>  表名	</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名           <span class="comment">--不仅可以查看表创建时的详细语句，还可以查看存储引擎和字符编码</span></span><br></pre></td></tr></table></figure>



<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--修改表名</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span><span class="operator">&lt;</span>旧表名<span class="operator">&gt;</span> RENAME [<span class="keyword">TO</span>] <span class="operator">&lt;</span>新表名<span class="operator">&gt;</span></span><br><span class="line"><span class="comment">--修改字段数据类型</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span><span class="operator">&lt;</span>表名<span class="operator">&gt;</span> MODIFY <span class="operator">&lt;</span>字段名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span></span><br><span class="line"><span class="comment">--修改字段名</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span><span class="operator">&lt;</span>表名<span class="operator">&gt;</span> CHANGE <span class="operator">&lt;</span>旧字段名<span class="operator">&gt;</span> <span class="operator">&lt;</span>新字段名<span class="operator">&gt;</span> <span class="operator">&lt;</span>新数据类型<span class="operator">&gt;</span></span><br><span class="line"><span class="comment">--添加数据表字段</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span><span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">ADD</span> <span class="operator">&lt;</span>新字段名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [约束条件] [<span class="keyword">FIRST</span><span class="operator">|</span>AFTER 已经存在的字段名]</span><br><span class="line"><span class="comment">--删除字段</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span><span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">DROP</span> <span class="operator">&lt;</span>字段名<span class="operator">&gt;</span></span><br><span class="line"><span class="comment">--修改字段排序</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span><span class="operator">&lt;</span>表名<span class="operator">&gt;</span> MODIFY <span class="operator">&lt;</span>字段<span class="number">1</span><span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> <span class="keyword">FIRST</span><span class="operator">|</span>AFTER <span class="operator">&lt;</span>字段<span class="number">2</span><span class="operator">&gt;</span></span><br><span class="line"><span class="comment">--更改表的存储引擎</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span><span class="operator">&lt;</span>表名<span class="operator">&gt;</span> ENGINE <span class="operator">=</span><span class="operator">&lt;</span>更改后的存储引擎名<span class="operator">&gt;</span></span><br><span class="line"><span class="comment">--删除表的外键约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span><span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY <span class="operator">&lt;</span>外键约束名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--复制表的结构和数据</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] table_name</span><br><span class="line">[ () <span class="keyword">LIKE</span> old_table_name[] ]							<span class="comment">--选择表</span></span><br><span class="line"><span class="operator">|</span> [<span class="keyword">AS</span> (select_statement)]                               <span class="comment">--选择字段</span></span><br></pre></td></tr></table></figure>



<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span>[IF <span class="keyword">EXISTS</span>] 表<span class="number">1</span>，表<span class="number">2</span>……						  <span class="comment">--删除表</span></span><br><span class="line"><span class="keyword">SHOW</span> TABLES 											<span class="comment">--查看全部表</span></span><br></pre></td></tr></table></figure>





<h3 id="约束控制"><a href="#约束控制" class="headerlink" title="约束控制"></a>约束控制</h3><h4 id="数据完整性约束"><a href="#数据完整性约束" class="headerlink" title="数据完整性约束"></a>数据完整性约束</h4><ul>
<li>实体完整性：强制表的标识符列或主键的完整性</li>
<li>参照完整性：在删除和输入记录是，引用完整性保持表之间已定义的关系，确保键值在所有表中一致（不能引用不存在的值）</li>
<li>域完整性：限制类型、格式、可能值范围（外键约束、检查约束、默认值约束、非空约束和规则）</li>
<li>用户自定义完整性：用户自己定义的业务规则</li>
</ul>
<h4 id="字段约束"><a href="#字段约束" class="headerlink" title="字段约束"></a>字段约束</h4><h5 id="主键约束："><a href="#主键约束：" class="headerlink" title="主键约束："></a>主键约束：</h5><p>主键分为：单字段主键和多字段联合主键</p>
<p>任何主键字段的值不允许为<code>NULL</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">PRIMARY</span> KEY(字段名) 							<span class="comment">--设置单字段主键</span></span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(字段名<span class="number">1</span>，字段名<span class="number">2</span>)					 <span class="comment">--设置多字段联合主键</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY , <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY(字段名)			<span class="comment">--修改主键（先删除原来的主键，增加新主键）</span></span><br></pre></td></tr></table></figure>



<h5 id="外键约束："><a href="#外键约束：" class="headerlink" title="外键约束："></a>外键约束：</h5><p>外键取值 <code>NULL</code> 或者为关联表对应字段的值</p>
<p>主表（父表）与从表（子表）之间，以关联值为关键字，建立相关表的联系</p>
<p>子表的记录“参照”父表的记录，则父表的该记录不能删除（<code>DELETE</code>）或修改（<code>UPDATE</code>）</p>
<p>插入（<code>INSERT</code>）或者修改（<code>UPDATE</code>）子表的“外键值”，子表的“外键值”必须为父表的“主键值”或 <code>NULL</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--表级完整性</span></span><br><span class="line"><span class="keyword">FOREIGN</span> KEY(表A的字段名列表) <span class="keyword">REFERENCES</span> 表B(字段名列表)        </span><br><span class="line">[ <span class="keyword">ON</span> <span class="keyword">DELETE</span> &#123; CASCADE<span class="operator">|</span>RESTRICT<span class="operator">|</span><span class="keyword">SET</span> <span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">NO</span> ACTION &#125; ]</span><br><span class="line">[ <span class="keyword">ON</span> UPDATE &#123; CASCADE<span class="operator">|</span>RESTRICT<span class="operator">|</span><span class="keyword">SET</span> <span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">NO</span> ACTION &#125; ]</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">CASCADE：父表记录的删除或修改会自动删除或修改子表中对应的记录</span></span><br><span class="line"><span class="comment">RESTRICT:与NO ACTION 功能相同，为级联默认选项</span></span><br><span class="line"><span class="comment">SET NULL:父表记录的删除或修改会将子表中对应的外键值设置为NULL</span></span><br><span class="line"><span class="comment">NO ACTION:父表执行记录的删除或修改时，若子表存在对应记录，操作失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="comment">--若表已创建</span></span><br><span class="line">	<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name   </span><br><span class="line">	<span class="keyword">ADD</span> [<span class="keyword">CONSTRAINT</span> 外键名] <span class="keyword">FOREIGN</span> KEY [id] (index_col_name,……)</span><br><span class="line">	<span class="keyword">REFERENCES</span> table_name(index_col_name,……)</span><br><span class="line">	[ <span class="keyword">ON</span> <span class="keyword">DELETE</span> &#123; CASCADE<span class="operator">|</span>RESTRICT<span class="operator">|</span><span class="keyword">SET</span> <span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">NO</span> ACTION &#125; ]</span><br><span class="line">	[ <span class="keyword">ON</span> UPDATE &#123; CASCADE<span class="operator">|</span>RESTRICT<span class="operator">|</span><span class="keyword">SET</span> <span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">NO</span> ACTION &#125; ]</span><br><span class="line">	<span class="comment">--若表未创建</span></span><br><span class="line">	<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">	index_col_name  数据类型  约束,</span><br><span class="line">	……,</span><br><span class="line">	<span class="keyword">FOREIGN</span> KEY(index_col_name) <span class="keyword">REFERENCES</span> 表名(index_col_name)</span><br><span class="line">	)</span><br><span class="line"><span class="comment">--列级完整性</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">	index_col_name  数据类型 约束 <span class="keyword">REFERENCES</span> 表名(index_col_name),     <span class="comment">--直接在字段后添加REFERENCES命令</span></span><br><span class="line">	……,</span><br></pre></td></tr></table></figure>



<h5 id="非空约束："><a href="#非空约束：" class="headerlink" title="非空约束："></a>非空约束：</h5><p>设置某个字段的非空约束，即该字段不能为<code>NULL</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">字段名 数据类型 <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure>



<h5 id="唯一约束："><a href="#唯一约束：" class="headerlink" title="唯一约束："></a>唯一约束：</h5><p>要求该列唯一，允许为空，但只能出现一个空值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">字段名 数据类型 <span class="keyword">UNIQUE</span> </span><br></pre></td></tr></table></figure>

<p><code>UNIQUE</code> 和<code>PRIMARY KEY</code> 的区别：一个表中可以有多个字段声明为<code>UNIQUE</code>且允许空值，只能有一个<code>PRIMARY KEY</code> 声明且不允许空值</p>
<h5 id="默认约束："><a href="#默认约束：" class="headerlink" title="默认约束："></a>默认约束：</h5><p>若某字段满足默认值约束要求，可以向该字段添加默认值约束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">字段名 数据类型 [其他约束条件] <span class="keyword">DEFAULT</span> 默认值</span><br></pre></td></tr></table></figure>



<h5 id="自增约束："><a href="#自增约束：" class="headerlink" title="自增约束："></a>自增约束：</h5><p>希望在每次插入新记录时，系统自动生成字段的主键值</p>
<p>一个表中只能有一个字段使用<code>AUTO_INCREMENT</code>约束，且该字段必须为主键的一部分</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">字段名 数据类型 [其他约束条件] AUTO_INCREMENT</span><br></pre></td></tr></table></figure>



<h5 id="检查约束："><a href="#检查约束：" class="headerlink" title="检查约束："></a>检查约束：</h5><p>设置检查约束直接在数据类型后加约束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">字段名 数据类型 [其他约束条件] <span class="keyword">CHECK</span>(检查条件)</span><br></pre></td></tr></table></figure>



<h4 id="删除约束"><a href="#删除约束" class="headerlink" title="删除约束"></a>删除约束</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> 约束条件  字段名 </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>大学课程</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL视图</title>
    <url>/2021/10/04/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图是一个虚拟表，<strong>不占据存储空间</strong>，数据来源于数据库表或其他视图，当基本表发生变化时，视图的数据也会变化</p>
<p>当调用视图时，才会执行视图中的SQL语句，进行取数据操作</p>
<span id="more"></span>

<h4 id="视图的优势"><a href="#视图的优势" class="headerlink" title="视图的优势"></a>视图的优势</h4><ul>
<li><p>增强数据安全性（不同的用户分配不同的视图）</p>
</li>
<li><p>提高灵活性，操作简单</p>
</li>
<li><p>提高数据的逻辑独立性</p>
<blockquote>
<p>使用视图可以向应用程序屏蔽表结构</p>
<p>使用视图可以向数据库表屏蔽应用程序</p>
</blockquote>
</li>
</ul>
<h3 id="视图定义和管理"><a href="#视图定义和管理" class="headerlink" title="视图定义和管理"></a>视图定义和管理</h3><h4 id="创建与使用："><a href="#创建与使用：" class="headerlink" title="创建与使用："></a>创建与使用：</h4><p>创建视图需要<code>CREATE VIEW</code> 的权限以及<code>SELECT</code> 权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [ALGORITHM <span class="operator">=</span> &#123;UNDEFINED <span class="operator">|</span> <span class="keyword">MERGE</span> <span class="operator">|</span> TEMPTABLE&#125;]</span><br><span class="line"><span class="keyword">VIEW</span> 视图名 [(视图列表)]						<span class="comment">--视图名唯一</span></span><br><span class="line"><span class="keyword">AS</span> 查询语句									  </span><br><span class="line">[<span class="keyword">WITH</span> [<span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> OPTION] 		<span class="comment">--CASCADED表示更新视图时要满足所有相关视图和表的条件，为默认值</span></span><br><span class="line">											<span class="comment">--LOCAL表示更新视图时，满足该视图本身的定义条件即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--例：在表1上创建一个名为表1_view的视图，包含字段1，字段2，字段3</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 表<span class="number">1</span>_view(字段<span class="number">1</span>,字段<span class="number">2</span>,字段<span class="number">3</span>) <span class="keyword">AS</span> <span class="keyword">SELECT</span> 字段<span class="number">1</span>,字段<span class="number">2</span>,字段<span class="number">3</span>  <span class="keyword">FROM</span> 表<span class="number">2</span>，表<span class="number">3</span>，表<span class="number">4</span> <span class="keyword">WHERE</span> (条件)</span><br><span class="line"><span class="comment">--例：查询给定值的信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span><span class="keyword">FROM</span> 表<span class="number">1</span>_view <span class="keyword">WHERE</span> 字段<span class="number">1</span><span class="operator">=</span><span class="string">&#x27;给定值&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>当向与视图关联的表中添加新字段，查询时该视图不包括新字段；若与视图关联的表或视图被删除，该视图不能使用</p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>删除视图时，只能删除视图的定义，不会删除数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> [IF <span class="keyword">EXISTS</span>]</span><br><span class="line">view_name[,view_name2]……</span><br><span class="line">[RESTRICT <span class="operator">|</span> CASCADE]</span><br></pre></td></tr></table></figure>

<p>一次可以删除多个视图</p>
<h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><p>查看视图要有<code>SHOW VIEW</code> 的权限</p>
<p>查看方法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DESCRIBE</span> 视图名称;      或者<span class="keyword">DESC</span> 视图名称;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;视图名&#x27;</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> <span class="string">&#x27;视图名&#x27;</span></span><br><span class="line"><span class="comment">--查询某数据库下的视图表</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span><span class="keyword">FROM</span> db_name.views <span class="keyword">WHERE</span> table_name <span class="operator">=</span><span class="string">&#x27;视图名&#x27;</span></span><br></pre></td></tr></table></figure>



<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> 视图名[&#123;属性清单&#125;] <span class="keyword">AS</span> <span class="keyword">SELECT</span> 语句 </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> 视图名[&#123;属性清单&#125;] <span class="keyword">AS</span> <span class="keyword">SELECT</span> 语句</span><br></pre></td></tr></table></figure>



<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>通过视图进行插入(<code>INSERT</code>)、更新(<code>UPDATE</code>)、删除(<code>DELETE</code>)表中的数据</p>
<p>更新视图的语法与<code>UPDATE</code>语法一致</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>大学课程</tag>
      </tags>
  </entry>
  <entry>
    <title>关系代数与关系数据库理论</title>
    <url>/2021/10/04/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%E4%B8%8E%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h3 id="关系代数及其运算"><a href="#关系代数及其运算" class="headerlink" title="关系代数及其运算"></a>关系代数及其运算</h3><p>关系查询语言分为：</p>
<p>关系代数语言：用关系的运算来表达查询要求的方式，查询操作是以集合操作位基础运算的DML语言</p>
<p>关系演算语言：用谓词来表达查询要求的方式，查询操作是以谓词演算为基础运算的DML语言。</p>
<span id="more"></span>

<h4 id="关系代数运算符"><a href="#关系代数运算符" class="headerlink" title="关系代数运算符"></a>关系代数运算符</h4><h5 id="集合运算符"><a href="#集合运算符" class="headerlink" title="集合运算符"></a>集合运算符</h5><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">含义</th>
<th align="left">英文</th>
</tr>
</thead>
<tbody><tr>
<td align="left">∪</td>
<td align="left">并</td>
<td align="left">Union</td>
</tr>
<tr>
<td align="left">−</td>
<td align="left">差</td>
<td align="left">Difference</td>
</tr>
<tr>
<td align="left">∩</td>
<td align="left">交</td>
<td align="left">Intersection</td>
</tr>
<tr>
<td align="left">×</td>
<td align="left">笛卡尔积</td>
<td align="left">Cartesian Product</td>
</tr>
</tbody></table>
<h5 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h5><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&gt;</td>
<td align="left">大于</td>
</tr>
<tr>
<td align="left">≥</td>
<td align="left">大于等于</td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">小于</td>
</tr>
<tr>
<td align="left">≤</td>
<td align="left">小于等于</td>
</tr>
<tr>
<td align="left">=</td>
<td align="left">等于</td>
</tr>
<tr>
<td align="left">≠</td>
<td align="left">不等于</td>
</tr>
</tbody></table>
<h5 id="专门的关系运算符"><a href="#专门的关系运算符" class="headerlink" title="专门的关系运算符"></a>专门的关系运算符</h5><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">含义</th>
<th align="left">英文</th>
</tr>
</thead>
<tbody><tr>
<td align="left">σ</td>
<td align="left">选择</td>
<td align="left">Selection</td>
</tr>
<tr>
<td align="left">π</td>
<td align="left">投影</td>
<td align="left">Projection</td>
</tr>
<tr>
<td align="left">⋈</td>
<td align="left">链接</td>
<td align="left">Join</td>
</tr>
<tr>
<td align="left">÷</td>
<td align="left">除</td>
<td align="left">Division</td>
</tr>
</tbody></table>
<h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">∧</td>
<td align="left">与</td>
</tr>
<tr>
<td align="left">∨</td>
<td align="left">或</td>
</tr>
<tr>
<td align="left">¬</td>
<td align="left">非</td>
</tr>
</tbody></table>
<h5 id="基本的关系代数运算"><a href="#基本的关系代数运算" class="headerlink" title="基本的关系代数运算"></a>基本的关系代数运算</h5><h6 id="并（Union）"><a href="#并（Union）" class="headerlink" title="并（Union）"></a>并（Union）</h6><p>关系 R 与 S 具有相同的关系模式，即 R 与 S 的元数相同（结构相同），R 与 S 的并是属于 R 或者属于 S 的元组构成的集合，记作 R ∪ S，定义如下：</p>
<p>R∪S={t|t∈R∨t∈S}R∪S={t|t∈R∨t∈S}</p>
<h6 id="差（Difference）"><a href="#差（Difference）" class="headerlink" title="差（Difference）"></a>差（Difference）</h6><p>关系 R 与 S 具有相同的关系模式，关系 R 与 S 的差是属于 R 但不属于 S 的元组构成的集合，记作 R − S，定义如下：</p>
<p>R−S={t|t∈R∨t∉S}R−S={t|t∈R∨t∉S}</p>
<h6 id="交（Intersection）"><a href="#交（Intersection）" class="headerlink" title="交（Intersection）"></a>交（Intersection）</h6><p>关系 R 和 S 具有相同的关系模式，交是由属于 R 同时双属于 S 的元组构成的集合，记作 R∩S，形式如下：</p>
<p>R∩S={t|t∈R∧t∈S}R∩S={t|t∈R∧t∈S}</p>
<h6 id="广义笛卡尔积（Extended-Cartesian-Product）"><a href="#广义笛卡尔积（Extended-Cartesian-Product）" class="headerlink" title="广义笛卡尔积（Extended Cartesian Product）"></a>广义笛卡尔积（Extended Cartesian Product）</h6><p>两个无数分别为 n 目和 m 目的关系 R 和 S 的 笛卡尔积是一个 (n+m) 列的元组的集合。组的前 n 列是关系 R 的一个元组，后 m 列是关系 S 的一个元组，记作 R × S，定义如下：</p>
<p>R×S={t|t=&lt;(T<sub>n</sub>,T<sub>m</sub>)∧T<sub>n</sub>∈R∧T<sub>m</sub>∈S}R×S={t|t=&lt;(T<sub>n</sub>,T<sub>m</sub>)∧T<sub>n</sub>∈R∧T<sub>m</sub>∈S}</p>
<p>$(t^n,t^m)$ 表示元素 $t^n$ 和 $t^m$ 拼接成的一个元组</p>
<p><strong>注：新关系中属性的个数为n+m，元组的个数为k1×k2.</strong></p>
<h5 id="投影（Projection）"><a href="#投影（Projection）" class="headerlink" title="投影（Projection）"></a>投影（Projection）</h5><p>投影运算是从关系的垂直方向进行运算，在关系 R 中选出若干属性列 A 组成新的关系，记作 $π_A(R)$，其形式如下：</p>
<p>πA(R)={t[A]|t∈R}πA(R)={t[A]|t∈R}</p>
<h5 id="选择（Selection）"><a href="#选择（Selection）" class="headerlink" title="选择（Selection）"></a>选择（Selection）</h5><p>选择运算是从关系的水平方向进行运算，是从关系 R 中选择满足给定条件的元组，记作 $σ_F(R)$，其形式如下：</p>
<p>σF(R)={t|t∈R∧F(t)=True}σF(R)={t|t∈R∧F(t)=True}</p>
<h6 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h6><p>设有关系 R、S 如图所示，求 $R∪S$、 $R−S$、 $R×S$、 $π_{A,C}(R)$、 $σ_{A&gt;B}(R)$ 和 $σ_{3&lt;4}(R×S)$</p>
<p><img src="https://img10.360buyimg.com/devfe/jfs/t3967/269/2409299226/5377/e997b909/58a95fceNddd39fd7.png" alt="关系表RS"></p>
<p>进行并、差运算后结果如下：</p>
<p><img src="https://img14.360buyimg.com/devfe/jfs/t3949/95/2458170516/5487/1c7f1f38/58a967b1N42db123f.png" alt="并差"></p>
<p>进行笛卡尔、 投影、 选择运算后结果如下：</p>
<p><img src="https://img30.360buyimg.com/devfe/jfs/t3943/109/2403665652/38834/c636281b/58a9685dN20af0b9b.png" alt="笛卡尔_投影_选择"></p>
<h5 id="链接（Join）"><a href="#链接（Join）" class="headerlink" title="链接（Join）"></a>链接（Join）</h5><h6 id="等值链接"><a href="#等值链接" class="headerlink" title="等值链接"></a>等值链接</h6><p>当 θ 为「=」时，称之为等值链接，记为： $R\Join_{X=Y}S$</p>
<h6 id="自然链接"><a href="#自然链接" class="headerlink" title="自然链接"></a>自然链接</h6><p>自然链接是一种特殊的等值链接，它要求两个关系中进行比较的分量必须是 <strong>相同的属性组</strong>，并且在结果集中将 <strong>重复的属性列</strong> 去掉</p>
<p>例如：设有关系 R、S 如图所示，求 $R \Join S$</p>
<p><img src="https://img11.360buyimg.com/devfe/jfs/t3982/212/2472511181/5973/54467e2a/58aa5ffaN970f7e5a.png" alt="关系RS"></p>
<p>先求出笛卡尔积 $R×S$，找出比较分量（有相同属性组），即: R.A/S.A 与 R.C/S.C</p>
<p><img src="https://img10.360buyimg.com/devfe/jfs/t3841/5/4275908218/12385/79e83d01/58aa6066Nd003e697.png" alt="求出笛卡尔积"></p>
<p>取等值链接 $R.A = S.A$ 且 $R.C = S.C$</p>
<p><img src="https://img10.360buyimg.com/devfe/jfs/t3256/75/6205568741/12327/2b1dc867/58aa60e8N38a84108.png" alt="找出相同属性的比较分量"></p>
<p>结果集中去掉重复属性列，注意无论去掉 R.A 或者 S.A 效果都一样，因为他们的值相等，结果集中只会有属性 A、B、C、D</p>
<p><img src="https://img12.360buyimg.com/devfe/jfs/t3217/183/6576493853/4744/ccb96965/58aa612eN043f7425.png" alt="结果集中找出重复属性列"></p>
<p>最终得出结果</p>
<p><img src="https://img12.360buyimg.com/devfe/jfs/t3247/65/6676502314/2874/657ddb0c/58aa617eN2457f536.png" alt="RS自然链接结果"></p>
<h5 id="除（Division）"><a href="#除（Division）" class="headerlink" title="除（Division）"></a>除（Division）</h5><p>设有以下如图关系，求 $R÷S$</p>
<p><img src="https://img10.360buyimg.com/devfe/jfs/t3151/348/6716540896/7287/dc01ad2e/58aaaf3bN1cae8b1a.png" alt="关系RS1"></p>
<p>取关系 R 中有的但 S 中没有的属性组，即：A、B</p>
<p><img src="https://img11.360buyimg.com/devfe/jfs/t3202/137/6722879648/7244/3b47a185/58aaaf81N0b2491b5.png" alt="关系RS1取属性AB"></p>
<p>取唯一 A、B 属性组值的象集</p>
<p>象集：本质上是一次选择行的运算和一次选择列的运算。<br>求x1在表A中的象集，就是先选出所有x属性中x=x1的那些行，然后选择出不包含x1的那些列。</p>
<p><img src="https://img11.360buyimg.com/devfe/jfs/t3871/170/2430481542/5179/be5899c5/58aaafe6N8297b49f.png" alt="关系RS1取属性AB对应的象集"></p>
<p>可知关系S存在于 a,b/c,k 象集 中。即 $R÷S$ 得</p>
<p><img src="https://img10.360buyimg.com/devfe/jfs/t3130/361/6704334588/3366/6b7e0b56/58aab058N3a3c374d.png" alt="关系RS1除结果"></p>
<p> **注：当提出查询“全部”，“所有”，“至少”这样的关键字时可以考虑使用除法解决。 **        实例：P52</p>
<h3 id="关系数据库理论"><a href="#关系数据库理论" class="headerlink" title="关系数据库理论"></a>关系数据库理论</h3><h4 id="数据冗余"><a href="#数据冗余" class="headerlink" title="数据冗余"></a>数据冗余</h4><p>关系模式中可能存在的冗余和异常问题</p>
<p>1.数据冗余   2.更新异常  3.插入异常  4.删除异常</p>
<h4 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h4><p>数据依赖分为：函数依赖、多值依赖、连接依赖</p>
<p>函数依赖与关键字</p>
<p>设R为任一给定关系，如果对于R中属性X的每一个值，R中的属性Y只有唯一值与之对应，则称X函数决定Y或Y函数依赖于X</p>
<ul>
<li>完全函数依赖<ul>
<li>如果存在 X 属性集（注意是集合，说明是联合主键）决定唯一的 Y ，且 X 中的任一子集都不能决定唯一的 Y，则 Y 完全依赖于 X。</li>
<li>例如：学生数学成绩完全由该学生的学号和数学课决定，所以数学课成绩完全依赖于（学号，数学课）</li>
</ul>
</li>
<li>部分函数依赖<ul>
<li>X 的属性集中任一子集都可以决定唯一的 Y</li>
<li>例如：学生学号和姓名可以决定唯一的学生，但是学生号也可以决定唯一的学生</li>
</ul>
</li>
<li>传递函数依赖<ul>
<li>设 R 为任一给定关系， X Y Z 为其不同的属性子集，若 X —&gt; Y, Y 不决定 X 且 Y —&gt;Z，则有 X —&gt;Z，称为 Z 传递函数依赖于 X</li>
<li>例如：书的出版编号是唯一，版权归出版社所有，所以只能由该出版社出版。所以存在函数依赖：书出版编号—&gt;出版社名，出版社名—&gt;出版社地址，但是出版社名不能决定唯一的出版书编号，则有出版社地址传递函数依赖于出版书编号</li>
</ul>
</li>
</ul>
<h4 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h4><p><strong>第一范式：</strong></p>
<p>若一个关系模式R的所有属性都是不可分的基本数据项，则该关系属于第一范式（1NF）</p>
<p>满足1NF的关系称为规范化的关系，否则为非规范化关系</p>
<p><strong>第二范式：</strong></p>
<p>每一个非主属性都完全依赖于主关键字，而不是部分依赖，则该关系属于第二范式（2NF）</p>
<p>若关系模式R属于1NF，且R中全部是主属性，则R必定是2NF</p>
<p>若关系模式R属于1NF，且R中所有的候选关键字全部是单属性构成，则R必定是2NF</p>
<p>二元关系模式必必定是2NF</p>
<p><strong>第三范式：</strong></p>
<p>每一个非主属性都不传递依赖于关键字，则该关系属于第三范式（3NF）</p>
<p>若关系模式R属于1NF，且R中全部是主属性，则R必定是3NF</p>
<p><strong>BCNF</strong>：</p>
<p>关系模式R是1NF，且每个属性都不传递函数依赖于R的候选关键字，则该关系属于BCNF</p>
<p>二元关系模式必定是BCNF</p>
<p>都是主属性的关系模式并非一定属于BCNF</p>
<p><strong>非范式化：</strong></p>
<p>在一个表格中有意义地引入冗余以改进性能被称为非范式化。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>大学课程</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统概述</title>
    <url>/2021/10/04/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h3 id="数据与数据管理技术"><a href="#数据与数据管理技术" class="headerlink" title="数据与数据管理技术"></a>数据与数据管理技术</h3><span id="more"></span>

<h4 id="数据库基本概念"><a href="#数据库基本概念" class="headerlink" title="数据库基本概念"></a>数据库基本概念</h4><h5 id="数据与信息："><a href="#数据与信息：" class="headerlink" title="数据与信息："></a>数据与信息：</h5><p>数据是描述事物的符号记录，是指用物理符号记录下来的、可以鉴别的信息。</p>
<p>信息是有一定含义的、经过加工处理的、对决策有价值的数据。</p>
<p>数据是信息的载体，信息是数据的内涵。</p>
<p>数据处理也称为信息处理，是指对各种形式的数据进行收集、存储、传播和加工直至产生新信息输出的全过程。</p>
<p>数据管理是数据处理的中心问题，是指数据的收集、整理、组织、存储、查询、维护和传送等各种操作，也是数据处理的基本环节，是数据处理必有得共性部分。</p>
<h5 id="数据库（DB）："><a href="#数据库（DB）：" class="headerlink" title="数据库（DB）："></a>数据库（DB）：</h5><p>数据库（DB）是按照一定结构组织并长期存储在计算机内的、可共享的大量数据得集合。</p>
<p>数据库中存储的数据具有<strong>永久存储</strong>、<strong>有组织</strong>和<strong>可共享</strong>三个基本特点。</p>
<h5 id="数据库管理系统（DBMS）："><a href="#数据库管理系统（DBMS）：" class="headerlink" title="数据库管理系统（DBMS）："></a>数据库管理系统（DBMS）：</h5><p>数据库管理系统（DBMS）是位于用户与操作系统之间的一层数据管理软件，安装与操作系统之上，是一个管理、控制数据库中各种数据库对象的系统软件。</p>
<p>数据库管理系统是数据库系统的一个重要组成部分。</p>
<p><strong>主要功能：</strong></p>
<p>1.<strong>数据定义功能</strong>：DBMS提供数据定义语言（DDL），定义数据库中的数据对象。</p>
<p>例：表、视图、存储过程、触发器等</p>
<p>2.<strong>数据操纵功能</strong>：DBMS停工数据操纵语言（DML）操纵数据实现对数据可的基本操作。</p>
<p>例：查询、插入、删除、修改等</p>
<p>3.<strong>数据库的运行管理</strong>：保证数据的安全性、完整性、多用户对数据的并发使用以及发生故障后的系统恢复</p>
<p>4.数据库的建立和维护功能：创建数据库及对数据库空间的维护、数据库的备份与恢复功能、数据库的重组织功能和性能监视、分析等</p>
<p>5.数据组织、存储和管理功能</p>
<p>例：索引查找、顺序查找</p>
<p>6.其他功能：主要包括与其他软件的网络通信功能、不同数据库管理系统之间的数据传输以及相互访问功能等</p>
<h5 id="数据库系统（DBS）："><a href="#数据库系统（DBS）：" class="headerlink" title="数据库系统（DBS）："></a>数据库系统（DBS）：</h5><p>数据库系统（DBS）是指计算机引入数据库后的系统，，它能够有组织地、动态地存储大量的数据，提供数据处理和数据共享机制。</p>
<p>通常一个完整的数据库系统包括<strong>数据库</strong>、<strong>数据管理系统</strong>及相<strong>关实用工具</strong>、<strong>应用程序</strong>、<strong>数据库管理员</strong>和<strong>用户</strong>。</p>
<p>数据库管理员（DBA）是专门负责对数据库进行维护，并保证数据库正常、高效运行。</p>
<p>数据库系统是最大的。</p>
<h4 id="数据管理技术的发展"><a href="#数据管理技术的发展" class="headerlink" title="数据管理技术的发展"></a>数据管理技术的发展</h4><h5 id="人工管理阶段："><a href="#人工管理阶段：" class="headerlink" title="人工管理阶段："></a>人工管理阶段：</h5><p>特点：</p>
<p>1.数据不保存</p>
<p>2.应用程序管理数据</p>
<p>3.数据面向应用</p>
<p><strong>记录内无结构，整体无结构</strong></p>
<h5 id="文件系统阶段："><a href="#文件系统阶段：" class="headerlink" title="文件系统阶段："></a>文件系统阶段：</h5><p>特点：</p>
<p>数据的管理者：文件系统，<strong>数据可长期保存</strong></p>
<p>数据面向的对象：某一应用程序</p>
<p>数据的共享程度：<strong>共享性差、冗余度大</strong></p>
<p>数据的结构化：<strong>记录内用结构，整体无结构</strong></p>
<p>数据的独立性：<strong>独立性差</strong>，数据的逻辑结构改变必须修改应用程序</p>
<p>数据控制能力：应用程序自己控制</p>
<h5 id="数据库系统阶段："><a href="#数据库系统阶段：" class="headerlink" title="数据库系统阶段："></a>数据库系统阶段：</h5><p>特点：<strong>1.数据集成                            2.数据共享性高</strong></p>
<p>​            <strong>3.数据冗余小                        4.数据一致性</strong></p>
<p>​            <strong>5.数据独立性高</strong>                    <strong>6.实施统一管理与控制</strong></p>
<p>​            7.减少应用程序开发与维护的工作量</p>
<p><img src="https://img-blog.csdnimg.cn/20191103183545415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbGlsaWxpbGlsaWtp,size_16,color_FFFFFF,t_70" alt="数据管理3个阶段的比较"></p>
<h3 id="数据库系统的特点及组成"><a href="#数据库系统的特点及组成" class="headerlink" title="数据库系统的特点及组成"></a>数据库系统的特点及组成</h3><h4 id="数据库系统的特点："><a href="#数据库系统的特点：" class="headerlink" title="数据库系统的特点："></a>数据库系统的特点：</h4><p>1.数据结构化</p>
<p>2.数据的共享性高，冗余度低，易扩充</p>
<p>3.数据独立性高：数据独立性包括物理独立性和逻辑独立性</p>
<p>逻辑独立性指用户的应用程序与数据库的逻辑结构式相互独立的</p>
<p>4.数据由DBMS统一管理和控制：</p>
<p>数据由DBMS统一管理和控制，用户和应用程序通过DBMS访问和使用数据库</p>
<p><strong>DBMS数据控制功能</strong></p>
<p>1.数据的安全性保护</p>
<p>2.数据的完整性检查</p>
<p>3.并发控制</p>
<p>4.数据库恢复</p>
<h3 id="数据库系统结构"><a href="#数据库系统结构" class="headerlink" title="数据库系统结构"></a>数据库系统结构</h3><h4 id="三级模式结构："><a href="#三级模式结构：" class="headerlink" title="三级模式结构："></a>三级模式结构：</h4><p>数据库系统内部的体系结构通常采用三级模式结构，即有外模式、模式和内模式组成</p>
<h5 id="模式："><a href="#模式：" class="headerlink" title="模式："></a>模式：</h5><p>模式也称为概念模式或逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公有数据库结构。</p>
<p>特性：</p>
<p>1.一个数据库只有一个模式</p>
<p>2.模式与具体应用程序无关，它只是装配数据的一个框架</p>
<p>3.模式用语言描述和定义，需定义数据的逻辑结构、数据有关的安全性等</p>
<h5 id="外模式："><a href="#外模式：" class="headerlink" title="外模式："></a>外模式：</h5><p>外模式也称为子模式或用户模式，是数据库用户所见和使用的局部数据的逻辑结构和特征的描述，是用户所用的数据库结构</p>
<p>特性：</p>
<p>1.一个数据库可以有多个外模式；每个用户至少使用一个外模式</p>
<p>2.同一个用户可使用不同的外模式，而每个外模式可为不同的用户所用</p>
<p>3.模式是对全体用户数据及其关系的综合与抽象，外模式是根据所需对模式的抽取</p>
<h5 id="内模式："><a href="#内模式：" class="headerlink" title="内模式："></a>内模式：</h5><p>内模式也称为存储模式，是数据物理结构的存储方法的描述。它是整个数据库的最底层结构的表示。</p>
<p>特性：<br>1.一个数据库只有一个内模式。内模式对用户透明</p>
<p>2.一个数据库由多种文件组成，如用户数据文件、索引文件及系统文件等</p>
<p>3.内模式设计直接影响数据库的性能</p>
<h5 id="模式关系："><a href="#模式关系：" class="headerlink" title="模式关系："></a>模式关系：</h5><p>以物理模式为框架的数据库称为物理数据库。在数据库系统中，只有物理数据库才是真正存在的，它是存储在外存的实际数据文件；而概念数据库和用户数据库在计算机外存是不存在的。</p>
<p>1.概念数据库是物理数据库的逻辑抽象形式</p>
<p>2.物理数据库是概念数据库的具体实现</p>
<p>3.用户数据库是概念数据库的子集，也是物理数据库子集的逻辑描述</p>
<h5 id="数据独立性与二级映像功能："><a href="#数据独立性与二级映像功能：" class="headerlink" title="数据独立性与二级映像功能："></a>数据独立性与二级映像功能：</h5><p>数据独立性是指数据与程序间的互不依赖性，一般分为<strong>物理独立性</strong>与<strong>逻辑独立性</strong></p>
<p>（1）外模式/模式映像（逻辑独立性）</p>
<p>（2）模式/内模式映像（物理独立性）</p>
<p>两级映像特性：</p>
<p>1.模式/内模式映像是唯一的</p>
<p>2.子模式/模式映像不唯一</p>
<h5 id="三级模式结构与两层映像的优点："><a href="#三级模式结构与两层映像的优点：" class="headerlink" title="三级模式结构与两层映像的优点："></a>三级模式结构与两层映像的优点：</h5><p>1.保证数据的独立性</p>
<p>2.方便用户使用，简化用户接口</p>
<p>3.保证数据库安全性的一个有力措施</p>
<p>4.有利于数据的共享性</p>
<p>5.有利于从宏观上通俗地理解数据库系统地内部结构</p>
<h4 id="数据库系统体系结构："><a href="#数据库系统体系结构：" class="headerlink" title="数据库系统体系结构："></a>数据库系统体系结构：</h4><h5 id="客户-服务器结构（C-S）结构："><a href="#客户-服务器结构（C-S）结构：" class="headerlink" title="客户/服务器结构（C/S）结构："></a>客户/服务器结构（C/S）结构：</h5><p>C/S结构的基本原则是将计算机应用任务分解成多个子任务，由多台计算机分工完成，即采用“功能分布”原则</p>
<h5 id="浏览器-服务器（B-S）结构："><a href="#浏览器-服务器（B-S）结构：" class="headerlink" title="浏览器/服务器（B/S）结构："></a>浏览器/服务器（B/S）结构：</h5><p>B/S最大优点是可以在任何地方进行操作而不用安装任何专门的软件，客户端零安装、零维护。B/S结构推动了AJAX技术的发展，它的程序也能在客户端计算机上进行部分处理，从而大大地减轻了服务器的负担；并增加了交互性，能进行局部实时刷新</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>大学课程</tag>
      </tags>
  </entry>
  <entry>
    <title>IP地址规划技术</title>
    <url>/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="IP地址分类及子网划分"><a href="#IP地址分类及子网划分" class="headerlink" title="IP地址分类及子网划分"></a>IP地址分类及子网划分</h2><h3 id="标准分类的-IP-地址"><a href="#标准分类的-IP-地址" class="headerlink" title="标准分类的 IP 地址"></a>标准分类的 IP 地址</h3><p>常用的 A 类、B 类、C 类采用包括“网络-主机号”的两级的层级结构</p>
<span id="more"></span>

<p>IPv4 的 <strong>地址长度是 32bit</strong>，用 <strong>点分十进制</strong> 表示，如 x.x.x.x 的格式。其中每个 <strong>x 为 8bit</strong>，取值范围（00000000-11111111）,对应的十进制取值范围是（0-255）</p>
<p>机器中存放的 IP 地址是 32 位二进制代码，每隔 8 为插入一个空格能提高可读性，将每 8 为的二进制数转换为十进制数，采用点分十进制记法则更加便于使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10000000 00001011 00000011 0001111 =&gt; 128.11.3.31</span><br></pre></td></tr></table></figure>

<p><img src="https://bluexiaowei.github.io/NCRE3/static/images/03-01.png" alt="地址类别"></p>
<p>每个网络中“全 0”和“全 1”的主机号的地址有特殊用法，所以是需要去除的</p>
<table>
<thead>
<tr>
<th>地址类别</th>
<th>主机地址范围</th>
<th>可分配的网络数</th>
<th>每个网络内可分配的最大主机数</th>
</tr>
</thead>
<tbody><tr>
<td>A 类</td>
<td>1.0.0.0 ~ 127.255.255.255</td>
<td>$2^7-2=126$</td>
<td>$2^{24}-2=16777214$</td>
</tr>
<tr>
<td>B 类</td>
<td>128.0.0.0 ~ 191.255.255.255</td>
<td>$2^{14}=128$</td>
<td>$2^{16}-2=65534$</td>
</tr>
<tr>
<td>C 类</td>
<td>192.0.0.0 ~ 223.255.255.255</td>
<td>$2^{21}=2097152$</td>
<td>$2^8-2=254$</td>
</tr>
</tbody></table>
<h3 id="特殊地址形式"><a href="#特殊地址形式" class="headerlink" title="特殊地址形式"></a>特殊地址形式</h3><p>特殊的 IP 地址包括：<strong>受限广播地址、直接广播地址、“这个网络上的特定主机”地址</strong>与回送地址</p>
<ol>
<li><p>受限广播地址</p>
<p>受限官博地址又称有限广播地址，该地址形式唯一，即：<strong>32 位全为 1 的 IP 地址（255.255.255.255）</strong>。此地址用来将一个分组以广播方式发送给本网络中的所有主机（本网内成员向全网广播）</p>
</li>
<li><p>直接广播地址</p>
<p><strong>直接广播地址的形式是一个有效的网络号和一个全 1 的主机号</strong>，用来使路由器将一个来自其他网络的分组以广播方式发送给特定网络上的所有主机</p>
<p><strong>在 IP 地址计算中：直接广播地址使 IP 地址网络号不变，主机号全为 1 的地址</strong></p>
</li>
<li><p>“这个网络上的特定主机”地址——主机号</p>
<p>“这个网络上的特定主机”地址用于同一网络内部某个主机或某个路由器向另一个主机发送分组</p>
<p><strong>“这个网络上的特定主机”地址的形式为一个全 0 的网络号和一个确定的主机号</strong></p>
<p><strong>在 IP 地址计算中：主机号是 IP 地址网络全为 0 主机号不变的地址</strong></p>
</li>
<li><p>回送地址</p>
<p>A 类 IP 地址中的 127.0.0.0 是一个保留地址，它即回送地址。用于网络软件测试和本地进程间通信使用</p>
</li>
<li><p>特殊地址</p>
<p>IPv4为内部网络预留的专用IP地址有三组</p>
<p>第一组是A类地址的一个地址块，这个地址中的地址空间为10.0.0.0~10.255.255.255</p>
<p>第二组是B类地址的16个地址块（172.16~172.31）</p>
<p>第三组是C类地址的256个地址块（192.168.0~192.168.255）</p>
</li>
</ol>
<h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><ol>
<li><p>地址结构</p>
<p>标准的 A 类、B 类与 C 类 IP <strong>地址都是网络号与主机号两级层次结构</strong>。<strong>IP 地址:: = {&lt;网络号&gt;，&lt;主机号&gt;}</strong></p>
<p>子网采用网络号-子网号-主机号的三层 IP 地址结构。<strong>IP 地址:: = {&lt;网络号&gt;，&lt;子网号&gt;，&lt;主机号&gt;}</strong></p>
<p>从主机号借用若干个位作为子网号 subnet-id，而主机号 host-id 也就相应减少了若干个位</p>
</li>
<li><p>概念</p>
<ul>
<li>子网掩码主要是用来区分 IP 地址中的网络号（网络号+子网号）和主机</li>
<li>子网掩码的结构与形式跟 IP 地址一样，也由 32 位的二进制组成，用点分十进制法表示</li>
<li>子网掩码与 IP 地址的对应关系是，IP 地址中网络号所在的位对应的子网掩码中的相应为 1，IP 地址中主机号所在的位对应的子网掩码中的相应位为 0</li>
<li><strong>注意：IP 地址中网络号和主机号是由子网掩码来确定的，子网掩码二进制表示中全为 1 则对应 IP 地址位段的是网络号，全为 0 则对应 IP 地址位段的是主机号</strong></li>
</ul>
<p><img src="https://bluexiaowei.github.io/NCRE3/static/images/03-02.png" alt="网络地址子网掩码组成图"></p>
<p>子网内第一个可用的 IP 地址：子网号（网络地址）后的第一个地址。 子网内最后一个可用的 IP 地址：直接广播地址前一个地址</p>
</li>
<li><p>子网划分</p>
<p>（1）判断客户需求的网络数与主机数</p>
<p>（2）配置满足需求的基本网络地址结构</p>
<p>（3）配置地址掩码</p>
<p>（4）配置网络地址</p>
<p>（5）配置网络广播地址</p>
<p>（6）配置网络的主机地址</p>
<p>规划子网地址的基本步骤</p>
<ul>
<li>确定要划分的<strong>子网数</strong></li>
<li>求出子网数目对应二进制的位数 N 以及主机数目对应二进制的位数 M</li>
<li>在该 IP 地址的原子网掩码的基础上，将其主机地址部分的前 N 位置取 1 和后 M 位置取0，即得出该 IP 地址划分子网后的子网掩码</li>
</ul>
<p>规划子网地址的基本思想</p>
<ul>
<li>熟记 2 的幂：1，2，3，8，16，64，128，256</li>
<li>用过划分子网可以将一个网络划分若干个小网络以满足不同部门的需要，而从外部来看仍然像一个网络一样</li>
<li>划分子网即优化网络性能又提高了网络管理的效率</li>
</ul>
<p>划分子网的基本方法</p>
<ul>
<li>你选择的子网掩码将会产生多少个子网？2^N-2（N 代表网络位借用主机的位数）</li>
<li>每个子网能有多少主机？2^M-2（M 代表主机位）</li>
<li>每个子网的网络地址：主机位全为 0</li>
<li>每个子网的广播地址：主机位全为 1</li>
</ul>
</li>
</ol>
<h3 id="可变长度子网掩码（VLSM）"><a href="#可变长度子网掩码（VLSM）" class="headerlink" title="可变长度子网掩码（VLSM）"></a>可变长度子网掩码（VLSM）</h3><p>VLSM是在标准的掩码上面再划分的子网的网络号码，无类路由选择网络可以使用VLSM，而有类路由选择网络中不能使用VLSM</p>
<p>可变长度子网掩码（VLSM)地址规划方法</p>
<h2 id="无类域间路由技术（CIDR）"><a href="#无类域间路由技术（CIDR）" class="headerlink" title="无类域间路由技术（CIDR）"></a>无类域间路由技术（CIDR）</h2><p>无类域间路由的设计思想是：不按标准的地址分类规则分配剩余的 IP 地址，而是以可变大小的块方法分配</p>
<ul>
<li>消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，可以更有效的分配 IPv4 地址空间。 IP 地址:: = {&lt;网络前缀&gt;, &lt;主机号&gt;}</li>
<li>使用 <strong>各种长度的“网络前缀”来代替分类地址中的网络号和子网号</strong></li>
<li><strong>使用“斜线记法”，又称 CIDR 记法，及在 IP 地址后面加上一个斜线“/”</strong>，然后写上网络前缀所占的位数（对应三级编址中子网掩码 1 的个数）</li>
<li>CIDR 把 <strong>网络前缀相同的连续的 IP 地址组成一个 CIDR 地址块</strong></li>
<li><strong>全 0 和全 1 的主机号地址一般不适用</strong></li>
</ul>
<p>CIDR地址规划方法</p>
<p>无类域间路由CIDR接收通常用在将多个C类IP地址归并到单一的网络中，并且在路由表中使用一项来表示这些C类IP地址</p>
<p><strong>CIDR技术的主要应用：</strong></p>
<p>1.构建超网           </p>
<p>2.路由聚合</p>
<h2 id="NAT工作原理"><a href="#NAT工作原理" class="headerlink" title="NAT工作原理"></a>NAT工作原理</h2><p>NAT（网络地址转换）技术是解决 IP 地址短缺问题，可以 <strong>实现将内部网络专用的 IP 地址可以转换为用于访问外网的全局 IP 地址</strong></p>
<p><img src="https://bluexiaowei.github.io/NCRE3/static/images/03-03.png" alt="网络地址类别"></p>
<h4 id="NAT-的工作原理"><a href="#NAT-的工作原理" class="headerlink" title="NAT 的工作原理"></a>NAT 的工作原理</h4><img src="https://bluexiaowei.github.io/NCRE3/static/images/03-04.png" alt="NAT的工作原理" style="zoom:150%;">

<h4 id="NAT技术类型"><a href="#NAT技术类型" class="headerlink" title="NAT技术类型"></a>NAT技术类型</h4><p>①静态NAT （一对一）</p>
<p>②动态地址NAT  （一对多）</p>
<p>③网络地址端口转换NAPT （一对多，端口区分）</p>
<h2 id="IPv6地址的特点"><a href="#IPv6地址的特点" class="headerlink" title="IPv6地址的特点"></a>IPv6地址的特点</h2><h4 id="IPv6-的表示方法"><a href="#IPv6-的表示方法" class="headerlink" title="IPv6 的表示方法"></a>IPv6 的表示方法</h4><ul>
<li>用二进制格式表示 <strong>128位</strong> 的一个 IPv6 地址</li>
<li>将这个 128 位的地址按 每16位为一个段位，划分为 8 个段位</li>
<li>将每个段位转换成十六进制数，并用 <strong>冒号（:）</strong> 隔开。<code>68E6:8C64:FFFF:FFFF:0:1180:960A:FFFF</code></li>
<li>若某个 IPv6 地址中出现多个连续的二进制数 0，可以通过压缩某个段位中的 <strong>前导 0</strong> 来简化 IPv6 地址的表示。 <code>002F</code> =&gt; <code>2F</code></li>
<li>如果某个 IPv6 地址中包含了一长串 0，在以冒号十六进制表示法表示时，<strong>可以将连续的段位值都为 0 的地方简写为 <code>::</code>，称为双冒号表示法。</strong> <code>FF05:0:0:0:0:0:0:0:B3</code> =&gt; <code>FF05::B3</code></li>
<li><strong>双冒号在一个地址中只能出现一次</strong></li>
</ul>
<h4 id="IPv6的分类"><a href="#IPv6的分类" class="headerlink" title="IPv6的分类"></a>IPv6的分类</h4><p>IPv6的地址分为：单播地址、组播地址、多播地址与特殊地址等基本的四类地址，同时它还加入了对自动配置的支持 。</p>
]]></content>
      <categories>
        <category>NCRE</category>
      </categories>
      <tags>
        <tag>网络技术</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络信息服务系统的安装与配置</title>
    <url>/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/%E7%AC%AC%E4%B9%9D%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="DNS域名系统"><a href="#DNS域名系统" class="headerlink" title="DNS域名系统"></a>DNS域名系统</h2><p>DNS是Domain Name System的缩写，中文的含义是<strong>域名系统</strong>。将人们易于记忆的域名与人们不容易记忆IP地址进行转换，执行此项功能的主机被称为DNS Server</p>
<span id="more"></span>



<p>DNS服务器的分类</p>
<ul>
<li>根服务器：在因特网上共有13 个根域名服务器（标号为a~m）</li>
<li>顶级服务器：负责顶级域名（如com、org、net、edu和gov）和所有国家的顶级域名（如cn）</li>
<li>权威服务器：在Internet上具有公共访问主机（如WWW服务器和FTP服务器）的每个组织机构必须提供公共可访问的DNS记录</li>
</ul>
<p>DNS系统工作原理</p>
<ul>
<li>当DNS客户机提出查询请求时，首先查询本地缓存中查找</li>
<li>如果没有符合条件的记录，则产生一个查询请求发给本地DNS服务器</li>
<li>本地DNS服务器,当本地DNS服务器接到查询后，首先在该服务器管理的区域的资源记录中查找<ul>
<li>如果找到该记录，则将解析结果返回DNS客户机</li>
<li>如果没有满足查询请求的记录，服务器在本地的缓存中查找</li>
<li>如果找到相应记录，则结果过程结束，否则按系统设置将查询请求发送到其他DNS服务器查询</li>
</ul>
</li>
<li>客户机如果在规定的时间内未收到查询响应，会尝试其他的DNS服务器或再次查询</li>
</ul>
<p>DNS服务器配置的主要参数</p>
<ol>
<li><p><strong>正向查找区域</strong></p>
<p>域名-&gt;IP地址；（A）资源记录</p>
</li>
<li><p>反向查找区域</p>
<p>IP地址-&gt;域名；添加（A）资源记录时，使用“添加PTR记录”自动添加到反向查找区域</p>
</li>
<li><p>地址资源记录</p>
<p>一组结构化的记录，包括（A）、MX（邮件交换记录）、CNAME（别名）</p>
</li>
<li><p><strong>转发器</strong></p>
</li>
</ol>
<p>　　本地DNS服务器用于将外部DNS名称的DNS查询转发给该DNS服务器，用于<strong>外部域名</strong>的DNS查询</p>
<p>主要考点</p>
<ul>
<li><strong>DNS服务器本机的IP必须静态配置</strong></li>
<li>主机资源记录的生存时间（TTL）指记录被客户端查询到，存放在<strong>缓存中</strong>的持续时间，默认值是<strong>3600</strong>秒。</li>
<li>DNS服务器中的根DNS服务器<strong>不需</strong>管理员手工配置</li>
<li>通过DNS服务器<strong>监视</strong>对话框可以对DNS服务器进行<strong>简单测试</strong>与<strong>递归查询测试</strong></li>
<li>使用<strong>nslookup</strong>命令可以测试正向和反向查找区域</li>
<li>清空DNS缓存（DNS cache）的是<strong>ipconfig/flushdns</strong> </li>
<li>缺省情况下Windows 2003系统<strong>没有安装</strong>DNS服务</li>
</ul>
<h2 id="DHCP服务"><a href="#DHCP服务" class="headerlink" title="DHCP服务"></a>DHCP服务</h2><p>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）分为两个部份：即服务器端和客户端，其中所有的IP网络设定数据都由DHCP服务器集中管理，并负责处理客户端的DHCP要求；而客户端则会使用从服务器分配下来的IP环境数据（如DNS、gateway的设置等）</p>
<p>DHCP的工作原理</p>
<ol>
<li>DHCP客户机广播“DHCP发现”消息，试图找到网络中的　　DHCP 服务器获得一个IP地址。该封包的来源地址为0.0.0.0，而目的地址则为 255.255.255.255</li>
<li>当 DHCP 服务器接收到“DHCP发现”消息后，就向网络中广播“DHCP供给”消息，其中包括提供DHCP客户机的地址和相关的配置信息</li>
<li>DHCP客户机收到“DHCP供给”信息，如果接受DHCP服务器所提供的相关参数，就通过广播”DHCP请求”消息向DHCP服务器请求提供IP地址</li>
<li>DHCP服务器广播“DHCP确认”消息，将IP地址分配给DHCP客户端</li>
</ol>
<p>DHCP服务器配置的术语、主要参数</p>
<ul>
<li>作用域<ul>
<li>作用域是一个网络中的所有可分配的 IP 地址的连续范围</li>
<li>作用域主要用来定义网络中单一的物理子网的 IP 地址范围。</li>
</ul>
</li>
<li>排除范围<ul>
<li>排除范围是不用于分配的 IP 地址序列</li>
<li>用于保证在这个序列中的 IP 地址不会被 DHCP 服务器分配给客户机。　</li>
</ul>
</li>
<li>地址池<ul>
<li>在用户定义了 DHCP 范围及排除范围后，剩余的地址形成了一个地址池</li>
<li>地址池中的地址可以动态的分配给网络中的客户机使用</li>
</ul>
</li>
<li>租约<ul>
<li>租约是 DHCP 服务器指定的时间长度，在这个时间范围内客户机可以使用所获得的 IP 地址</li>
<li>当客户机获得 IP 地址时租约被激活</li>
<li>在租约到期前客户机常常需要向服务器更新 IP 地址的租约</li>
</ul>
</li>
<li>保留地址<ul>
<li>用户可以利用保留地址创建一个永久的地址租约</li>
<li>保留地址保证子网中的指定硬件设备始终使用同一个 IP 地址</li>
<li><strong>可以使用作用域的任何地址，包括排除范围内的地址</strong>。</li>
</ul>
</li>
<li>选项类型<ul>
<li>选项类型是 DHCP 服务器给 DHCP 工作站分配服务租约时分配的其它客户配置参数</li>
<li>经常使用的选项包括：默认网关的 IP 地址（路由器）, WINS 服务器, 及 DNS 服务器的IP地址。</li>
</ul>
</li>
</ul>
<p>主要考点</p>
<ul>
<li>DHCP工作原理（四次交互）</li>
<li>添加排除时必须输入起始IP地址和结束IP地址（不需MAC地址）</li>
<li>新建作用域后必须激活才可为客户机分配地址</li>
<li>地址租约期限决定客户机使用所获得IP地址的时间长短，最小可调整单位是分钟，客户端自动续约</li>
<li>保留是指DHCP服务器指派的永久地址租约，添加保留地址时需获得客户机的MAC地址信息。可以使用排除地址范围。</li>
<li>DHCP中继。</li>
<li>常用指令<ul>
<li>ipconfig /all（查看到该客户机的配置信息和地址租约） </li>
<li>ipconfig/release（释放已获得的IP地址租约）</li>
<li>ipconfig /renew命令（重新从DHCP服务器获得新的IP地址租约）</li>
</ul>
</li>
</ul>
<h2 id="WWW服务"><a href="#WWW服务" class="headerlink" title="WWW服务"></a>WWW服务</h2><p>浏览器与服务器之间传送信息的的协议时<strong>HTTP</strong>，即超文本传输协议，使用<strong>TCP协议</strong>，默认端口号为<strong>80</strong>。</p>
<p>主要考点</p>
<ul>
<li>建立Web 站点时，必须为该站点指定一个主目录，也可以是虚拟子目录 。</li>
<li>Web站点必须设置网站的默认文档后才能自动打开“default.html”或”index.html”等页面。</li>
<li>在网站的选项中的可设置网站的标识、连接限制、以及启用日　志记录和日志记录格式。　　Web站点可设置静态的IP地址或全选“全部未分配”</li>
<li>目录安全选项可选择配置身份验证和访问控制、IP地址和域名限制、安全通信</li>
<li>使用IIS建立Web站点设置选项时性能选项，可设置影响带宽使用的属性及客户端Web连接的数量。（<strong>无时间</strong>）</li>
<li>网站性能选项中，带宽限制选项限制该网站的可使用带宽</li>
<li>访问WEB站点的方法。 </li>
<li>在IIS6.0中用虚拟服务器构建多个网站的方法：可以为服务器上的每个站点配置唯一的<strong>标识</strong>或虚拟目录。标识有包括：<strong>主机头名称、IP地址、非标准TCP端口号</strong>。</li>
</ul>
<h2 id="FTP服务"><a href="#FTP服务" class="headerlink" title="FTP服务"></a>FTP服务</h2><ul>
<li>文件传送协议（FTP）允许用户从服务器上获取文件副本并下载到本地计算机上，或将本地计算机上的一个文件上传到服务器</li>
<li>不需要用户登录就能自由下载文件的FTP服务成为匿名FTP服务。</li>
<li>FTP的传输层使用TCP协议，服务器端提供的端口号<strong>21用于数据连接</strong>，<strong>端口号20用于数据传送</strong></li>
</ul>
<p>FTP服务器配置的主要参数</p>
<ul>
<li>域：FTP可建立多个虚拟服务器，每个虚拟服务器成为域，<strong>一个域是由IP地址和端口号唯一识别</strong></li>
<li>匿名用户：对名为<strong>anonymous</strong>的用户自动识别为<strong>匿名用户</strong>，<strong>不设置密码</strong>。</li>
<li>命名用户：创建时设置密码，此类用户一般提供更多的访问权限。</li>
<li>组：用户组就是将多个命名用户组织在一起，它们拥有相同的权限，这些权限只需在组的选项中设置即可。</li>
</ul>
<p>FTP服务器的配置</p>
<ol>
<li><p>修改管理员密码 （默认管理员:LocalAdministrator），在初次运行的情况下，没有设置管理员的密码</p>
</li>
<li><p>新建域（11上、13上考题）</p>
<ul>
<li>在Serv-U的管理界面左侧的目录树中选中“域”图标，在菜单栏中选中“域”菜单选项，在显示的下拉菜单中选中“新建域（N）” 。这时界面上将弹出“添加新建域-第一步”对话框</li>
<li>在“IP地址”框中输入FTP服务器的IP地址，这里为“192.168.0.111”，点击【下一步（N）】,进入“添加新建域-第二步” 。<strong>IP地址可为空，意为服务器的所有IP地址</strong>。当服务器有多个IP或动态IP时，比较方便</li>
<li>在“域名”框中输入该服务器的域名，即它的描述名称，这里为“ftp.myftp.com”，点击【下一步（N）】，进入“添加新建域-第三步”。<strong>可以使用域名</strong></li>
<li>在“域端口号”中输入该服务器的端口号。默认的端口号为“21”，也<strong>可以设置自己想要的端口号</strong>。当然存在一些情况这个21端口，不能使用，这时也该使用别的端口，这里设置该服务器的端口号为“8021”，点击【下一步（N）】,进入“添加新建域-第四步”</li>
<li>在“域类型”对话框中选择域存储的地方。<strong>“.INI文件存储”一般是应用于较小的域，对于用户数大于500的较大的域，应该选择注册表以提供更高的性能</strong>。点击【下一步（N）】，完成FTP服务器的创建</li>
</ul>
</li>
<li><p>用户的添加与管理（09上、09下、11下）</p>
<ul>
<li><p>在Serv-U的管理界面的左侧目录树中选择【域】→【ftp.myftp.com】→【用户】，在菜单栏选中“用户（U）”选项，在弹出的下拉菜单中选中“新建用户（N）”，将弹出“添加新建用户-第一步”对话框</p>
<blockquote>
<p>注意：在服务器端创建</p>
</blockquote>
</li>
<li><p>在“用户名称”框中输入所要添加的用户的用户名，这里设置为“user”，<strong>如果是匿名用户，则输入用户名“anonymous”</strong>，点击【下一步（N）】，进入“添加新用户-第二步”对话框。<strong>注意：要手工添加</strong></p>
</li>
<li><p>在“密码”框中输入该用户名访问FTP时所使用的密码，这里为“123456”，当输入的用户名为“anonymous”时，系统自动判定添加的为匿名用户，将不进入这一步。点击【下一步（N）】，进入“添加新用户-第三步”对话框</p>
</li>
<li><p>在“主目录”输该用户访访问FTP时的主目录，或者点击框右面的图标，进行主目录的选择，这里为“D:\共享文件夹”，点击【下一步（N）】，进入“添加新用户-第四步”对话框</p>
</li>
<li><p>选择“是否锁定用户主目录?”后，点击【完成】，完成了添加新用户的操作。  </p>
</li>
</ul>
</li>
</ol>
<p>常用选项</p>
<ul>
<li>服务器选项：在Serv-U的管理界面的左侧目录树中选择【&lt;&lt;本地服务器&gt;&gt;】→【设置】即可打开服务器设置选项对话框。<ul>
<li>最大上传速度，最大下载速度：<strong>指整个FTP服务器占用的带宽</strong></li>
<li>最大用户数量：<strong>同时在线的最大用户数</strong>。</li>
<li>检查匿名密码</li>
<li>删除部分已上传文件</li>
<li>禁用反超时调度</li>
<li>拦截“FTP_bounce”攻击和FXP。</li>
<li><strong>只允许在FTP客户端和服务器间进行文件传输，而不允许在两个FTP服务器间进行文件传输</strong></li>
</ul>
</li>
<li>域设置选项：在Serv-U的管理界面的左侧目录树中选择，【&lt;&lt;本地服务器&gt;&gt;】→【域】→【ftp.myftp.com】→【设置】，则显示“域设置”界面。<ul>
<li>域常规选项</li>
<li>域虚拟路径选项</li>
<li>IP访问选项</li>
<li>域消息选项</li>
<li>域记录选项</li>
<li>域上传/下载率选项</li>
<li>域高级选项</li>
</ul>
</li>
<li>用户选项：在Serv-U的管理界面的左侧目录树中选择【&lt;&lt;本地服务器&gt;&gt;】→【域】→　　【ftp.myftp.com】→【用户】,选中一个用户，如“user”即可打开用户设置对话框。<ul>
<li>用户帐号选项</li>
<li>用户常规选项</li>
<li>用户目录访问选项</li>
<li><strong>用户IP访问选项</strong></li>
<li>用户上传/下载率选项</li>
<li><strong>用户配额选项</strong></li>
<li><strong>可以限制用户上传信息占用的存储空间</strong></li>
</ul>
</li>
</ul>
<p>使用浏览器测试FTP服务器</p>
<p>在浏览器的地址栏中输入服务器的IP地址，如“<strong>ftp:192.168.0.111</strong>”，如果该服务器的端口号不是21，则还需要加上端口号来访问该FTP服务器，格式为：“<strong>ftp:192.168.0.111:8021</strong>”。连接后，可以选择使用匿名方式登录FTP服务器，也可以通过输入正确的用户名和密码来登录对话框。 </p>
<h2 id="E-mail服务"><a href="#E-mail服务" class="headerlink" title="E-mail服务"></a>E-mail服务</h2><p>完整的电子邮件地址（例如，<a href="mailto:&#x75;&#x73;&#x65;&#x72;&#x31;&#x40;&#109;&#x61;&#105;&#108;&#46;&#x61;&#x62;&#99;&#46;&#99;&#111;&#109;">&#x75;&#x73;&#x65;&#x72;&#x31;&#x40;&#109;&#x61;&#105;&#108;&#46;&#x61;&#x62;&#99;&#46;&#99;&#111;&#109;</a>）由两部分构成，第一部分为信箱名（user1），第二部分为邮件服务器的域名（mail.abc.com）中间用@隔开。</p>
<p><strong>发送方的邮件服务器在发送邮件时根据第二部分来确定要连接的接收方邮件服务器；接收邮件服务器软件则使用信箱名来选择对应的邮箱将收到的邮件存储起来</strong>。</p>
<p>电子邮件系统使用的协议主要有：<strong>SMTP</strong>，<strong>用于发送电子邮件</strong>，默认的<strong>TCP端口为25</strong>；<strong>POP3</strong>，默认的<strong>TCP端口为110</strong>；<strong>IMAP4</strong>，默认的<strong>TCP端口为143</strong>。用户<strong>访问</strong>并<strong>读取</strong>邮件服务器上的邮件使用POP3或IMAP4协议。</p>
]]></content>
      <categories>
        <category>NCRE</category>
      </categories>
      <tags>
        <tag>网络技术</tag>
      </tags>
  </entry>
  <entry>
    <title>中小型网络系统总体规划与设计</title>
    <url>/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="网络总体设计基本方法"><a href="#网络总体设计基本方法" class="headerlink" title="网络总体设计基本方法"></a>网络总体设计基本方法</h2><ul>
<li><p>网络结构与拓扑构型设计方法</p>
<p>是否需要分成3层（核心层，汇聚层，接入层）组建的经验数据是：如果结点数为<strong>250 ~ 5000个</strong>，<strong>一般需要按3层结构来设计</strong>；如果结点为<strong>100~500个</strong>，<strong>可以不必设计接入层网络</strong>，结点直接通过汇聚层的路由器或交换机接入；如果结点数为<strong>5~250个</strong>，也<strong>可以不设计接入层网络与汇聚层网络</strong></p>
</li>
</ul>
<span id="more"></span>

<ul>
<li><p>核心层网络设计</p>
<ul>
<li>整个网络系统的主干部分是核心层，它是设计与建设的重点。目前应用于核心层网络的技术标准主要是 <strong>GE/10GE</strong>，核心设备是<strong>高性能交换路由器</strong>，连接核心路由器的是<strong>具有冗余链路的光纤</strong>。整个网络流量的 <strong>40%~60%</strong> 都需要由核心层网络承载</li>
<li>直接接入核心路由器：采取链路冗余的办法直接连接两台核心路由器，<strong>其特点是直接利用了核心路由器的宽带，但是占用的核心路由器端口较多，而高端路由器的端口价格很高，所以设备成本会上升</strong></li>
<li>通过专用交换机接入核心路由器：在两台核心路由器之上增加一台连接服务器集群的交换机，同时采用 <strong>链路冗余</strong> 的办法，间接的连接到两台核心路由器，<strong>其优点是可以分担核心路由器的带宽，缺点是会形成带宽瓶颈，存在单点故障的潜在危险</strong></li>
</ul>
</li>
<li><p>汇聚层网络与接入层网络结构设计</p>
<p>汇聚层网络可以将位于不同位置的子网连接到核心层网络，实现路由汇聚的功能。对网络系统进行分层设计可便于规划与分配带宽，有利于均衡负荷，提高网络效率。实际情况验证：<strong>层次之间的上联带宽与下一级带宽之间比一般控制在 1:20</strong></p>
</li>
</ul>
<h2 id="路由器关键设备选型"><a href="#路由器关键设备选型" class="headerlink" title="路由器关键设备选型"></a>路由器关键设备选型</h2><blockquote>
<p>网络关键设备选型的基本原则：厂商与产品系列的选择、网络的可扩展性考虑、网络技术先进性考虑。</p>
</blockquote>
<h4 id="路由器的分类"><a href="#路由器的分类" class="headerlink" title="路由器的分类"></a>路由器的分类</h4><p>一般按路由器的性能进行分类，即可分为</p>
<ul>
<li>高端路由器（高端核心路由器）</li>
<li>中端路由器（或企业级路由器）</li>
<li>低端路由器</li>
</ul>
<p><strong>路由器性能主要指路由器背板交换能力，背板交换能力大于 40Gbit/s 的称作高端路由器；背板交换能力低于 40Gbit/s 的称为中低端路由器</strong></p>
<h4 id="路由器关键技术指标"><a href="#路由器关键技术指标" class="headerlink" title="路由器关键技术指标"></a>路由器关键技术指标</h4><ul>
<li><p>吞吐量</p>
<p><strong>路由器的吞吐量是指它的包转发能力</strong>，涉及两个方面的内容：端口吞吐量与整机吞吐量</p>
<ul>
<li>端口吞吐量是值路由器的某个端口的包转发能力</li>
<li>整机吞吐量是指路由器整机的包转发能力</li>
<li><strong>路由器的吞吐量与路由器的端口数量和速率、包类型、包长度关系密切</strong></li>
</ul>
</li>
<li><p>背板能力</p>
<p>背板是路由器输入端与输出端之间的物理通道，<strong>它决定了路由器的吞吐量</strong></p>
<ul>
<li><strong>高性能路由器一般采用交换式结构</strong></li>
<li><strong>传统的路由器采用的是共享背板的结构</strong></li>
</ul>
</li>
<li><p>延时与延时抖动</p>
<ul>
<li>从数据包的第一个字节进入路由，到该帧的最后一个字节离开路由器期间所经历的时间就是所谓的延时。延时与<strong>包长度</strong>、<strong>链路传输速率</strong>有关。高速路由器一般要求为1518 B的IP包，延时要小于1 ms</li>
<li>延时的变化量就是延时抖动。<strong>由于数据包对延时抖动要求不高，所以一般不把延时抖动作为衡量高速路由器的主要指标，但是语音、视频业务对延时抖动要求比较高</strong>。</li>
</ul>
</li>
<li><p>丢包率</p>
<ul>
<li>丢包率是指在<strong>持续的、稳定的</strong>负荷情况下，由于包转发能力的限制而造成的丢失的概率</li>
<li><strong>丢包率常被用做路由器超负荷工作是的性能衡量指标</strong></li>
</ul>
</li>
<li><p>突发处理能力</p>
<p>常以 <strong>最小帧间隔发送数据包而不引起丢失的最大发送速率来衡量突发处理能力</strong>。</p>
</li>
<li><p>服务质量</p>
<p>路由器的服务质量主要表现在<strong>队列管理机制</strong>、<strong>端口硬件队列管理</strong>和<strong>支持 QoS 协议</strong>上。<strong>队列管理机制是指路由器的队列调度算法与拥塞管理机制</strong>。</p>
</li>
<li><p>路由表容量</p>
<ul>
<li><strong>路由表是路由器用来决定包转发路径的主要依据</strong>。建立和维护与当前网络链路状态与节点状态相适应的路由表是路由器的主要任务之一</li>
</ul>
</li>
<li><p>路由表容量是指路由器可以存储的最多的路由表的数量。</p>
<ul>
<li>BGP协议的路由器一般要存储数万条路由表项。</li>
</ul>
</li>
<li><p>典型的高端路由器的可靠性与可用性指标应该达到以下几点</p>
<ul>
<li>无故障连续工作时间（MTBF）<strong>大于 10 万个小时</strong>，且系统故障恢复时间 <strong>小于 30min</strong>。</li>
<li><strong>系统具有自动保护切换功能，主备用切换时间小于 50ms</strong>。</li>
<li><strong>SDH 与 ATM 接口自动保护切换功能，切换时间小于 50ms</strong>。</li>
<li>路由器系统内部<strong>不存在单故障点</strong>。</li>
<li>主路由器、主存储器、交换矩阵、电流、总线管理器与网络管理接口等主要部件需要由热插拔冗余备份，线卡要求有备份，并提供远程测试诊断能力。</li>
</ul>
</li>
<li><p>网管能力</p>
<p><strong>路由器的网络管理能力表现在网络管理员可以通过网络管理程序和通用的网络管理协议 SNMPv2</strong>，对网络资源进行集中管理与操作。</p>
</li>
</ul>
<h2 id="交换机设备选型"><a href="#交换机设备选型" class="headerlink" title="交换机设备选型"></a>交换机设备选型</h2><p><strong>交换机的分类</strong></p>
<ul>
<li>按所支持的技术类型，可以将交换机分为<ul>
<li>10Mbit/s Ethernet 交换机</li>
<li>Fast Ethernet 交换机</li>
<li>速率达到 1Gbit/s 的 GE 交换机</li>
</ul>
</li>
<li>按内部结构，可以将交换机分为<ul>
<li>模块式交换机</li>
<li>固定端口交换机</li>
</ul>
</li>
<li>按应用规模，可以将交换机分为<ul>
<li>企业级交换机</li>
<li>部门级交换机</li>
<li>工作组交换机</li>
</ul>
</li>
</ul>
<p><strong>交换机的主要技术指标</strong></p>
<ul>
<li><p>背板带宽</p>
</li>
<li><p><strong>全双工端口带宽</strong></p>
<blockquote>
<p><strong>全双工端口带宽：计算方法 = 端口数 x 端口速率 x 2</strong></p>
</blockquote>
</li>
<li><p>交换方式</p>
</li>
<li><p>帧转发速率</p>
</li>
<li><p>延时</p>
</li>
<li><p>模块式或固定端口配置</p>
</li>
<li><p>支持 VLAN 能力等</p>
</li>
</ul>
<h2 id="网络服务器设备选型"><a href="#网络服务器设备选型" class="headerlink" title="网络服务器设备选型"></a>网络服务器设备选型</h2><h4 id="网络服务器的分类"><a href="#网络服务器的分类" class="headerlink" title="网络服务器的分类"></a>网络服务器的分类</h4><ol>
<li><p>按照应用领域不同，可以将网络服务器分为： </p>
<ul>
<li>Internet 通用服务器</li>
<li>数据库服务器</li>
<li>文件服务器</li>
<li>应用服务器</li>
</ul>
</li>
<li><p>按照网络应用规模不同，网络服务器可以分为：</p>
<ul>
<li>基础级服务器：1个CPU</li>
<li>工作组级服务器：1~2个CPU</li>
<li>部门级服务器：2~4个CPU，采用SMP技术</li>
<li><strong>企业级服务器：4~8个CPU，采用SMP技术</strong></li>
</ul>
</li>
<li><p>按照网络服务器主机的硬件体系结构可以分为：</p>
<ul>
<li>基于 CISC 处理器 Inter 机构（IA）的 PC 服务器</li>
<li>基于 RISC 结构处理器的服务器</li>
<li>小型服务器</li>
<li>基于精简指令集（RISC）结构处理器的服务器与相应的 PC 服务器相比，CPU 处理能力提高了 50%-75%。<strong>各种大型、中型计算机和超级服务器都采用 RISC 结构处理器，操作系统采用 UNIX</strong>，所以通常将此类服务器作为 <strong>UNIX 服务器</strong></li>
</ul>
</li>
<li><p>服务器采用的相关技术</p>
<p><strong>热插拔技术</strong>、<strong>集群（Cluster）技术</strong>、高性能存储与智能 I/O 技术、对称多处理（Symmetric Multi-Processing, SMP）技术、应急管理端口（Emergence Management Port, EMP）技术、非一致内存访问（Non-Uniform Memory Access, NUMA）技术、服务器处理与 Intel 服务器控制（Intel Server Control, ISC）技术</p>
<ul>
<li><p>热拔插技术</p>
<p><strong>可以实现用户在不断电的情况下进行故障硬盘、板卡等部件的更换</strong>，所以使得系统应对突发事件能力大大提高。另外，高端应用的磁盘镜像系统提高了磁盘的热插拔功能，大大缩减了系统故障修复时间</p>
<p><strong>注意</strong>：如果系统式两个电源，则热插拔功能可以实现在用户不断电的情况下进行故障电源的更换</p>
</li>
<li><p>集群技术</p>
<p><strong>集群（Cluster）技术大大提高了系统的数据处理能力</strong>。它式向一组独立的计算机提供高速通信线路，并使其组成一个共享数据存储空间的服务器系统。<strong>如果其中某台主机出现故障，该主机所运行的程序将立即转移到其他主机运行，可见集群计算技术可以使服务器的可用性、可靠性与容灾额能力得到大大提高</strong></p>
</li>
<li><p>高性能存储与智能 I/O 技术</p>
<p><strong>存储能力使衡量服务器性能与选型的重要指标之一。评价高性能存储技术的主要指标使磁盘容量和存取 I/O 熟读</strong>。在提高磁盘容量的基础上，通过改善并行读写能力，提高磁盘的存取速度和吞吐量；通过磁盘容错处理来解决系统的可靠性</p>
</li>
<li><p>对称多处理技术</p>
<p>对称多处理（SMP）技术可以实现多 CPU 结构的服务器中的均衡负荷，从而提高系统效率。是否在多 CPU 结构的服务器中采用了对称多处理技术使一个重要指标</p>
</li>
<li><p>非一致内存访问（Non-Uniform Memory Access, NUMA）技术</p>
<p>非一直内存访问（NUMA）技术实在多大 64 个或更多 CPU 的服务器之中，将集群技术与对称多处理技术结合起来应用，以求得较高的性价比</p>
</li>
<li><p>高性能服务器一般利用专用的服务处理器，对服务器系统的运行状况进行监控</p>
</li>
</ul>
</li>
</ol>
<h4 id="网络服务器的性能"><a href="#网络服务器的性能" class="headerlink" title="网络服务器的性能"></a>网络服务器的性能</h4><p>服务器的性能主要表现在</p>
<ul>
<li>磁盘存储能力</li>
<li>运算处理能力</li>
<li>高可用性</li>
<li>可扩展性</li>
<li>可管理性等。</li>
</ul>
<p>**系统高可用性可以用如下公式： 系统可用性 = MTBF / ( MTBF + MTBR )**。</p>
<blockquote>
<p>MTBF 为平均无故障时间； MTBR 为平均修复时间。</p>
</blockquote>
<p><strong>如果系统高可用性达到 99.9%，那么每年的停机时间 &lt;8.8 小时；系统高可用性达到 99.99%，每年的停机时间 &lt;53 分钟；系统高可用性达到 99.999%，每年的停机时间 &lt;5 分钟</strong></p>
]]></content>
      <categories>
        <category>NCRE</category>
      </categories>
      <tags>
        <tag>网络技术</tag>
      </tags>
  </entry>
  <entry>
    <title>局域网技术基础及应用</title>
    <url>/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><ul>
<li><p>交换式局域网</p>
<ul>
<li>交换式局域网的核心是交换机</li>
<li>局域网交换机可以在它的多个端口之间建立多个并发连接</li>
<li>主要采用两种转发方式：<strong>快捷交换方式</strong>与<strong>存储转发交换</strong>方式</li>
</ul>
</li>
<li><p>虚拟局域网</p>
<ul>
<li>虚拟局域网（virtual LAN，VLAN）</li>
<li>建立在交换技术的基础上，是以<strong>软件</strong>的方法将网络中的结点按工作性质与需要划分成若干个“<strong>逻辑工作组</strong>”</li>
<li>每个逻辑工作组就是一个虚拟网络</li>
</ul>
</li>
</ul>
<span id="more"></span>



<p>IEEE于1999年公布了VLAN的IEEE802.1Q标准。</p>
<p>虚拟局域网组网定义方法通常有四种</p>
<ul>
<li>基于端口的虚拟局域网</li>
<li>基于MAC地址的虚拟局域网</li>
<li>基于网络层地址定义的虚拟局域网</li>
<li>基于IP广播组的虚拟局域网。</li>
</ul>
<h2 id="以太网组网的基本方法"><a href="#以太网组网的基本方法" class="headerlink" title="以太网组网的基本方法"></a>以太网组网的基本方法</h2><h3 id="以太网的物理层标准的命名方法"><a href="#以太网的物理层标准的命名方法" class="headerlink" title="以太网的物理层标准的命名方法"></a>以太网的物理层标准的命名方法</h3><p>传统以太网的物理层标准的命名方法是：</p>
<table>
<thead>
<tr>
<th>IEEE802.3 x （Mb/s）</th>
<th>Type-y</th>
<th>Name （局域网名称）</th>
</tr>
</thead>
</table>
<p>其中，x为该Ethernet数据传输的速率，单位是Mb/s；Type为传输的方式，基带或频带；y为网络的最大长度，单位是100m；Name是局域网的名称</p>
<h3 id="10BASE-T标准以太网组网的设计方法"><a href="#10BASE-T标准以太网组网的设计方法" class="headerlink" title="10BASE-T标准以太网组网的设计方法"></a>10BASE-T标准以太网组网的设计方法</h3><p>标准（传统）以太网可以选择10BASE-5、10BASE-2或10BASE-T中的任意一种或几种的组合。目前标准的设计方案都采用10BASE-T标准，使用集线器、非屏蔽双绞线和RJ-45接口</p>
<p>集线器工作在物理层，所有连接在一个集线器上的结点都属于同一个“<strong>冲突域</strong>”。在任何一个时间段中，只能有一个结点可以发送数据帧，而其他结点只能处于接受状态</p>
<h3 id="快速以太网组网的设计方法"><a href="#快速以太网组网的设计方法" class="headerlink" title="快速以太网组网的设计方法"></a>快速以太网组网的设计方法</h3><p>快速以太网协议标准为IEEE802.2u。基本特点如下</p>
<ul>
<li>保持传统以太网帧结构与介质访问控制方法不变</li>
<li>在LLC子层使用IEEE802.3标准，在MAC子层使用CSMA/CD方法</li>
<li>数据传输速率提高到100Mbps</li>
<li>提供10Mbps与100Mbps速率自动协商功能</li>
</ul>
<p>快速以太网介质专用接口MII （了解）</p>
<ul>
<li>MII将MAC子层和物理层分隔开来</li>
<li>MII向上通过与MAC子层得接口提供载波侦听信号与冲突检测（CSMA/CD）信号，向下支持10Mbps与100Mbps速率的接口，以及与集线器交换控制信息的功能。</li>
</ul>
<p>快速以太网的物理层标准</p>
<ul>
<li>100BASE-TX<ul>
<li>使用<strong>5类非屏蔽双绞线或屏蔽双绞线</strong>的快速以太网技术，它使用两对双绞线，<strong>一对用于发送</strong>，<strong>一对用于接收数据</strong></li>
<li>在传输中使用<strong>4B/5B编码</strong>方式。他的最大网段长度为<strong>100m</strong></li>
<li>支持<strong>全双工</strong>的数据传输</li>
</ul>
</li>
<li>100BASE-FX<ul>
<li>使用<strong>2条光纤</strong>，最大长度为<strong>415m</strong>，<strong>一条光纤用于发送</strong>，另一<strong>条光纤用于接收</strong></li>
<li>数据传输采用<strong>4B/5B-NRZI编码</strong>方法</li>
<li>采用<strong>全双工</strong>方式工作</li>
</ul>
</li>
<li>100BASE-T4<ul>
<li>它使用<strong>4对3类非屏蔽双绞线</strong>，<strong>3对用于传送数据</strong>，<strong>1对用于检测冲突信号</strong></li>
<li>在传输中使用<strong>8B/6T编码</strong>方式，它使用与10BASE-T相同的RJ-45连接器，最大网段长度为<strong>100m</strong></li>
<li>采用半<strong>双工方式</strong>工作</li>
</ul>
</li>
</ul>
<p>全双工与半双工工作模式(了解)</p>
<ul>
<li>全双工（Full Duplex Communication）是指在通信的任意时刻，线路上存在A到B和B到A的双向信号传输。在全双工方式下，通信系统的每一段都设置了发送器和接收器，因此，能控制数据同时在两个方向上传送</li>
<li>半双工（Half Duplex Communication）是指在通信过程的任意时刻，信息既可以有A传到B，又能由B传到A，但只能有一个方向上的传输存在</li>
<li>与传统以太网的连接方式不同，全双工工作是一种<strong>点-点</strong>连接方式，支持全双工模式的快速以太网的拓扑构型一定是星形</li>
<li>传统以太网将很多个主机连接在一条共享的同轴电缆上，主机之间需要争用共享的传输介质，因此就出现了CSMA/CD介质访问控制方法。点-点连接方式不存在争用问题，因此<strong>不需要采用CSMA/CD介质访问控制方法</strong>。</li>
</ul>
<p>10Mbps与100Mbps速率自动协商功能</p>
<ol>
<li>自动确定非屏蔽双绞线的远端连接设备使用的是半双工（CSMA/CD）的10Mpbs工作模式，还是全双工的100Mbps工作模式</li>
<li>向其他节点发布远端连接设备的工作模式</li>
<li>与远端连接设备交换工作模式相关参数，协调和确定双方的工作模式</li>
<li>自动协商功能自动选择共有的最高性能的工作模式</li>
</ol>
<p>自动协商过程只能用于使用双绞线的以太网，并且规定自动协商过程需要在<strong>500ms</strong>内完成</p>
<p>按工作性能从高到底，网络协议的优先等级从高到低排列为：</p>
<ul>
<li>100BASE-TX或100BASE-FX全双工模式；</li>
<li>100BASE-T4半双工模式；</li>
<li>100BASE-TX半双工模式；</li>
<li>10BASE-T全双工模式；</li>
<li>10BASE-T半双工模式。</li>
</ul>
<h2 id="综合布线之网络系统设计"><a href="#综合布线之网络系统设计" class="headerlink" title="综合布线之网络系统设计"></a>综合布线之网络系统设计</h2><p>综合布线系统（Premises Distributed System, PDS）是 <strong>建筑物内或建筑物间</strong> 的只用结构化、高灵活性的信息传输通道，其对象是建筑物或建筑物之间的传输网络，旨在使语音和数据通讯设备、交换设备和其他信息管理系统彼此相连，并使这些设备与外部通信网络连接</p>
<h3 id="综合布线系统组合"><a href="#综合布线系统组合" class="headerlink" title="综合布线系统组合"></a>综合布线系统组合</h3><p><img src="https://bluexiaowei.github.io/NCRE3/static/images/05-01.png" alt="综合布线系统组合"></p>
<h3 id="综合布线系统的网络拓扑结构"><a href="#综合布线系统的网络拓扑结构" class="headerlink" title="综合布线系统的网络拓扑结构"></a>综合布线系统的网络拓扑结构</h3><p>综合布线系统的网络头普结构包含何种网络单元，并按经济合理原则和技术性能要求对这些网络单元进行组合和配置</p>
<ul>
<li>组合配置包括 <strong>组合逻辑和配置形式</strong>，<strong>组合逻辑描述网络功能的拓扑结构</strong></li>
<li>配置形式则说明传输路线与交换中心的交换情况，即 <strong>网络单元的邻接关系</strong></li>
<li>在局域网中布线中常用的拓扑结构有 <strong>星行、环行、总线型和网状结构</strong>等，其中星形结构应用最为广泛</li>
</ul>
<h3 id="综合布线系统的主要布线"><a href="#综合布线系统的主要布线" class="headerlink" title="综合布线系统的主要布线"></a>综合布线系统的主要布线</h3><ul>
<li>连接设备：<strong>指综合布线系统中的各种连续设备</strong>。各种适配器（主件的连接器）、成对连接器及接插软线，都属于连接设备，如配线架、光纤耦合器等。如局域网设备、阻抗匹配设备、滤波器或保护器等，都不属于连接设备</li>
<li>传输介质：常用的传输介质有双绞线、光缆 2 大类<ol>
<li>双绞线：分为 <strong>非屏蔽双绞线和屏蔽双绞线</strong>两种<ul>
<li>非屏蔽双绞线电缆（UTP）的线对外 <strong>没有金属屏蔽层，抗电磁干扰能力差</strong>，使用是受外力弯曲和牵拉，<strong>易导致均衡绞距受破坏</strong>，同时该种电缆在传输信息是易向外辐射泄漏，<strong>安全性较差</strong>；但由于 <strong>其体积小、重量轻、弹性好且价格低</strong>，故是 <strong>结构化布线系统中最常用的通信介质</strong></li>
<li>屏蔽双绞线电缆（STP）的线对 <strong>外包有一层金属箔，具有较好的抗干扰性</strong>，但存在 <strong>价格高，体积大，重量大，不宜施工</strong> 等不足，主要用于外界电磁干扰较大或对数据传输安全性要求较高的环境中</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="综合布线之子系统设计"><a href="#综合布线之子系统设计" class="headerlink" title="综合布线之子系统设计"></a>综合布线之子系统设计</h2><h3 id="建筑群子系统设计"><a href="#建筑群子系统设计" class="headerlink" title="建筑群子系统设计"></a>建筑群子系统设计</h3><p>建筑群子系统的通信线路的铺设主要有 <strong>地下管道布线、直埋布线、架空布线和巷道布线</strong> 4 种方式或者是这 4 种方式的任意组合。</p>
<ul>
<li>地下管道布线：通过由入孔和管道组成的地下系统，对网络内的建筑物进行互联，该方式能 <strong>保持建筑物的原貌。采用由耐腐蚀材料的管道，能对电缆提供最好的机械保护，有效减低电缆受损维修风险</strong></li>
<li>直埋布线：除穿过基础墙的线缆外，<strong>电缆其余部分均不采取管道保护</strong>。 该方法可<strong>保持建筑物的外贸</strong>。基础墙的电缆孔需要向外尽量延伸至不需动图的地方，从而避免其他人沿墙动土时破坏线缆</li>
<li>架空布线：在建筑物间悬空，并通过 <strong>电线杆支撑</strong>。电缆可采用自支撑电缆或将户外电缆系在钢丝绳上。该方式安全性、保密性、灵活性较差，且影响美观，故 <strong>不是理想的布线方式</strong>。只有在已有电线杆前提下使用，但布线成本低</li>
<li>巷道布线：利用建筑物间的地下管道（如用于传送集中供暖站热水的热水管）进行电缆敷设。<strong>可充分利用原有安全设施，且造价低</strong>。电缆安装位置应与热水管保持一定距离，以防热水或热气损坏电缆；电缆尽可能安置在巷道内较高位置，以防水淹</li>
</ul>
<h3 id="设备间子系统"><a href="#设备间子系统" class="headerlink" title="设备间子系统"></a>设备间子系统</h3><p>设备间是线路管理的集中点，是配线设备和通信设备的所在地，，是安放众多用户公用通信装置的场所。设备间子系统连接主配线区（电缆进线室、MDF交接箱）、程控交换机（PBX）或局域网交换机等设备。<strong>在设备间子系统，通过垂直干线或水平干线子系统连接道管理子系统</strong></p>
<p>设备间<strong>室温</strong>应保持在<strong>10℃-27 ℃</strong>之间，<strong>相对湿度</strong>应保持在30%-80%,照明满足标准，并有良好的防尘措施</p>
<h3 id="管理子系统"><a href="#管理子系统" class="headerlink" title="管理子系统"></a>管理子系统</h3><p>管理子系统设置在楼层配线间，时水平子系统电缆端接和主干系统电缆端标的场所，设置在漏乘配线间中，由楼宇主配线架、楼层分配线架、转换插座及跳线组成，包括干线间或卫星接线间内的交叉互联设备。<strong>用户可以通过在管理子系统中增加、交换、更改、扩展线缆来改变线路路由</strong></p>
<h3 id="干线子系统"><a href="#干线子系统" class="headerlink" title="干线子系统"></a>干线子系统</h3><p>干线子系统即建筑物<strong>主馈电缆</strong>，包括：干线接线间至各远程通信（卫星）接线间、设备间至网络端口、主设备间和计算机中心之间、设备间至建筑群子系统设施间的连接电缆，这备件的主干线缆</p>
<p>干线子系统主要有 <strong>点对点结合、分支结合</strong> 两种。这两种连接方式根据建筑物结构特点以及经济性等情况可单独采用也可以混合使用</p>
<h3 id="水平子系统设计"><a href="#水平子系统设计" class="headerlink" title="水平子系统设计"></a>水平子系统设计</h3><p>水平子系统时综合布线系统的分支部分，时综合布线工程中工程量最大、范围最广、最难施工的一个子系统，<strong>一般电缆长度不超过 90m</strong>。综合布线系统多采用 5 类和 6 类 4对 <strong>非屏蔽双绞线</strong>。<strong>对于用户有高速率终端要求的场合，可采用光纤直接铺设到桌面的方案</strong></p>
<h3 id="工作区子系统设计"><a href="#工作区子系统设计" class="headerlink" title="工作区子系统设计"></a>工作区子系统设计</h3><p>工作区子系统指终端<strong>设备出线到信息插座</strong>的整个区域。可支持常见的终端设备电话机、计算机、数据终端、传感器以及监视器等</p>
<ol>
<li>信息插座类型和数量的确定：信息插座有<strong>嵌入式安装插座（暗座）</strong>、<strong>多介质信息插座（光纤和铜缆）</strong>和表面安装插座等类型可提供选择。其中嵌入式安装插座用于连接双绞线，<strong>多介质信息插座可用于连接铜缆和光纤，用以满足用户“光纤到桌面”的需求</strong></li>
<li>适配器的选用：<ul>
<li><strong>当设备连接器采用不同于信息插座的连接器</strong>时，可以选择专用电缆或适配器</li>
<li><strong>在单一信息插座上进行两项服务时</strong>，宜采用一线两用器或“Y”形适配器</li>
<li><strong>连接使用不同信号的数模转换或数据速率转换装置</strong>时，宜采用适配器</li>
<li>水平子系统中 <strong>选用的介质类别（电缆）与设备所需的介质类别（电缆）</strong>不同时，宜采用适配器</li>
</ul>
</li>
</ol>
<h2 id="局域网互联设备—集线器"><a href="#局域网互联设备—集线器" class="headerlink" title="局域网互联设备—集线器"></a>局域网互联设备—集线器</h2><h3 id="中续器（Repeater）"><a href="#中续器（Repeater）" class="headerlink" title="中续器（Repeater）"></a>中续器（Repeater）</h3><p>中续器是一种最简单的网络互联设备，主要完成<strong>物理层</strong>的功能，负责在两个节点的物理层上按位传递信息，完成信号的复制、调整和放大功能</p>
<p><img src="https://bluexiaowei.github.io/NCRE3/static/images/05-02.png" alt="中续器"></p>
<h3 id="网桥（Bridge）"><a href="#网桥（Bridge）" class="headerlink" title="网桥（Bridge）"></a>网桥（Bridge）</h3><p>网桥是连接两个局域网的设备，<strong>工作在 MAC 子层上</strong>，并且它可以完成具有相同或相似体系结构的网络系统的连接。<strong>网桥是依靠 MAC 地址表确定帧是否需要转发，以及向何处转发</strong></p>
<p>网桥能够互联两个<strong>采用不同数据链路层协议</strong>、<strong>不同传输介质</strong>与不同传输速率的网络</p>
<p>透明网桥和源路由网桥的标准分别由 IEEE 802.1 与 IEEE 802.5 两个分委员定制。<strong>其中透明网桥的标准为 IEeE 802.1d</strong></p>
<p>透明网桥采用生成树算法，来防止出现坏路情况。    根据该算法所制定的协议即称为<strong>生成树协议</strong>(spanning tree protocol, <strong>STP</strong>) 。<strong>生成树协议能够逻辑地阻断网络中存在的冗余链路，以消除路径中的环路，并可以在活动路径出现故障时，重新激活冗余链路来恢复网络的连通，保证网络的正常工作</strong></p>
<h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>交换机是一种基于 MAC 地址识别，能完成封装转发数据包功能的网络设备</p>
<p>二层交换机工作与数据链路层，他建立和维护一个 <strong>表示 MAC 地址与交换机端口对应关系的交换表</strong></p>
<p>三层交换技术就是二层交换技术上加上三层转发技术，是在网络模型中的第三层实现了数据包的高速转发，即可 <strong>实现网络路由功能</strong>， 又可根据不同网络状况做到最优网络性能</p>
<h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><p>集线器的主要功能是对接收到的信号进行再生整形放大，以扩大网络的传输距离，同时把所有节点集中在以它为中心的节点上。<strong>它发送数据时都是没有针对性的，而是采用广播方式发送</strong></p>
<p>工作在 <strong>物理层</strong>，<strong>所有节点通过双绞线连接到一个集线器上</strong>，执行 <strong>CSMA/CD 介质访问控制方法</strong>。当一个节点发送数据时，所有节点都能接受到。<strong>连接到一个集线器的所有节点共享一个冲突域</strong></p>
<p>通过在网络链路中 <strong>串接一个集线器可以监听该链路中的数据包，连接到一个集线器的多个节点不能同时发送数据帧可以同时接受数据帧</strong></p>
]]></content>
      <categories>
        <category>NCRE</category>
      </categories>
      <tags>
        <tag>网络技术</tag>
      </tags>
  </entry>
  <entry>
    <title>无线局域网设备安装与调试</title>
    <url>/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/%E7%AC%AC%E5%85%AB%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="蓝牙技术与标准"><a href="#蓝牙技术与标准" class="headerlink" title="蓝牙技术与标准"></a>蓝牙技术与标准</h2><p><strong>蓝牙技术的基本概念</strong></p>
<ul>
<li>蓝牙技术是一种支持设备短距离通信的无线电技术，它的通信距离一般为<strong>10m</strong>以内</li>
<li>蓝牙技术能在包括移动电话、PDA、无线耳机、笔记本电脑、相关外设等众多设备之间进行无线信息交换</li>
<li>蓝牙技术的标准是<strong>IEEE802.15</strong>，工作在<strong>2.4GHz</strong> 频带，带宽为<strong>1Mb/s</strong></li>
<li>蓝牙技术是由东芝、爱立信、IBM、Intel和诺基亚于1998年5月共同提出的近距离无线数字通信的技术标准</li>
</ul>
<span id="more"></span>

<p><strong>蓝牙系统的主要参数和技术指标</strong></p>
<ol>
<li><p>工作频段：<strong>ISM频段2.402GHz-2.480GHz</strong></p>
</li>
<li><p>双工方式：<strong>TDD</strong> </p>
</li>
<li><p>业务类别：<strong>同时支持电路交换及分组交换业务。</strong></p>
</li>
<li><p>标称数据速率：<strong>1 Mbps</strong> </p>
</li>
<li><p>异步信道速率：<strong>非对称连接 723.2kbps/57.6kbps。对称连接433.9kbps（全双工模式）</strong></p>
</li>
<li><p>同步信道速率：<strong>64kbps</strong> </p>
</li>
<li><p>信道间隔：1 MHz </p>
</li>
<li><p>信道数：79 </p>
</li>
<li><p>发射功率级范围：<strong>0dBm（1 mW），覆盖1-10m，20dBm（100mW），覆盖扩展至100m</strong>。</p>
</li>
<li><p>跳频频点数：79个频点/MHz （2402+k（MHz），k=0,1,2…78）。</p>
</li>
<li><p>跳频速率：1600次/s </p>
</li>
<li><p>工作模式：Active/Sniff/Hold/Pack </p>
</li>
<li><p>数据连接方式：面向连接业务SCO、无连接业务ACL。</p>
</li>
<li><p>纠错方式：1/3FEC，2/3FEC,CRC16,ARQ。</p>
</li>
<li><p>鉴权：反映逻辑算术方式。</p>
</li>
<li><p>密钥：以8bit为单位增减，<strong>最长128bit</strong></p>
</li>
<li><p>安全机制：链路级，认真基于共享链路密钥询问/相应机制，认证和加密密钥生成基于 SAFER+算法</p>
</li>
<li><p>话音编码方式：CVSD或对数PCM</p>
</li>
<li><p>网络拓扑结构：AD hoc、Piconet及Scatternet结构</p>
</li>
</ol>
<h2 id="HiperLan技术与标准"><a href="#HiperLan技术与标准" class="headerlink" title="HiperLan技术与标准"></a>HiperLan技术与标准</h2><p><strong>HiperLan技术的基本概念</strong></p>
<ul>
<li>HiperLan是一种在欧洲应用的无线局域网通信标准的一个子集，有HiperLan/1和HiperLan/2两种标准</li>
<li>HiperLan/1采用<strong>5GHz</strong>射频频率，上行速率可达<strong>20Mb/s</strong>。HiperLan/2同样采用<strong>5GHz</strong>射频频率，上行速率可达<strong>54Mb/s</strong>。 HiperLan/2系统同3G标准兼容</li>
<li>在HiperLan/2的典型网络拓扑结构中，移动终端通过接入点接入固定网。一个AP所覆盖的区域范围在<strong>室内一般为30米</strong>，在<strong>室外一般是150米</strong></li>
</ul>
<p><strong>HiperLan/2的主要技术特点</strong></p>
<ol>
<li><p><strong>高速数据传输 ：采用OFDM调制技术</strong></p>
</li>
<li><p><strong>面向连接</strong> </p>
</li>
</ol>
<h2 id="IEEE802-11标准"><a href="#IEEE802-11标准" class="headerlink" title="IEEE802.11标准"></a>IEEE802.11标准</h2><p><strong>IEEE802.11标准的基本概念</strong></p>
<ul>
<li>IEEE802.11标准定义了两种类型的设备：<strong>无线节点</strong>和<strong>无线接入点</strong><ul>
<li>无线节点通常是在一台接入设备上加上一块无线网络接口卡构成</li>
<li>无线接入点的作用是提供无线和有线网络之间的桥接</li>
</ul>
</li>
<li>802.11定义了使用红外、调频扩频、直接序列扩频技术，传输速率为1或2Mbps的无线局域网标准。<strong>两个扩频技术</strong>，<strong>一个红外规范</strong>。 <strong>FHSS（调频扩频）和DSSS（直序扩频）</strong></li>
<li>无线传输频道定义在<strong>24.G.Hz</strong>的ISM波段内</li>
</ul>
<p><strong>目前使用的标准主要有： IEEE802.11b、IEEE802.11a和IEEE802.11g</strong></p>
<ol>
<li><p><strong>802.11b协议</strong></p>
<p>802.11b协议的无线网络工作在<strong>2.4GHz</strong>频率下，最大传输速率可以达到<strong>11Mb/s</strong>，它可以实现速率在<strong>1Mb/s、2Mb/s、5.5Mb/s以及11Mb/s</strong>之间的自动切换 。</p>
</li>
<li><p><strong>802.11a协议</strong></p>
<p>工作在<strong>5GHz</strong>的频率下，数据传输速率可以达到<strong>54Mb/s</strong>，传输距离在<strong>10 ~100m</strong> 。</p>
</li>
<li><p><strong>802.11g协议</strong></p>
<p>它是在802.11b协议的基础上改进的协议，支持<strong>2.4GHz</strong>工作频率以及DSSS技术 ，它可以实现11Mb/s传输速率，同时<strong>保持着对802.11b的兼容</strong>，又可以实现<strong>54Mb/s</strong>高传输速率 。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>802.11b</strong></th>
<th><strong>802.11a</strong></th>
<th><strong>802.11g</strong></th>
</tr>
</thead>
<tbody><tr>
<td>批准的IEEE标准</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>Wi-Fi联盟认证</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>最大传输速率</td>
<td>11 Mb/s</td>
<td>54Mb/s</td>
<td>54Mb/s</td>
</tr>
<tr>
<td>实际吞吐量</td>
<td>5~7Mb/s</td>
<td>28~31Mb/s</td>
<td>28<del>31Mb/s（全部在802.11g环境）  10</del>12Mb/s（与802.11b客户端混合环境）</td>
</tr>
<tr>
<td>最大容量</td>
<td>33 Mb/s   3信道*11</td>
<td>432 Mb/s   8信道*54</td>
<td>162 Mb/s   3信道*54</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>802.11b</strong></th>
<th><strong>802.11a</strong></th>
<th><strong>802.11g</strong></th>
</tr>
</thead>
<tbody><tr>
<td>与802.11b的后向兼容性</td>
<td>是  在2.4GHz ISM频段上运行，客户端以8.2.11b的速度在802.11b和802.11g Aps上运行</td>
<td>否  在5GHz UNI频段上运行</td>
<td>是  在2.4GHz ISM频段上运行，客户端以8.2.11b的速度在802.11bAps上运行，以8.2.11g的速度在802.11g Aps上运行</td>
</tr>
<tr>
<td>与其他设备之间的干扰</td>
<td>是  如无线电话、蓝牙、微波炉</td>
<td>否</td>
<td>是  如无线电话、蓝牙、微波炉</td>
</tr>
<tr>
<td>室内距离</td>
<td>30m</td>
<td>与802.11b和802.11g  相比，在30m内有更快的速度</td>
<td>与802.11b相比，在30m内有更快的速度</td>
</tr>
</tbody></table>
<p><strong>IEEE802.11b的基本运作模式</strong></p>
<p>802.11b运作模式基本分为两种：<strong>点对点模式</strong>和<strong>基本模式</strong>。</p>
<ul>
<li><strong>点对点模式</strong>是指<strong>无线网卡和无线网卡</strong>之间的通信方式。只要PC插上无线网卡即可与另一具有无线网卡的PC连接，对于小型的无线网络来说，是一种方便的连接方式，<strong>最多可连接256台PC</strong></li>
<li><strong>基本模式</strong>是指无线网络规模扩充或无线和有线网络并存时的通信方式，这是802.11b最常用的方式。此时，插上无线网卡的PC需要由接入点与另一台PC连接。接入点负责频段管理及漫游等指挥工作，<strong>一个接入点最多可连接1024台PC</strong>（无线网卡）。当无线网络节点扩增时，网络存取速度会随着范围扩大和节点的增加而变慢，此时添加接入点可以有效控制和管理频宽与频段。无线网络需要与有线网络互连，或无线网络节点需要连接和存取有线网的资源和服务器时，<strong>接入点可以作为无线网和有线网之间的桥梁</strong></li>
</ul>
<p><strong>802.11b的典型解决方案</strong></p>
<ol>
<li><p>对等解决方案：每台电脑安装一片无线网卡。 </p>
</li>
<li><p>单接入点解决方案：接入点相当于集线器。 </p>
</li>
<li><p>多接入点解决方案：所有无线终端可通过就近接入点接入网络。 </p>
</li>
<li><p>无线中继方案：无线接入器充当有线网络的延伸。 </p>
</li>
<li><p>无线冗余解决方案：多接入点放在同一位置防止设备失效。 </p>
</li>
<li><p>多蜂窝漫游工作模式：与移动电话类似。 （<strong>部署多个接入点，自动切换们服务不中断</strong>）</p>
</li>
</ol>
<h2 id="常用的无线局域网设备"><a href="#常用的无线局域网设备" class="headerlink" title="常用的无线局域网设备"></a>常用的无线局域网设备</h2><ol>
<li><p>无线网卡</p>
<p>无线网卡在无线局域网中的作用相当于有线网卡在有线局域网中的作用。两台计算机只要各自插上无线网卡，就可以实现通信。 </p>
</li>
<li><p>无线接入点</p>
<p>无线接入点也称为<strong>无线AP</strong>，它是在无线局域网环境中，进行数据发送和接收的集中设备，它的作用相当于有线网络中的集线器。通常，一个AP能够连接<strong>30台</strong>左右的无线网络终端或者其他的无线AP</p>
</li>
<li><p>天线天线的功能是使无线信号有较大的信噪比，以提高数据传输的稳定性和可靠性，一般都要将AP连接上天线上。一般分为室内天线和室外天线。 </p>
</li>
<li><p><strong>无线网桥、路由器及网关</strong></p>
<p><strong>无线网桥主要用于连接几个不同的网段</strong>，实现较远距离的无线数据通信。<strong>无线路由器和无线网关</strong>是具有路由功能的AP，一般情况下它<strong>具有NAT功能</strong>，因此可以用它建立一个更小的无线局域网。</p>
</li>
</ol>
<h3 id="无线接入点的安装与调试"><a href="#无线接入点的安装与调试" class="headerlink" title="无线接入点的安装与调试"></a>无线接入点的安装与调试</h3><h4 id="Aironet-1100系列接入点概述"><a href="#Aironet-1100系列接入点概述" class="headerlink" title="Aironet 1100系列接入点概述"></a>Aironet 1100系列接入点概述</h4><p>Cisco公司的Aironet 1100系列接入点是一款<strong>无线局域网收发器</strong>，主要用于独立无线网络的中心点或无线网络和有线网络之间的连接点。它<strong>兼容IEEE 802.11b和IEEE 802.11g</strong>，工作在<strong>2.4GHz</strong>频率段。使用<strong>IOS</strong>操作系统。</p>
<h4 id="将接入点接入网络"><a href="#将接入点接入网络" class="headerlink" title="将接入点接入网络"></a>将接入点接入网络</h4><ol>
<li>安装和配置AP之前，先向网络管理员询问以下信息：</li>
</ol>
<ul>
<li><strong>系统名</strong></li>
<li>无线网络中对<strong>大小写敏感的服务集标识符（SSID）</strong></li>
<li><strong>如果没有连接到DHCP服务器，则需要为接入点指定一个唯一的IP地址。</strong></li>
<li><strong>如果接入点与PC不在同一个子网内，则需要子网掩码和默认网关</strong></li>
<li>简单网络管理协议（SNMP）集合名称以及SNMP文件属性（如果使用SNMP）</li>
</ul>
<ol start="2">
<li>可以用线内供电连接以太网和使用本地电源。</li>
</ol>
<h4 id="配置接入点"><a href="#配置接入点" class="headerlink" title="配置接入点"></a>配置接入点</h4><p>第一次配置无线接入点，一般采用<strong>本地配置方式</strong>，即无需将无线接入点连接到一个有线的网络中。它的<strong>默认IP地址是10.0.0.1</strong>，并成为小型的DHCP服务器。可以为下列设备分配20个<strong>10.0.0.x</strong>范围的IP地址：</p>
<ul>
<li>连接在接入点以太网端口上的PC机。</li>
<li>没有配置SSID或SSID配置为<strong>tsunami</strong>（默认SSID），并且关闭所有安全配置的无线设备。</li>
</ul>
<p>本地连接无线接入点的步骤：</p>
<p>①使用五类以太网电缆连接PC机和无线接入点</p>
<p>②给无线接入点加电</p>
<p>③确认PC获得了10.0.0.x网段的地址</p>
<p>④打开浏览器，在浏览器的地址栏输入<strong>10.0.0.1</strong>，按回车键</p>
<p>⑤按Tab键越过用户名字段，输入<strong>大小写敏感的密码Cisco</strong>，然后确认。 点击“<strong>Express Setup</strong>”<strong>进入快速配置页面</strong>，在各输入框中填入相关的配置信息。</p>
<p>各个配置参数的含义：</p>
<ul>
<li>System name</li>
<li>Configuration server protocol</li>
<li>Ip address</li>
<li>Ip subnet mask</li>
<li>Default gateway</li>
<li>Radio service set ID（SSID）:<strong>大小写区分，SSID是客户端设备用来访问接入点的唯一标识</strong>。</li>
<li>Broadcast SSID in beacon ：<strong>设定允许设备不指定SSID而访问接入点。YES选项是默认设置</strong>，允许设备不指定SSID而访问接入点，NO选项表示设备必须指定SSID访问接入点</li>
</ul>
]]></content>
      <categories>
        <category>NCRE</category>
      </categories>
      <tags>
        <tag>网络技术</tag>
      </tags>
  </entry>
  <entry>
    <title>网络管理技术</title>
    <url>/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="网络管理的基本知识"><a href="#网络管理的基本知识" class="headerlink" title="网络管理的基本知识"></a>网络管理的基本知识</h2><p>网络管理系统一般由管理进程、被管对象、代理进程、管理信息库和网络管理协议五部分组成。</p>
<span id="more"></span>

<ol>
<li>管理进程：也称管理站，是网络管理的主动实体。</li>
<li>被管对象：网络上的软硬件设施。</li>
<li>代理进程：网络管理中的被动实体。</li>
<li>网络管理协议：较流行的有SNMP和CMIP</li>
<li>管理信息库：被管对象概念上的集合。</li>
</ol>
<p>网络管理的功能</p>
<ul>
<li>配置管理</li>
<li>性能管理</li>
<li>记账管理</li>
<li>故障管理</li>
<li>安全管理</li>
</ul>
<h2 id="网络管理模型"><a href="#网络管理模型" class="headerlink" title="网络管理模型"></a>网络管理模型</h2><p>OSI管理模型：OSI管理模型由ISO公布</p>
<p>SNMP管理模型</p>
<p>SNMP由一系列协议组和规范组成，它们提供了一种从网络上的设备中收集网络管理信息的方法</p>
<p>SNMP的体系结构分为<strong>SNMP管理者</strong>、<strong>SNMP代理</strong>和<strong>MIB</strong>，其管理模型是一个管理/代理模型</p>
<p>每一个支持SNMP的网络设备中都包含一个网管代理，网管代理随时记录网络设备的各种信息，网络管理程序再通过SNMP通信协议收集网管代理所记录的信息</p>
<ul>
<li><p>SNMP的管理站和代理</p>
<p>SNMP采用一种分布式结构。一个管理站可以管理控制着多个代理；反之，一个代理也可以被过个管理站所管理、控制。为此，SNMP采用了“团体”这个概念来实现一些简单的安全控制</p>
</li>
<li><p>管理信息库 MIB-2</p>
<p>管理信息库MIB也称为MIB-2，它指明了网络元素所维持的变量。MIB给出了一个网络中所有可能的被管理对象的集合的数据结构。</p>
<p><strong>Cisco的管理对象标识符（OID）</strong>都是由<strong>1.3.6.1.4.1.9</strong>开头的</p>
<p>MIB的应用类型中的<strong>计量器</strong>类型与计数器很类似，不同之处在于它的值<strong>可以增加也可以减少</strong></p>
</li>
<li><p>SNMP支持的操作</p>
<ul>
<li><strong>get</strong>：用于管理站向代理查询被管理设备上的MIB库数据</li>
<li><strong>set</strong>：用于管理站命令代理对被管设备上MIB库中的对象值进行设置</li>
<li><strong>notifications</strong>：用于代理主动向管理站报告被管对象的某些变化。通知又乐意进一步分为自陷（Trap）和通知（Inform）两类</li>
<li>每个操作都有相应的<strong>PDU</strong>格式</li>
</ul>
</li>
<li><p>SNMP的实现</p>
</li>
</ul>
<p>CMIP与SNMP的比较</p>
<ul>
<li><p>SNMP的特点</p>
<ul>
<li>简单，易于在各种网络中实现</li>
<li>广泛支持，机会所有的网络产品都支持SNMP</li>
<li>操作原语简捷</li>
<li>性能高</li>
</ul>
</li>
<li><p>CMIP的特点</p>
<ul>
<li>每个变量不仅传递信息，而且还完成一定的网络管理任务，这样可减少管理者的负担减少网络负载</li>
<li>安全性高，拥有验证、访问控制盒安全日志</li>
</ul>
</li>
<li><p>SNMP和CMIP的不同点</p>
<ul>
<li><strong>SNMP</strong>有广泛的适用性，且在<strong>用于小规模设备时成本低、效率高</strong>，而CMIP更适用于大型网络</li>
<li>SNMP主要基于轮询方式获得信息，CMIP主要采用报告方式</li>
<li>SNMP基于<strong>UDP</strong>,CMIP使用面向连接的传输</li>
<li>CMIP采用面向对象的信息建模方式，SNMP用简单的变量表示管理对象</li>
</ul>
</li>
</ul>
<h2 id="互联网控制报文协议ICMP"><a href="#互联网控制报文协议ICMP" class="headerlink" title="互联网控制报文协议ICMP"></a>互联网控制报文协议ICMP</h2><p>ICMP工作在<strong>网络层</strong>，是一种管理协议，用于在IP主机、路由器之间<strong>传递控制消息和差错报告</strong></p>
<p><strong>ICMP消息被封装在IP数据包内</strong>，通过IP包传送的ICMP信息主要是设计错误操作的报告和会送给源节点的关于IP数据包处理的消息</p>
<p><strong>ICMP消息类型</strong></p>
<table>
<thead>
<tr>
<th>类型号</th>
<th>类型描述</th>
<th>类型号</th>
<th>类型描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td><strong>回送应答</strong></td>
<td>12</td>
<td>参数错误</td>
</tr>
<tr>
<td>3</td>
<td><strong>目标不可到达</strong></td>
<td>13</td>
<td>时间戳请求</td>
</tr>
<tr>
<td>4</td>
<td>源抑制</td>
<td>14</td>
<td>时间戳应答</td>
</tr>
<tr>
<td>5</td>
<td>重定向</td>
<td>15</td>
<td>信息请求（已作废）</td>
</tr>
<tr>
<td>8</td>
<td><strong>回送请求</strong></td>
<td>16</td>
<td>信息应答（已作废）</td>
</tr>
<tr>
<td>9</td>
<td>路由器请求</td>
<td>17</td>
<td>地址掩码请求</td>
</tr>
<tr>
<td>10</td>
<td>路由器恳求</td>
<td>18</td>
<td>地址掩码应答</td>
</tr>
<tr>
<td>11</td>
<td><strong>超时</strong></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>ICMP的主要功能：</p>
<ul>
<li>通告网络错误：目标不可到达报文</li>
<li>通告网络拥塞：源抑制报文</li>
<li>帮助查找网络故障：回送请求与回送应答报文</li>
<li>通告超时：超时报文</li>
<li>路由重定向：重定向报文</li>
<li>检查IP协议的错误：参数错误报文</li>
<li>测量指定路径上的通信延迟：时间戳</li>
<li>获取子网掩码：掩码请求与掩码应答</li>
</ul>
<h2 id="常用网络管理软件的安装与配置"><a href="#常用网络管理软件的安装与配置" class="headerlink" title="常用网络管理软件的安装与配置"></a>常用网络管理软件的安装与配置</h2><ul>
<li><p>网络管理软件的常见功能</p>
<ul>
<li>网络性能监控：提供带宽测量、路由CPU负荷性能　指标的实时监控，以及历时数据统计</li>
<li>网络发现和拓扑管理：提供子网列表、ping sweep　和IP网络浏览器</li>
<li>IP地址管理</li>
<li>探测功能：提供ping和trace route等</li>
<li>其他：如TFTP服务器等</li>
</ul>
</li>
<li><p>常见网络管理软件安装与配置（12下）</p>
<ul>
<li><p>大型管理平台</p>
<p><strong>HP Open View、Sun Net Manager、IBM Net View</strong>等</p>
<p>可以对多种网络、协议进行管理，有很好的开放性，支持第三方管理软件的潜入</p>
</li>
<li><p>网络设备厂家自身产品的网管软件：如CISCO、Juniper、华为</p>
</li>
<li><p>中小型网络通用网管软件：Solarwinds、MRTG、SNMPc等。</p>
</li>
<li><p>这些网络系统都是采用SNMP协议来对网络进行管理的,如果一个网络管理控制多个代理，那么它和这些代理中的每一个都各构成一个团体。</p>
</li>
</ul>
</li>
<li><p>网络设备SNMP设置（以cisco路由器为例）</p>
<ul>
<li><p>创建或修改对SNMP团体的访问控制(08上、10上)</p>
<p>(config)# snmp-server community &lt;团体名&gt;</p>
<p> [view &lt;视阈名&gt; ] [ro | rw] [&lt;访问控制列表号&gt; ] 其中：</p>
<p>①团体名：用于同一团体内的管理站和代理之间进行通信认证。</p>
<p>②视阈名：规定了本团体内访问管理信息库的范围。</p>
<p>③Ro或rw：代表访问权限为<strong>只读</strong>或<strong>可读写</strong>。</p>
<p>④访问控制表号：<strong>1~99</strong>，标准的ACL，IP范围内的主机为属于这个“团体”的管理站。</p>
<p><strong>(config)# snmp-server community public 4</strong></p>
<p>(config)# snmp-server community admin view part rw</p>
</li>
<li><p>创建或修改一个SNMP视阈</p>
<p>(config)# snmp-server view &lt;视阈名&gt;</p>
<p>&lt;对象标识符或子树&gt;|included|excluded ]</p>
</li>
<li><p>设置路由器上的SNMP代理具有发出通知的功能：<br> (config)# snmp-server enable traps</p>
<p> [&lt;通知类型 &gt;] [&lt;通知选项&gt;]</p>
<p><strong>管理站对这种报文不必有所应答</strong></p>
</li>
<li><p>在某个接口的配置模式下，指定当该接口断开或连接时要向管理站发出通知</p>
<p>(config-if)# snmp trap link-status（链路状态）</p>
</li>
<li><p>配置接收通知的管理站</p>
<p>(config)# snmp-server host &lt;主机名或IP地址&gt; </p>
<p>[traps|informs] [version  1|2c] </p>
<p>&lt;团体名&gt;[ udp-port&lt;端口号&gt;（默认值为162）] [&lt;通知类型&gt;]</p>
</li>
</ul>
</li>
</ul>
<h2 id="利用工具监控和管理网络"><a href="#利用工具监控和管理网络" class="headerlink" title="利用工具监控和管理网络"></a>利用工具监控和管理网络</h2><ol>
<li><p>需求</p>
</li>
<li><p>网络监听原理</p>
<p>网卡有4 种接收模式：<strong>广播</strong>，<strong>组播</strong>，<strong>单播</strong>，<strong>混杂模式</strong>。嗅探器通过将本地网卡设置为混杂模式，来监听并捕捉其所连接网段的所有网络数据</p>
</li>
<li><p>网络数据监听部署</p>
<ul>
<li><p>对于<strong>共享型网络</strong></p>
<p>在共享型网络中，只要将嗅探器部署到网络中的任意一个接口上或者插入到任何一个节点的链路中，即可以捕捉到所有数据包</p>
</li>
<li><p>对于交换型网络</p>
<p>在交换式网络中，需要采用通过对交换机进行端口镜像的方式，来获得网络中流量</p>
<ul>
<li><p>配置被镜像端口：<code>SW(config)#monitor session 1 source interface Gi2/16</code></p>
</li>
<li><p>配置镜像端口：<code>SW(config)#monitor session 1 destination interface Gi2/12</code></p>
</li>
<li><p>检查配置：<code>SW#show monitor session 1</code> </p>
<p>Session 1<br> -——–<br> Type : Local Session<br> Source Ports :<br> Both:Gi2/16<br> Destination Ports : Gi2/12（目的端口，嗅探器放在这监测源端口）</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>网络数据监听工具（09下）</p>
<p>常见的网络数据监听工具有 <strong>Sniffer Pro、Ethereal、TCPdump</strong>，Wireshark 等，其中 Sniffer Pro 是一个功能强大的可视化  网络流量监控软件,主要功能包括：</p>
<ul>
<li>捕捉网络流量，进行数据包解码分析</li>
<li>实时监测网络活动</li>
<li>内置分析器诊断网络故障</li>
<li>存储各种历时信息，并可进行基线分析</li>
<li>当探测到网络故障时可以发出警报</li>
<li>可以模拟生成数据包对网络进行探测。</li>
</ul>
</li>
</ol>
<h2 id="查找和排除故障的基本方法"><a href="#查找和排除故障的基本方法" class="headerlink" title="查找和排除故障的基本方法"></a>查找和排除故障的基本方法</h2><ol>
<li><p>收集故障有关信息</p>
<ul>
<li>该计算机使用真实IP地址</li>
<li>该计算机能够使用域名访问自己校园网的WWW服务器</li>
<li>该计算机与校园网WWW服务器不在同一个网段（VLAN）</li>
<li>在同一网段的其他计算机能正常访问<a href="http://www.mircosoft.com/">www.mircosoft.com</a> </li>
</ul>
</li>
<li><p>可能造成一台计算机无法浏览某个WWW服务器的原因主要有</p>
<ul>
<li>该计算机的TCP/IP协议工作不正常</li>
<li>该计算机的IP地址与掩码设置有误</li>
<li>该计算机的网关设置有误</li>
<li>该计算机的DNS设置有误</li>
<li>该计算机系统的浏览器有问题</li>
<li>提供<a href="http://www.micrisoft.com名字解析的服务器有故障/">www.micrisoft.com名字解析的服务器有故障</a></li>
<li>服务器<a href="http://www.micrisoft.com工作不正常/">www.micrisoft.com工作不正常</a></li>
<li>校园网路由设置中存在问题</li>
<li><strong>该计算机请求无法到达服务器<a href="http://www.micrisoft.com/">www.micrisoft.com</a></strong></li>
</ul>
</li>
<li><p>故障测试与分析：</p>
<ul>
<li><p>运行命令ping <a href="http://www.microsoft.com测试/">www.microsoft.com测试</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">C:\&gt;ping www.microsoft.com</span><br><span class="line">Pinging lb1.www.ms.akadns.net [207.46.19.60(www.microsoft.com 的IP地址)] with 32 bytes of data:</span><br><span class="line">Reply from 202.113.79.1: destination net unreachable (表明该计算机发出的ping包在202.113.79.1处被阻拦了)</span><br><span class="line">Reply from 202.113.79.1: destination net unreachable</span><br><span class="line">Reply from 202.113.79.1: destination net unreachable</span><br><span class="line">Reply from 202.113.79.1: destination net unreachable</span><br><span class="line">Ping statistics <span class="keyword">for</span> 207.46.19.60 :</span><br><span class="line">Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),</span><br><span class="line">Approximate round trip <span class="built_in">times</span> <span class="keyword">in</span> milli-seconds:</span><br><span class="line">Minimum = 0ms, Maximum = 0ms, Average = 0ms</span><br></pre></td></tr></table></figure></li>
<li><p>运行命令 tracert <a href="http://www.microsoft.com测试/">www.microsoft.com测试</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C:\&gt;tracert www.microsoft.com</span><br><span class="line">Tracing route to lb1.www.ms.akadns.net [65.55.57.27]</span><br><span class="line">over a maximum of 30 hops:</span><br><span class="line">1&lt;1 ms &lt;1 ms&lt;1 ms 202.113.79.53</span><br><span class="line">2&lt;1 ms &lt;1 ms&lt;1 ms 202.113.79.9</span><br><span class="line">3 202.113.79.1 reports: destination net unreachable.(第三跳202.113.79.1存在访问控制)</span><br><span class="line">Trace complete.</span><br></pre></td></tr></table></figure></li>
<li><p>另外，如果出现 <code>request timed out</code> 可能是目标方工作不正常</p>
</li>
</ul>
</li>
</ol>
<h2 id="网络攻击与漏洞查找的基本方法"><a href="#网络攻击与漏洞查找的基本方法" class="headerlink" title="网络攻击与漏洞查找的基本方法"></a>网络攻击与漏洞查找的基本方法</h2><p>常见的网络入侵与攻击的基本方法</p>
<ul>
<li><p>木马入侵：C/S结构，不自身复制</p>
</li>
<li><p>漏洞入侵：<strong>Unicode漏洞入侵</strong>、<strong>跨站脚本注入</strong>、<strong>sql注入入侵</strong></p>
</li>
<li><p><em>协议欺骗攻击</em>*</p>
<p>主要的协议欺骗攻击方式有以下几种：<strong>IP 欺骗攻击、ARP 欺骗攻击、DNS 欺骗攻击、源路由欺骗攻击</strong></p>
</li>
<li><p>口令入侵</p>
</li>
<li><p>缓冲区溢出漏洞攻击</p>
</li>
<li><p><strong>拒绝服务攻击</strong>（Dos）：基本方式是通过发送大量合法的请求来消耗和占用过多的服务资源，使得网络服务不能相应正常的请求</p>
<p>常用的DoS 攻击包括：</p>
<ul>
<li>Smurf 攻击：攻击者冒充受害者主机的IP地址，向一个大的网络发送echo request的定向广播包，此网络的许多主机都作出回应，受害主机会收到大量的echo reply消息</li>
<li>SYN Flooding：利用TCP三次握手过程进行攻击，使用无效的IP地址</li>
<li>分布式拒绝服务攻击（DDos）：攻击者攻破了多个系统，并利用这些系统去集中攻击其他目标，成百上千的主机发送大量的请求，受害设备因为无法处理而拒绝服务</li>
<li>Ping of Death：通过构造出重组缓冲区大小的异常的ICMP包进行攻击</li>
<li>Teardrop：利用OS处理分片重叠报文的漏洞进行攻击</li>
<li>Land 攻击：向某个设备发送数据包，并将数据包的源地址和目的地址都设置成攻击目标地址。</li>
</ul>
</li>
</ul>
<p>漏洞查找办法</p>
<p>漏洞扫描分为被动和主动两种</p>
<ul>
<li><p><strong>被动</strong>扫描对网络上的流量进行分析，不产生额外流量，类似于<strong>IDS</strong></p>
</li>
<li><p>主动扫描可能会影响网络系统的正常运行</p>
</li>
<li><p>常用的漏洞扫描攻击有：<strong>ISS，Microsoft Baseline Security Analyzer，X-Scanner</strong></p>
<ul>
<li><p>ISS扫描器是<strong>主动扫描</strong>的一种</p>
<p>Internet Scanner对<strong>网络设备</strong>进行自动的安全漏洞分析</p>
<p>System Scanner是在系统层上通过<strong>依附于主机</strong>上的扫描器代理侦测主机内部的漏洞</p>
</li>
<li><p>X-Scanner采用<strong>多线程方式</strong>对指定IP地址段进行安全漏洞是扫描，支持插件功能，提供了<strong>图形界面</strong>和<strong>命令行</strong>两种操作方式</p>
</li>
<li><p>MBSA是微软的安全评估工具</p>
</li>
</ul>
</li>
</ul>
<p>漏洞修补方法（09上）</p>
<ul>
<li><p><strong>Microsoft Windows Server Update Services (WSUS)</strong> 是用来实时发布微软公共操作系统软件更新程序的服务器，WSUS通过Internet和微软公司Microsoft Windows Server Update Services实时连接，及时获得微软公司最新更新程序，大大缩短了网内计算机执行重大更新时的时间过程</p>
</li>
<li><p>可更新部署Windows Server 2003、Windows 2000 Server 和 Windows XP 、Office XP、Exchange server2003以及SQL server2000和更高版本的更新。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>NCRE</category>
      </categories>
      <tags>
        <tag>网络技术</tag>
      </tags>
  </entry>
  <entry>
    <title>综合题</title>
    <url>/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="路由器配置"><a href="#路由器配置" class="headerlink" title="路由器配置"></a>路由器配置</h2><p>静态路由配置</p>
<p>Router（config）# <strong>ip route &lt;目的网络地址&gt;&lt;子网掩码&gt;&lt;下一跳路由器的IP地址&gt;</strong> </p>
<p>如：Router（config）# ip route 59.65.96.0 255.255.240.0 222.112.37.1</p>
<p><strong><span id="more"></span></strong></p>
<p><strong>默认路由配置</strong></p>
<p>Router（config）# <strong>ip route 0.0.0.0 0.0.0.0 &lt;下一跳路由器的IP地址&gt;</strong> </p>
<p>如：Router（config）# ip route 0.0.0.0 0.0.0.0 222.112.37.1</p>
<p><strong>POS接口配置</strong></p>
<p>Router（config）# Interface POS3/0 </p>
<p>Router（config-if）# Description TO BEIJING </p>
<p>Router（config-if）# <strong>Bandwidth 2500000 (单位bps)</strong></p>
<p>Router（config-if）# Ip address 212.14.37.18 255.255.255.252 </p>
<p>Router（config-if）# <strong>Crc 32 （可选的CRC校验位是16和32）</strong></p>
<p>Router（config-if）# <strong>Pos framing sdh （可选帧格式是SDH和SONET）</strong></p>
<p>Router（config-if）# No ip directed-broadcast </p>
<p>Router（config-if）# <strong>Pos flag s1s0 2</strong> </p>
<p>  （<strong>s1s0=00表示是SONET帧数据，s1s0＝10（十进制2）表示是SDH帧</strong>）</p>
<p>广域网同步串行接口配置</p>
<p>Router（config）# Interface s1/1 </p>
<p>Router（config-if）# Description TOBEIJING </p>
<p>Router（config-if）# <strong>Bandwidth 2048 （带宽为2M）注意单位为bps</strong></p>
<p>Router（config-if）# Ip address 212.112.41.81 255.255.255.252 </p>
<p>Router（config-if）# <strong>Encapsulation</strong> hdlc （<strong>封装HDLC或PPP协议，HDLC为缺省</strong>）</p>
<p>// encapsulation的拼写</p>
<p> Router（config-if）# No ip directed-broadcast </p>
<p>Router（config-if）# No ip proxy-arp </p>
<p>Router（config-if）# No shutdown </p>
<p>Router（config-if）# Exit </p>
<p><strong>OSPF配置</strong></p>
<p>一、启用OSPF ：</p>
<p>在全局模式下：router ospf <process id></process></p>
<p>二、在OSPF配置模式下，定义参与OSPF的子网地址,使用命令：</p>
<p><strong>area &lt;区域号&gt; range &lt;子网地址&gt;&lt;子网掩码&gt;；和</strong></p>
<p><strong>network &lt;子网号&gt; <wildcard-mask> area &lt;区域号&gt;</wildcard-mask></strong></p>
<p>​    如果区域中的子网是连续的，则可使用这个子网聚合功能，区域边缘路由器可以将所有连续的子网聚合为一条路由信息传播给其他区域，在其他区域内的路由器看到这个区域的路由就只有一条。 <strong>注意：同区域在定义参与OSPF的子网地址时也可以子网聚合</strong></p>
<p><img src="/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/image-20210323101942248.png" alt="image-20210323101942248"></p>
<p><img src="/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/image-20210323101958092.png" alt="image-20210323101958092"></p>
<p><img src="/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/image-20210324093652155.png" alt="image-20210324093652155"></p>
<p><img src="/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/image-20210324094627442.png" alt="image-20210324094627442"></p>
<p><img src="/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/image-20210324102034191.png" alt="image-20210324102034191"></p>
<p><img src="/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/image-20210324131436805.png" alt="image-20210324131436805"></p>
<p><img src="/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/image-20210325144924390.png" alt="image-20210325144924390"></p>
<p><img src="/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/image-20210326193429768.png" alt="image-20210326193429768"></p>
]]></content>
      <categories>
        <category>NCRE</category>
      </categories>
      <tags>
        <tag>网络技术</tag>
      </tags>
  </entry>
  <entry>
    <title>网络安全技术</title>
    <url>/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/%E7%AC%AC%E5%8D%81%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="网络攻击"><a href="#网络攻击" class="headerlink" title="网络攻击"></a>网络攻击</h2><ul>
<li><p>服务攻击（DOS）</p>
<p>指对网络中提供给某种服务的服务器进行攻击，使其“拒绝服务”而造成网络无法正常工作</p>
</li>
<li><p>非服务攻击（如对网络设备攻击、源路由攻击和地址欺骗）</p>
<p>利用协议或操作系统实现协议时的漏洞来达到攻击的目的，它不针对于某具体的应用服务，因此非服务攻击是一种更有效的攻击手段</p>
</li>
<li><p>非授权访问</p>
<p>存储在联网计算机中的信息或服务被未授权的网络用户非法使用，或者被授权用户越权滥用</p>
</li>
<li><p>网络病毒</p>
</li>
</ul>
<span id="more"></span>





<h2 id="网络安全模型"><a href="#网络安全模型" class="headerlink" title="网络安全模型"></a>网络安全模型</h2><ol>
<li><p>网络安全模型</p>
<p>在网络信息传输中，为了保证信息传输的安全性，一般需要一个值得信任的第三方，负责向源结点和目的结点进行秘密信息分发，同时在双方发生争执时，也要起到仲裁的作用。在基本的安全模型中，通信的双方在进行信息传输前，先建立起一条逻辑通道，并提供安全的机制和服务，来实现在开放网络环境中信息的安全传输。</p>
</li>
<li><p>P2DR模型</p>
<ul>
<li><strong>安全策略（Policy）</strong>是模型中的防护、检测和响应等部分实施的依据，一个安全策略体系的建立包括策略的制定、评估与执行。 包括<strong>安全策略和具体安全规则</strong></li>
<li>*防护（Protection）<strong>防护技术包括：防火墙、操作系统身份认证、数据加密、访问控制、授权、虚拟专用网技术和数据备份等，它对系统</strong>可能出现的安全问题采取预防措施</li>
<li>检测（Detection）<strong>检测功能使用漏洞评估、入侵检测等系统检测技术，当攻击者穿透防护系统时，发挥功用</strong></li>
<li>响应（Response）<strong>响应包括</strong>紧急响应和恢复处理**，而恢复又包括系统恢复和信息恢复，响应系统在检测出入侵时，开始事件处理的工作</li>
</ul>
</li>
</ol>
<h2 id="网络安全规范"><a href="#网络安全规范" class="headerlink" title="网络安全规范"></a>网络安全规范</h2><p>可信计算机系统评估准则（TCSEC)将计算机系统安全等级分为A．B．C．D这4类，共有7级，即D．C1、C2、B1、B2、B3与A1，其中，<strong>D级系统的安全要求最低，A1级系统的安全要求最高</strong></p>
<p><strong>D级</strong>系统属于非安全保护类，它<strong>不能用于多用户环境下的重要信息处理</strong></p>
<p><strong>C类</strong>系统是用户能定义访问控制要求的<strong>自主保护类型</strong></p>
<p><strong>B类</strong>系统属于强制型安全保护系统，即<strong>用户不能分配权限</strong>，只有管理员可以为用户分配</p>
<p><strong>一般的UNIX系统通常能满足C2标准</strong></p>
<h2 id="数据备份方法（基于策略）"><a href="#数据备份方法（基于策略）" class="headerlink" title="数据备份方法（基于策略）"></a>数据备份方法（基于策略）</h2><ul>
<li><p>完全备份</p>
<p>完全备份即是将用户指定的数据甚至是整个系统的数据进行完全的备份</p>
</li>
<li><p>增量备份</p>
<p>增量备份是针对完全备份，在进行增量备份，只有那些在上次完全或者增量备份后被修改了的文件才会被备份</p>
</li>
<li><p>差异备份</p>
<p>差异备份是将最近一次完全备份后产生的所有数据更新进行备份。差异备份将完全恢复时所涉及到的备份文件数量限制为2个</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>空间使用</th>
<th>备份速度</th>
<th>恢复速度</th>
</tr>
</thead>
<tbody><tr>
<td>完全备份</td>
<td>最多</td>
<td>最慢</td>
<td>最快</td>
</tr>
<tr>
<td>增量备份</td>
<td>最少</td>
<td>最快</td>
<td>最慢</td>
</tr>
<tr>
<td>差异备份</td>
<td>少于完全备份</td>
<td>快于完全备份</td>
<td>快于增量备份</td>
</tr>
</tbody></table>
<h2 id="防病毒技术"><a href="#防病毒技术" class="headerlink" title="防病毒技术"></a>防病毒技术</h2><p>恶意代码</p>
<ul>
<li><p>蠕虫</p>
<p>蠕虫是是一个自我包含的程序，它能够传播自身的功能或拷贝自身的片段到其他计算机系统（通常是通过网络连接）</p>
</li>
<li><p>木马</p>
<p>“木马”通常寄生在用户计算机系统中，盗用用户信息，并通过网络发送给黑客。与病毒不同之处在于<strong>没有自我复制功能</strong></p>
<p>传播途径：<strong>电子邮件、软件下载、会话软件</strong></p>
</li>
</ul>
<p>防病毒软件安装与配置</p>
<ul>
<li><p>网络版防病毒系统结构</p>
<ul>
<li><p>系统中心：系统中心实时记录计算机的病毒监控、检测和清除的信息，实现对整个防护系统的自动控制。</p>
</li>
<li><p>服务器端：服务器端为网络服务器操作系统应用而设计</p>
</li>
<li><p>客户端：客户端对当前工作站上病毒监控、检测和清除，并在需要时向系统中心发送病毒监测报告</p>
</li>
<li><p>管理控制台：管理控制台是为了网络管理员的应用而设计的，通过它可以集中管理网络上所有已安装的防病毒系统防护软件的计算机</p>
<p><strong>管理控制台既可以安装到服务器上也可以安装在客户机上，视网络管理员的需要，可以自由安装</strong></p>
</li>
</ul>
</li>
<li><p>网络版防病毒系统安装</p>
<p>对于大多数的网络版的防病毒系统，<strong>服务器端和客户端通常可以采用本地安装、远程安装、Web安装、脚本安装等方式进行安装</strong></p>
<p>控制台的安装通常有两种方式：通过光盘安装控制台、远程安装控制台，系统管理员可以将管理控制台远程安装到其他计算机上</p>
</li>
<li><p>网络版防病毒系统的主要参数配置</p>
<ul>
<li>系统升级：<strong>从网站升级、从上级中心升级、从网站上下载手动数据包</strong></li>
<li>扫描设置</li>
<li>黑白名单设置</li>
<li>端口设置：<strong>为了使网络版防病毒软件的通信数据能顺利的通过防火墙，通常系统都会提供用于数据通信端口设置的界面。（非固定端口）</strong></li>
</ul>
</li>
</ul>
<h2 id="防火墙技术"><a href="#防火墙技术" class="headerlink" title="防火墙技术"></a>防火墙技术</h2><ul>
<li><p>防火墙的主要功能</p>
<ul>
<li>所有的从外部到内部的通信都必须经过它</li>
<li>只有有内部访问策略授权的通信才能被允许通过</li>
<li>具有防攻击能力，保证自身的安全性。</li>
</ul>
</li>
<li><p><strong>防火墙的分类</strong></p>
<ul>
<li>防火墙在网络之间通过执行控制策略来保护网络系统，防火墙包括硬件和软件两部分</li>
<li>防火墙根据其实现技术可以分为：<strong>包过滤路由器、应用网关、应用代理</strong>和<strong>状态检测</strong>4类</li>
</ul>
</li>
<li><p>防火墙的系统结构</p>
<ul>
<li>包过滤型结构：包过滤型结构是通过专用的包过滤路由器或是安装了包过滤功能的普通路器来实现的。包过滤型结构对进出内部网络的所有信息进行分析，按照一定的安全策略对这些信息进行分析与限制</li>
<li>双宿网关结构：双宿网关结构即是一台装有两块网卡的主机作为防火墙，将外部网络与同部网络实现物理上的隔开。应用级网管完全暴露个整个外部网络，人们将处于防火墙关键部位、运行应用级网管软件的计算机系统成为<strong>堡垒主机</strong></li>
<li>屏蔽主机结构：屏蔽主机结构将所有的外部主机强制与一个堡垒主机相连，从而不允许它们直接与内部网络的主机相连，因此<strong>屏撇主机结构是由包过滤路由器和堡垒主机组成的</strong></li>
<li>屏蔽子网结构：<strong>屏蔽子网结构使用了两个屏蔽路由器和两个堡垒主机</strong>。在该系统中，从外部包过滤由器开始的部分是由网络系统所属的单位组建的，属于内部网络，也称为“<strong>DMZ网络</strong>”。外部包过滤路由器与外部堡垒主机构成了防火墙的过滤子网；内部包过滤路由器和内部堡垒主机则用于对内部网络进行进一步的保护。</li>
</ul>
</li>
</ul>
<h2 id="网络入侵检测系统的部署"><a href="#网络入侵检测系统的部署" class="headerlink" title="网络入侵检测系统的部署"></a>网络入侵检测系统的部署</h2><ul>
<li><p>网络入侵检测系统的组成结构</p>
<ul>
<li>控制台</li>
<li>探测器</li>
</ul>
</li>
<li><p>网络入侵检测系统常用部署方法</p>
<ol>
<li><p>网络接口卡与交换设备的监控端口连接，通过交换设备的Span/Mirror功能将流向个端口的数据包复制一份给监控端口</p>
</li>
<li><p>在网络中增加一台集线器改变网络拓扑结构，通过集线器（共享式监听方式）获取数据包</p>
</li>
<li><p>入侵检测传感器通过一个TAP（分路器）设备对交换式网络中的数据包进行分析和处理</p>
<blockquote>
<p><strong>TAP是一种容错方案，它提供全双工或半双工10/100/1000M网段上观察数据流量的手段</strong>，其优点为</p>
<ul>
<li>TAP是容错的，如果发生电源故障，原先监控的网段上的通信部受影响</li>
<li>TAP不会影响数据流</li>
<li>TAP阻止建立于入侵检测系统的直接连接，从而保护它不受攻击</li>
</ul>
</blockquote>
</li>
</ol>
</li>
</ul>
<h2 id="网络安全评估"><a href="#网络安全评估" class="headerlink" title="网络安全评估"></a>网络安全评估</h2><ul>
<li><p>网络安全评估分析技术</p>
<ul>
<li><p>基于应用的技术（被动）</p>
</li>
<li><p>基于网络的技术（主动）</p>
<p>网络安全风险评估技术通常用来进行<strong>穿透实验</strong>和<strong>安全审计</strong></p>
</li>
</ul>
</li>
<li><p>网络安全评估分析系统结构</p>
<p>通常采用<strong>控制台</strong>和<strong>代理相结合</strong>的结构</p>
</li>
</ul>
]]></content>
      <categories>
        <category>NCRE</category>
      </categories>
      <tags>
        <tag>网络技术</tag>
      </tags>
  </entry>
  <entry>
    <title>路由器设计基础</title>
    <url>/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="路由相关术语"><a href="#路由相关术语" class="headerlink" title="路由相关术语"></a>路由相关术语</h2><p>分组转发</p>
<ul>
<li>分组的传送采用存储-转发方式，即网络节点根据分组控制信息，分组送到下一节点，下一节点接收到分组后，暂时保存下来并排队等候传输，然后根据分组控制信息把该分组传送到下一节点，直至到达最终目的</li>
</ul>
<span id="more"></span>

<p>路由算法分类</p>
<ul>
<li><strong>静态路由选择算法</strong> 也称为非自适应路由选择，其路由信息是由<strong>网络管理人员手工配置</strong>的，且需要网络管理人员手动修改路由表中的路由表项，以适应网络拓扑结构变化或网络链路状态的变化</li>
<li><strong>动态路由选择算法</strong> 也叫做自适应路由选择，其路由信息是通过相互连接的路由器彼此之间 <strong>交换路由信息</strong>，然后按照一定的算法 <strong>计算并优化</strong> 而得出的，同时为适应不断变化的网络，还需要在一定时间间隙对这些路由信息不断更新，以即使获得最有的路径选择效果</li>
</ul>
<p>路由的度量标准</p>
<ul>
<li>跳数：分组从源节点到目的即节点所经过路由器的个数</li>
<li>带宽：链路的传输速率，用来表示通信线路所能传送数据的能力</li>
<li>延时：分组从源节点到达目的节点所花费的时间</li>
<li>负载：单位时间内通过路由器或线路的通信量</li>
<li>可靠性：传输过程中的误码率，域网络的质量和性能有密切的关系</li>
<li>代价：传输过程中的耗费，通常域所使用的链路带宽相关，一般来说，网络的速率越高，其代价也越高。</li>
</ul>
<h2 id="IP-路由选择和路由汇聚"><a href="#IP-路由选择和路由汇聚" class="headerlink" title="IP 路由选择和路由汇聚"></a>IP 路由选择和路由汇聚</h2><ul>
<li>无类域间路由协议（CIDR）<strong>支持通过子网划分的相反过程</strong> 来汇聚路由表项</li>
<li>无类域间路由协议使用 <strong>网络前缀法表示路由表的表现</strong>，具体路由表的项目表示由 <strong>“网络前缀”和“下一跳地址”</strong> 两项内容组成</li>
<li>路由选择变为从匹配结果中选择具有最长网络前缀的路由的过程，这就是 <strong>最长前缀匹配</strong></li>
</ul>
<h2 id="路由信息协议（RIP）"><a href="#路由信息协议（RIP）" class="headerlink" title="路由信息协议（RIP）"></a>路由信息协议（RIP）</h2><p>RIP（路由信息协议）是一种<strong>分布式、基于距离向量</strong> 的内部网关协议，适用于小型同类网络的一个自治系统内的路由细心的传递，是使用 <strong>跳数</strong> 来衡量到达目的地址的路由距离</p>
<p>RIP 的原理</p>
<ul>
<li>路由刷新报文主要内容由若干个<strong>（V, D）</strong>组成的表<ul>
<li><strong>V 表示“矢量</strong>，标识该路由器可以到达的目的网络或者目的主机</li>
<li><strong>距离 D 对应路由上的“跳数”</strong></li>
</ul>
</li>
<li>RIP 规定，路由器<strong>每 30 秒向外广播一个（V, D）报文（周期性）</strong>，报文信息来自本地路由器表</li>
<li>RIP 规定，一条有限的 <strong>路径长度不得超过 15</strong>，超过 15 则以为路径无限长，即路径不存在</li>
</ul>
<p>RIP 的运行过程</p>
<p><img src="https://bluexiaowei.github.io/NCRE3/static/images/04-01.png" alt="RIP 的运行过程"></p>
<h2 id="最短路径优先协议（OSPF）"><a href="#最短路径优先协议（OSPF）" class="headerlink" title="最短路径优先协议（OSPF）"></a>最短路径优先协议（OSPF）</h2><p>OSPF 协议概述</p>
<ul>
<li>开放最短路径优先（OSPF）协议，也是 <strong>内部网关协议</strong> 的一种，克服 RIP 的缺点开发出来的</li>
<li>开放式最短路径优先协议 <strong>组要用于在自治系统内部路由器之间传输路由信息</strong></li>
<li>开放式最短路径优先协议不采用距离矢量的路由算法，而是 <strong>基于 Dijkstra 提出的最短路径算法规则计算路径</strong></li>
<li>开放式最短路径优先协议还 <strong>支持分层网络</strong>，这使得它的应用更加具有广泛性和灵活性</li>
</ul>
<p>OSPE 协议的特征</p>
<ul>
<li>OSPE 主要的特征是使用 <strong>分布式链路状态协议</strong>，而 RIP 使用的是距离向量协议</li>
<li>OSPE 协议要求路由器发送的信息是本路由器与那些相邻路由器，以及链路状态的质量。<strong>链路状态“度量”组要是指费用、距离、延时、带宽等</strong></li>
<li>OSPF 协议要求当链路状态发生变化时用 <strong>“洪泛法”</strong> 向所有路由器发送此信息，而 RIP 仅向自己相邻的几个路由器发送交换路由信息</li>
<li>OSPF 协议的路由器之间频繁的交换链路状态信息，<strong>区域内部路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑情况</strong></li>
<li>为了适应规模很大的网络，并使更新过程收敛的更快，OSPE 协议将一个自治系统再划分为若干个更小的范围，叫做 <strong>区域</strong></li>
<li>每个区域有个 <strong>32 位区域标识符</strong>（用点分十进制表示），再一个区域内的路由器数 <strong>不超过 200 个</strong></li>
<li>所有的OSPF路由器交换链路状态信息，最终建立一个<strong>链路状态数据库</strong>， 这个数据库实际上就是该区域全网的拓扑结构图</li>
</ul>
<h2 id="外部网关协议（BGP）"><a href="#外部网关协议（BGP）" class="headerlink" title="外部网关协议（BGP）"></a>外部网关协议（BGP）</h2><p>自治系统 AS 的定义：在单一的技术管理下的一组路由器，而这些路由器使用一种 AS 内部的路由选择协议和共同的度量以确定分组在 AS 内的路由，同时还使用一种 AS 之间的路由选择协议用以确定分组在 AS 之间的路由。</p>
<p><img src="https://bluexiaowei.github.io/NCRE3/static/images/04-02.png" alt="外部网关协议(BGP-4)"></p>
<p>BGP 的主要特点</p>
<ul>
<li>是一种外部网关协议，是在 AS 之间传递路由信息以及控制优化路由信息</li>
<li>是一种“<strong>路径矢量</strong>”路由协议，其路由信息中携带了所经过的全部自治系统的路由列表</li>
<li>为了保证 BGP 的可靠传输，其使用 TCP 来承载协议报文</li>
</ul>
<p>BGP边界路由器的初始化过程：BGP刚刚运行时，交换整个路由表，以后只需要在发生变化时更新有变化的部分</p>
<p>BGP 路由协议四种分组</p>
<ul>
<li><strong>打开（OPEN）报文</strong>：采用与相邻的另一个 BGP 发言人建立关系</li>
<li><strong>更新（UPDATE）报文</strong>：用来发送某一路由的信息，以及列出要撤销的多条路由</li>
<li><strong>保活（KEEPALIVE）报文</strong>：用来确认打开报文和周期性（30 秒）的证实邻站关系</li>
<li><strong>通知（NOTIFICATION）报文</strong>：用来发送检测到的差错。</li>
</ul>
]]></content>
      <categories>
        <category>NCRE</category>
      </categories>
      <tags>
        <tag>网络技术</tag>
      </tags>
  </entry>
  <entry>
    <title>JS函数</title>
    <url>/2021/10/18/JS/JS%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>函数是 JavaScript 程序的一个基本组成部分</p>
<p>JavaScript 函数是参数化的，即函数定义可以包含一组标识符，称为参数或形参，函数调用会为这些形参提供值或实参</p>
<p>JavaScript 函数可以嵌套函数，内嵌的函数可以访问定义在函数作用域的任何变量。即 JavaScript 函数是闭包</p>
<span id="more"></span>

<h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>定义函数有以下方法</p>
<ul>
<li>function 关键字</li>
<li>箭头函数</li>
</ul>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>函数声明由 function 关键字和函数体组成</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算阶乘的递归函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x * factorial(x-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数声明语句会被“提升”到包含脚本、函数或代码块的顶部，因此调用代码可以出现在函数定义代码之前</p>
<p>在一个 JavaScript 代码块中声明的所有函数在该块的任何地方都有定义，且在 JavaScript 解释器开始执行该块的任何代码前被定义</p>
<p>在语句块中定义的函数只在该块中有定义，对块的外部不可见</p>
<h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><p>函数表达式出现在复杂表达式或语句的上下文中，且函数名是可选的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将该函数表达式赋值给一个变量</span></span><br><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; <span class="keyword">return</span> x*x&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式可以包含名字，对递归有用</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="keyword">function</span> <span class="title">fact</span>(<span class="params">x</span>)</span>&#123; <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">else</span> <span class="keyword">return</span> x*fact(x-<span class="number">1</span>);&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式也可以用作其他函数的参数</span></span><br><span class="line">[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>].sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123; <span class="keyword">return</span> a-b;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式也可以定义完立即调用</span></span><br><span class="line"><span class="keyword">let</span> tensquared = (<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; <span class="keyword">return</span> x*x;&#125;(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>



<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>在 ES6 中，箭头函数使用”箭头“分隔函数的参数和函数体</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123; <span class="keyword">return</span> x + y&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若函数体只有一个 return 语句，可以省略</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">x, y</span>) =&gt;</span>  x + y;</span><br></pre></td></tr></table></figure>

<p>箭头函数从定义自己的环境继承 <code>this</code> 关键字的值，而不像其他函数那样定义自己的调用上下文、</p>
<p>箭头函数没有 <code>prototype</code> 属性，即箭头函数不能作为新类的构造函数</p>
<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>构成函数体的 JavaScript 代码在调用函数的时候执行，JavaScript 函数可通过 5 种方式调用</p>
<ul>
<li>作为函数</li>
<li>作为方法</li>
<li>作为构造函数</li>
<li>通过 call() 或 apply() 方法间接调用</li>
<li>通过 JavaScript 语言特性隐式调用（与常规书函数调用不同）</li>
</ul>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>对于常规函数调用，函数的返回值会变成调用表达式的值</p>
<ul>
<li>若函数由于解释器到末尾返回，返回值为 <code>undefined</code></li>
<li>若函数由于解释器执行到 <code>return</code> 语句返回，返回语句表达式值，若没有值返回 <code>undefined</code></li>
</ul>
<p>作为函数来调用的函数通常不会在定义中使用 <code>this</code> 关键字</p>
<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>方法即对象的属性为函数时的函数</p>
<p>方法调用会调用上下文，属性访问表达式由两部分构成：对象和属性名。对象会成为调用上下文，函数体可以通过 <code>this</code> 引用这个对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> calculator = &#123;</span><br><span class="line">    <span class="attr">operand1</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">operand2</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 使用this关键字引用包含对象</span></span><br><span class="line">        <span class="built_in">this</span>.result = <span class="built_in">this</span>.operand1 + <span class="built_in">this</span>.operand2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">calculator.add();</span><br><span class="line">calculator.result;    <span class="comment">// =&gt; 2</span></span><br></pre></td></tr></table></figure>

<p><code>this</code> 关键字不具有变量那样的作用域，除了箭头函数，嵌套函数不会继承包含函数的 <code>this</code> 值</p>
<ul>
<li>嵌套方法被当作方法调用，<code>this</code> 值就是调用它的对象</li>
<li>嵌套方法（不是箭头函数）被当作函数调用，<code>this</code> 值是全局对象（非严格模式）或 <code>undefined</code>（严格模式）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    <span class="attr">m</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> self = <span class="built_in">this</span>;    <span class="comment">// 将 this 值保存在变量中</span></span><br><span class="line">        <span class="built_in">this</span> === o;         <span class="comment">// =&gt; true</span></span><br><span class="line">        f();                <span class="comment">// 调用嵌套函数</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span> === o;     <span class="comment">// =&gt; false：this 是全局对象或 undefined</span></span><br><span class="line">            self === o;     <span class="comment">// =&gt; true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在嵌套函数内，<code>this</code> 关键字不等于对象，解决技巧：</p>
<ul>
<li><p>如上述代码将 <code>this</code> 值 赋给变量，在嵌套函数中，使用变量引用</p>
</li>
<li><p>ES6 之后，使用箭头函数继承 <code>this</code> 值，函数表达式不会被提升，需要将定义放在对象方法调用嵌套函数代码前</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span> ===o;    <span class="comment">// true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>调用嵌套函数的 <code>bind()</code> 函数，定义一个在指定对象上被隐式调用的新函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> f = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span> === o    <span class="comment">// true，因为将这个函数绑定到外部的 this</span></span><br><span class="line">&#125;).bind(<span class="built_in">this</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="构造函数调用"><a href="#构造函数调用" class="headerlink" title="构造函数调用"></a>构造函数调用</h3><p>在函数或方法调用前加关键字 <code>new</code>，即为构造函数调用</p>
<p>构造函数调用会创建一个新的空对象，这个对象继承构造函数的 <code>prototype</code> 属性指定的对象</p>
<h3 id="隐式函数调用"><a href="#隐式函数调用" class="headerlink" title="隐式函数调用"></a>隐式函数调用</h3><p>一些 JavaScript 语言特性看起来不像函数调用，但实际上会导致某些函数被调用</p>
<p>这些被隐式调用的函数，若产生 bug，副效应和性能问题都比常规函数更难排查</p>
<p>可能导致隐式函数调用的语言特性</p>
<ul>
<li>若对象由获取方法或设置方法，查询或设置其属性值可能会调用这些方法</li>
<li>对象在字符串上下文中使用时，会调用对象的 <code>toString()</code> 方法，用于数值上下文时，会调用 <code>valueOf()</code> 方法</li>
<li>遍历可迭代对象的元素时，也会涉及一系列方法调用</li>
<li>标签模板字面量是一种伪装的函数调用</li>
<li>代理对象的行为完全由函数控制，其上的几乎任何操作都会导致一个函数被调用</li>
</ul>
<h2 id="函数实参与形参"><a href="#函数实参与形参" class="headerlink" title="函数实参与形参"></a>函数实参与形参</h2><p>JavaScript 函数定义不会指定函数形参的类型，函数调用也不对传入的实参进行任何类型检查</p>
<h3 id="可选形参与默认值"><a href="#可选形参与默认值" class="headerlink" title="可选形参与默认值"></a>可选形参与默认值</h3><p>调用函数时传入的实参少于声明的形参时，额外的形参会获得默认值，通常是 <code>undefined</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将对象 o 的可枚举属性名放到数组中，返回数组</span></span><br><span class="line"><span class="comment">// 若不传数组，创建一个新数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPropertyNames</span>(<span class="params">o, a = []</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> property <span class="keyword">in</span> o) a.push(property);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数的形参默认值表达式在函数调用时求值，因此每次调用上述函数时若只传一个参数，都创建并传入一个新的空数组</p>
<p>若函数有多个形参，可以使用前面参数的值来定义后面参数的默认值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> rectangle = (width, height = width*<span class="number">2</span>)</span><br><span class="line">rectangle(<span class="number">1</span>)        <span class="comment">// =&gt; &#123;width: 1, height: 2&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="剩余实参与可变长度实参列表"><a href="#剩余实参与可变长度实参列表" class="headerlink" title="剩余实参与可变长度实参列表"></a>剩余实参与可变长度实参列表</h3><p>剩余形参能够编写在调用时传入比形参多任意数量的实参的函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params">first=-<span class="literal">Infinity</span>, ...rest</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> maxValue = first;</span><br><span class="line">    <span class="comment">// 遍历其他参数，寻找最大数值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> n <span class="keyword">of</span> rest)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; maxValue)&#123;</span><br><span class="line">            maxValue = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回最大的数值</span></span><br><span class="line">    <span class="keyword">return</span> maxValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">max(<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1000</span>, <span class="number">4</span>)    <span class="comment">// =&gt; 1000</span></span><br></pre></td></tr></table></figure>

<p>剩余形参前有三个点，且必须是函数声明中最后一个参数</p>
<p>在函数体内，剩余形参的值始终是数组，数组可能为空，但剩余形参不可能为 <code>undefined</code></p>
<h3 id="函数实参解构为形参"><a href="#函数实参解构为形参" class="headerlink" title="函数实参解构为形参"></a>函数实参解构为形参</h3><p>调用函数时若传入一个实参列表，则所有参数值都会被赋给函数定义时声明的形参</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">vectorAdd</span>(<span class="params">v1, v2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [v1[<span class="number">0</span>] + v2[<span class="number">0</span>], v1[<span class="number">1</span>] + v2[<span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line">vectorAdd([<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>])    <span class="comment">// =&gt; [4,6]</span></span><br></pre></td></tr></table></figure>

<p>在解构赋值中可以为形参定义默认值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用标量乘以向量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">vetorMultiply</span>(<span class="params">&#123;x, y, z=<span class="number">0</span>&#125;, scalar</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">x</span>: x*scalar, <span class="attr">y</span>: y*scalar, <span class="attr">z</span>: z*scalar&#125;;</span><br><span class="line">&#125;</span><br><span class="line">vectorMultiply(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;, <span class="number">2</span>)    <span class="comment">// =&gt; &#123;x: 2, y: 4, z: 0&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以通过把对象参数解构为函数参数模拟调用函数时使用 <code>name=value</code> 的形式指定实参</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arraycopy</span>(<span class="params">&#123;<span class="keyword">from</span>,to=<span class="keyword">from</span>,n=<span class="keyword">from</span>.length,fromIndex=<span class="number">0</span>,toIndex=<span class="number">0</span>&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> valuesToCopy = <span class="keyword">from</span>.slice(fromIndex, fromIndex + n);</span><br><span class="line">    to.splice(toIndex, <span class="number">0</span>, ...valuesToCopy);</span><br><span class="line">    <span class="keyword">return</span> to;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], b=[<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>];</span><br><span class="line">arraycopy(&#123;<span class="attr">from</span>: a, <span class="attr">n</span>: <span class="number">3</span>, <span class="attr">to</span>: b, <span class="attr">toIndex</span>: <span class="number">4</span>&#125;)    <span class="comment">// =&gt; [9, 8, 7, 6, 1, 2, 3, 5]</span></span><br></pre></td></tr></table></figure>

<p>ES2018 中，解构对象也可以使用形参</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">vetorMultiply</span>(<span class="params">&#123;x, y, z=<span class="number">0</span>, ...props&#125;, scalar</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">x</span>: x*scalar, <span class="attr">y</span>: y*scalar, <span class="attr">z</span>: z*scalar, ...props&#125;;</span><br><span class="line">&#125;</span><br><span class="line">vectorMultiply(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">w</span>: -<span class="number">1</span>&#125;, <span class="number">2</span>)    <span class="comment">// =&gt; &#123;x: 2, y: 4, z: 0, w: -1&#125;</span></span><br></pre></td></tr></table></figure>







<h2 id="函数作为值"><a href="#函数作为值" class="headerlink" title="函数作为值"></a>函数作为值</h2><p>在 JavaScript 中，函数不仅是语法，也是值，即可以把函数赋值给变量、保存为对象的属性或数组的元素、作为参数传给其他函数等操作</p>
<p>函数在 JavaScript 中不是原始值，是一种特殊的对象，即函数也可以有属性。当函数需要一个“静态”变量，且这个变量的值需要在函数每次调用时都能访问到，则通常把这个变量定义为函数自身的一个属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算阶乘并把结果缓存到函数本身的属性中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Number</span>.isInteger &amp;&amp; n &gt; <span class="number">0</span>)&#123;              <span class="comment">// 仅限于正整数</span></span><br><span class="line">        <span class="keyword">if</span>(!(n <span class="keyword">in</span> factorial))&#123;                  <span class="comment">// 若没有缓存</span></span><br><span class="line">            factorial[n] = n * factorial(n-<span class="number">1</span>);  <span class="comment">// 计算并缓存结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> factorial[n];                    <span class="comment">// 返回缓存结果</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NaN</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial[<span class="number">1</span>] = <span class="number">1</span>;         <span class="comment">// 初始化缓存</span></span><br><span class="line">factorial[<span class="number">6</span>]              <span class="comment">// =&gt; 720</span></span><br><span class="line">factorial[<span class="number">5</span>]              <span class="comment">// =&gt; 120</span></span><br></pre></td></tr></table></figure>







<h2 id="函数作为命名空间"><a href="#函数作为命名空间" class="headerlink" title="函数作为命名空间"></a>函数作为命名空间</h2><p>在函数体内声明的变量在函数外部不可见，可以利用函数作为临时命名空间</p>
<p>假设有一段 JavaScript 代码，想在多个程序或页面中调用，且这段代码定义了存储中间计算结果的变量，则无法知道多个程序创建的变量是否会跟这段代码冲突，利用函数作为命名空间可以解决</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chunkNamespace</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 要复用的代码</span></span><br><span class="line">    <span class="comment">// 在这里定义的任何变量都是函数的局部变量</span></span><br><span class="line">    <span class="comment">// 不会污染全局命名空间</span></span><br><span class="line">&#125;</span><br><span class="line">chunkNamespace()    <span class="comment">// 需要调用函数</span></span><br></pre></td></tr></table></figure>

<p>也可以在一个表达式中定义并调用匿名函数（也称立即调用函数表达式）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="comment">// 将 chunkNamespace() 函数重写为一个无名表达式</span></span><br><span class="line">   <span class="comment">// 要复用的代码</span></span><br><span class="line">&#125;);    <span class="comment">// 函数定义结束后立即调用</span></span><br></pre></td></tr></table></figure>







<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>JavaScript 使用司法作用域，即函数执行时使用的是定义函数时生效的变量作用域，而不是调用函数时生效的变量作用域</p>
<p>闭包：将函数对象与作用域（即一组绑定）组合起来解析函数变量的机制</p>
<p>闭包在嵌套函数中最为常见，且一个私有变量可以由多个闭包共享</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">conter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        <span class="attr">count</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> n++; &#125;,</span><br><span class="line">        <span class="attr">reset</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; n=<span class="number">0</span>; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = counter(), d = counter();    <span class="comment">// 创建两个计数器</span></span><br><span class="line">c.count()</span><br><span class="line">d.count()</span><br><span class="line">c.reset();          <span class="comment">// reset() 和 count() 方法共享状态</span></span><br><span class="line">c.count()           <span class="comment">// =&gt;0：因为重置了 c</span></span><br></pre></td></tr></table></figure>

<p>上述代码中 <code>counter()</code> 函数返回一个“计数器”对象，有两个方法。每次调用 <code>counter()</code> 都会创建一个新作用域，即 c 和 d 的变量不一样，在一个计数器上调用 <code>count()</code> 或 <code>reset()</code> 不会影响另一个计数器</p>
<p>闭包技术也可以与属性获取方法和设置方法组合使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        <span class="comment">// 属性获取方法，返回递增后的私有计数器值</span></span><br><span class="line">        <span class="keyword">get</span> <span class="title">count</span>() &#123; <span class="keyword">return</span> n++; &#125;,</span><br><span class="line">        <span class="comment">// 属性设置方法，不允许 n 的值减少</span></span><br><span class="line">        <span class="keyword">set</span> <span class="title">count</span>(<span class="params">m</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m &gt; n) n = m;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&quot;count can only be set to a larger value&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>基于闭包技术实现一个通用的共享私有状态的函数，使用闭包的私有属性访问器方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个函数按照指定的名字为对象 o 添加属性访问器方法</span></span><br><span class="line"><span class="comment">// 方法命名为 get&lt;name&gt; 和 set&lt;name&gt;</span></span><br><span class="line"><span class="comment">// 若提供断言函数，则设置方法用它测试自己的函数</span></span><br><span class="line"><span class="comment">// 在存储前先验证，若断言返回 false，则设置方法抛出异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作的值没有保存在对象 o 上，保存在这个函数的一个局部变量中</span></span><br><span class="line"><span class="comment">// 获取方法和设置方法也在函数局部定义，即可以访问这个局部变量</span></span><br><span class="line"><span class="comment">// 即该变量对两个访问器方法是私有的，除了设置方法，没有</span></span><br><span class="line"><span class="comment">// 其他途径可以设置或修改这个变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addPrivateProperty</span>(<span class="params">o, name, predicate</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value;    <span class="comment">// 属性值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取方法简单地返回属性值</span></span><br><span class="line">    o[<span class="string">`get<span class="subst">$&#123;name&#125;</span>`</span>] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> value; &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置方法保存值或在断言失败时抛出异常</span></span><br><span class="line">    o[<span class="string">`set<span class="subst">$&#123;name&#125;</span>`</span>] = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(predicate &amp;&amp; !predicate(v))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`set<span class="subst">$&#123;name&#125;</span>: invalid value <span class="subst">$&#123;v&#125;</span>`</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 addPrivateProperty() 方法</span></span><br><span class="line"><span class="keyword">let</span> o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加属性访问器方法，并确保只能设置字符串值</span></span><br><span class="line">addPrivateProperty(o, <span class="string">&quot;Name&quot;</span>, <span class="function"><span class="params">x</span> =&gt;</span> <span class="keyword">typeof</span> x === <span class="string">&quot;string&quot;</span>);</span><br><span class="line"></span><br><span class="line">o.setName(<span class="string">&quot;Frank&quot;</span>);        <span class="comment">// 设置属性的值</span></span><br><span class="line">o.getName();               <span class="comment">// =&gt; &quot;Frank&quot;</span></span><br><span class="line">o.setName(<span class="number">0</span>);              <span class="comment">// !TypeError：尝试设置一个错误类型的值</span></span><br></pre></td></tr></table></figure>



<h2 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h2><p>函数使用 <code>typeof</code> 操作符返回字符串 <code>function</code>，但函数实际上是一种特殊的对象，因此也有属性和方法，甚至构造函数</p>
<p><strong><code>length</code> 属性</strong></p>
<ul>
<li>函数有一个只读的 <code>length</code> 属性，表示函数的元数，即函数在参数列表中声明的形参个数</li>
<li>剩余形参不包含在 <code>length</code> 属性内</li>
</ul>
<p><strong><code>name</code> 属性</strong></p>
<ul>
<li>函数有一个只读的 <code>name</code> 属性，表示定义函数时使用的名字</li>
<li>若函数是未命名的，表示在第一次创建此函数时赋给该函数的变量名或属性名</li>
<li>主要用于记录调试或排错消息</li>
</ul>
<p><strong><code>prototype</code> 属性</strong></p>
<ul>
<li>除了箭头函数，所有函数都有一个 <code>prototype</code> 属性，这个属性引用原型对象的对象</li>
<li>每个函数都有原型对象</li>
<li>当函数被作为构造函数使用时，新创建的对象从这个原型对象继承属性</li>
</ul>
<p><strong><code>call()</code> 和 <code>apply()</code> 方法</strong></p>
<ul>
<li><p><code>call()</code> 和 <code>apply()</code> 允许间接调用一个函数</p>
</li>
<li><p><code>call()</code> 和 <code>apply()</code> 的第一个参数为要在其上调用这个函数的对象，即函数的调用上下文，在函数体内会成为 <code>this</code> 关键字的值，箭头函数调用这两个方法会忽略第一个参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数 f() 对象 o</span></span><br><span class="line">f.call(o);</span><br><span class="line">f.apply(o);</span><br></pre></td></tr></table></figure></li>
<li><p><code>call()</code> 的后续参数会传给被调用的函数，<code>apply()</code> 传给函数的参数需要以数组的形式提供</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f.call(o, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">f.apply(o, [<span class="number">1</span>,<span class="number">2</span>]);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong><code>bind()</code> 方法</strong></p>
<ul>
<li><p><code>bind()</code> 方法的主要目的是将函数绑定到对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y</span>)</span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>.x + y;&#125;  <span class="comment">// 需要绑定的函数</span></span><br><span class="line"><span class="keyword">let</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span>&#125;;                    <span class="comment">// 要绑定的对象</span></span><br><span class="line"><span class="keyword">let</span> g = f.bind(o);                  <span class="comment">// 调用g(x)会在o上调用f()</span></span><br><span class="line">g(<span class="number">2</span>)                                <span class="comment">// =&gt; 3</span></span><br><span class="line"><span class="keyword">let</span> p = &#123; <span class="attr">x</span>: <span class="number">10</span>, g&#125;;                <span class="comment">// 作为这个对象的方法调用g()</span></span><br><span class="line">p.g(<span class="number">2</span>)                              <span class="comment">// =&gt; 3：g仍然绑定到o，而非p</span></span><br></pre></td></tr></table></figure></li>
<li><p>调用 <code>bind()</code> 最常见的目的是让非箭头函数变得像箭头函数，箭头函数从定义的环境中继承 <code>this</code> 值，且不能被 <code>bind()</code> 覆盖</p>
</li>
<li><p><code>bind()</code> 方法也可以执行“部分应用”（柯里化），即在第一个参数之后传给 <code>bind()</code> 的参数也会随着 <code>this</code> 值一起被绑定</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">x,y</span>) =&gt;</span> x + y;     </span><br><span class="line"><span class="keyword">let</span> succ = sum.bind(<span class="literal">null</span>,<span class="number">1</span>);</span><br><span class="line">succ(<span class="number">2</span>)      <span class="comment">// =&gt; 3：x绑定到1，2会传给参数y</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y,z</span>)</span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>.x + y + z&#125;</span><br><span class="line"><span class="keyword">let</span> g = f.bind(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;, <span class="number">2</span>);      <span class="comment">// 绑定this和y</span></span><br><span class="line">g(<span class="number">3</span>)         <span class="comment">// =&gt; 6：this.x绑定到1，y绑定到2，z是3</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong><code>Function()</code> 构造函数</strong></p>
<ul>
<li><p><code>Function()</code> 构造函数可以接收任意多个字符串参数，其中最后一个参数是函数体的文本</p>
</li>
<li><p>与函数字面量一样，<code>Function()</code> 构造函数创建的也是匿名函数</p>
</li>
<li><p><code>Function()</code> 构造函数允许在运行时动态创建和编译 JavaScript 函数</p>
</li>
<li><p><code>Function()</code> 构造函数创建的函数不使用词法作用域，而是始终编译为如同顶级函数一样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> scope = <span class="string">&quot;global&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constructFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> scope = <span class="string">&quot;local&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;return scope&quot;</span>);    <span class="comment">// 不会捕获局部作用域</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这行代码返回“global”，因为Function()构造函数返回的函数不使用局部作用域</span></span><br><span class="line">constructFunction()()          <span class="comment">// =&gt; &quot;global&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>JavaScript 可以把函数作为对象来操作意味着可以在 JavaScript 中使用函数实编程技巧</p>
<h3 id="使用函数处理数组"><a href="#使用函数处理数组" class="headerlink" title="使用函数处理数组"></a>使用函数处理数组</h3><p>假设有一个数值数组，要求计算平均值和标准差，</p>
<ul>
<li><p>使用非函数式编程风格</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算平均值</span></span><br><span class="line"><span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i++) total += data[i];</span><br><span class="line"><span class="keyword">let</span> mean = total/data.length;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算标准差，计算每个元素相对于平均值偏差的平方</span></span><br><span class="line">total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> deviation = data[i] - mean;</span><br><span class="line">    total += deviation * deviation;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> stddev = <span class="built_in">Math</span>.sqrt(total/(data.length-<span class="number">1</span>));</span><br></pre></td></tr></table></figure></li>
<li><p>使用函数式编程风格</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先定义两个简单的函数</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">x,y</span>) =&gt;</span> x+y;</span><br><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">x</span> =&gt;</span> x*x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用数组方法计算平均值和标准差</span></span><br><span class="line"><span class="keyword">let</span> data = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> mean = data.reduce(sum)/data.length;    <span class="comment">// mean == 3</span></span><br><span class="line"><span class="keyword">let</span> deviations = data.map(<span class="function"><span class="params">x</span> =&gt;</span> x-mean);</span><br><span class="line"><span class="keyword">let</span> stddev = <span class="built_in">Math</span>.sqrt(deviations.map(square).reduce(sum)/(data.length-<span class="number">1</span>));</span><br><span class="line">stddec          <span class="comment">// =&gt; 2</span></span><br></pre></td></tr></table></figure></li>
<li><p>定义方法的函数版</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 map() 和 reduce() 函数</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="function"><span class="keyword">function</span>(<span class="params">a,...args</span>) </span>&#123; <span class="keyword">return</span> a.map(...args);&#125;;</span><br><span class="line"><span class="keyword">const</span> reduce = <span class="function"><span class="keyword">function</span>(<span class="params">a,...args</span>) </span>&#123; <span class="keyword">return</span> a.reduce(...args);&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先定义两个简单的函数</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">x,y</span>) =&gt;</span> x+y;</span><br><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">x</span> =&gt;</span> x*x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用数组方法计算平均值和标准差</span></span><br><span class="line"><span class="keyword">let</span> data = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> mean = reduce(data,sum)/data.length;    </span><br><span class="line"><span class="keyword">let</span> deviations = map(data, <span class="function"><span class="params">x</span> =&gt;</span> x-mean);</span><br><span class="line"><span class="keyword">let</span> stddev = <span class="built_in">Math</span>.sqrt(reduce(map(deviation,square),sum)/(data.length-<span class="number">1</span>));</span><br><span class="line">stddec        </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>高阶函数即操作函数的函数，它接收一个或多个函数作为参数并返回一个新函数</p>
<p>以下的 <code>mapper()</code> 函数接收一个函数参数并返回一个新函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个函数，这个函数接收一个数组并对每个元素应用f</span></span><br><span class="line"><span class="comment">// 返回每个返回值的数组</span></span><br><span class="line"><span class="comment">// 比较这个函数与之前的map() 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapper</span>(<span class="params">f</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">a</span> =&gt;</span> map(a, f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> increment = <span class="function"><span class="params">x</span> =&gt;</span> x+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> incrementAll = mapper(increment);</span><br><span class="line">incrementAll([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])    <span class="comment">// =&gt; [2,3,4]</span></span><br></pre></td></tr></table></figure>

<p>以下这个高阶函数接收两个函数，返回一个新函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个计算f(g(...))的新函数</span></span><br><span class="line"><span class="comment">// 返回的函数h会把它接收的所有参数传给g，</span></span><br><span class="line"><span class="comment">// 再把g的返回值传给f，然后返回f的返回值</span></span><br><span class="line"><span class="comment">// f和g被调用时都使用与h被调用时相同的this值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">f, g</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 这里对f使用call是因为只给它传一个值</span></span><br><span class="line">        <span class="comment">// 对g使用apply是因为正在传一个值的数组</span></span><br><span class="line">        <span class="keyword">return</span> f.call(<span class="built_in">this</span>, g.apply(<span class="built_in">this</span>, args));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">x,y</span>) =&gt;</span> x+y;</span><br><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">x</span> =&gt;</span> x*x;</span><br><span class="line">compose(square, sum)(<span class="number">2</span>,<span class="number">3</span>)    <span class="comment">// =&gt; 25,平方和</span></span><br></pre></td></tr></table></figure>



<h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><p>函数f的 <code>bind()</code> 方法返回一个新函数，这个新函数在指定的上下文中以指定的参数调用f，此时 <code>bind()</code> 方法在左侧部分应用函数，即传给 <code>bind()</code> 的参数会放在原始函数的参数列表的开头</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传给这个函数的参数会传到左侧</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partialLeft</span>(<span class="params">f, ...outerArgs</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...innerArgs</span>)</span>&#123;                  <span class="comment">// 返回这个函数</span></span><br><span class="line">        <span class="keyword">let</span> args = [...outerArgs, ...innerArgs];    <span class="comment">// 构建参数列表</span></span><br><span class="line">        <span class="keyword">return</span> f.apply(<span class="built_in">this</span>, args);                 <span class="comment">// 通过它调用f</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传给这个函数的参数会传到右侧</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partialRight</span>(<span class="params">f, ...outerArgs</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...innerArgs</span>)</span>&#123;                  <span class="comment">// 返回这个函数</span></span><br><span class="line">        <span class="keyword">let</span> args = [...innerArgs, ...outerArgs];    <span class="comment">// 构建参数列表</span></span><br><span class="line">        <span class="keyword">return</span> f.apply(<span class="built_in">this</span>, args);                 <span class="comment">// 通过它调用f</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数的参数列表作为一个模板，这个参数列表中的 undefined值</span></span><br><span class="line"><span class="comment">// 会被来自内部参数的值填充</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">f, ...outerArgs</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...innerArgs</span>)</span>&#123;   </span><br><span class="line">        <span class="keyword">let</span> args = [...outerArgs];    	<span class="comment">// 外部参数模板的局部副本</span></span><br><span class="line">        <span class="keyword">let</span> innerIndex = <span class="number">0</span>;             <span class="comment">// 下一个是哪个内部函数</span></span><br><span class="line">        <span class="comment">// 循环遍历 args，用内部参数填充 undefined 值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; args.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(args[i] === <span class="literal">undefined</span>) args[i] = innerArgs[innerIndex++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 现在把剩余的内部参数加进去</span></span><br><span class="line">        args.push(...innerArgs.slice(innerIndex));</span><br><span class="line">        <span class="keyword">return</span> f.apply(<span class="built_in">this</span>, args);   </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是有3个参数的函数</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">x,y,z</span>) </span>&#123; <span class="keyword">return</span> x * (y -z);&#125;;</span><br><span class="line"><span class="comment">// 以下3个部分应用的区别</span></span><br><span class="line">partialLeft(f, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>)            <span class="comment">// =&gt; -2：绑定第一个参数：2 * (3 - 4)</span></span><br><span class="line">partialRight(f, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>)           <span class="comment">// =&gt;  6：绑定最后一个参数：3 * (4 - 2)</span></span><br><span class="line">partial(f, <span class="literal">undefined</span>, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>)     <span class="comment">// =&gt; -6：绑定中间的参数：3 * (2 - 4)</span></span><br></pre></td></tr></table></figure>

<p>以上的部分应用函数允许在已经定义的函数基础上轻松定义其他函数，如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> increment = partialLeft(sum, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> cuberoot = partialRight(<span class="built_in">Math</span>.pow, <span class="number">1</span>/<span class="number">3</span>);</span><br><span class="line">cuberoot(increment(<span class="number">26</span>))            <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure>

<p>也可以将部分应用的函数与其他高阶函数组合，如通过组合与部分应用定义 <code>not()</code> 函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> not = partialLeft(compose, <span class="function"><span class="params">x</span> =&gt;</span> !x);</span><br><span class="line"><span class="keyword">const</span> even = <span class="function"><span class="params">x</span> =&gt;</span> x % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> odd = not(even);</span><br><span class="line"><span class="keyword">const</span> isNumber = not(<span class="built_in">isNaN</span>);</span><br><span class="line">odd(<span class="number">3</span>) &amp;&amp; isNumber(<span class="number">2</span>)    <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>



<h3 id="函数记忆"><a href="#函数记忆" class="headerlink" title="函数记忆"></a>函数记忆</h3><p>在函数式编程中，缓存称为函数记忆</p>
<p>以下代码展示了高阶函数 <code>memoize()</code> 可以接收一个函数参数，然后返回这个函数的记忆版</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回f的记忆版</span></span><br><span class="line"><span class="comment">// 只适用于f的参数都有完全不同的字符串表示的情况</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memoize</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> cache =<span class="keyword">new</span> <span class="built_in">Map</span>();    <span class="comment">// cache保存在这个闭包中</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建参数的字符串版，以用作缓存键</span></span><br><span class="line">        <span class="keyword">let</span> key = args.length + args.join(<span class="string">&quot;+&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(cache.has(key))&#123;</span><br><span class="line">            <span class="keyword">return</span> cache.get(key);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> result = f.apply(<span class="built_in">this</span>, args);</span><br><span class="line">            cache.set(key, result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 <code>memoize()</code> 函数创建一个新对象作为缓存使用，并将这个对象赋值给一个局部变量，从而让其（在闭包中）成为被返回的函数的私有变量。返回的函数将其参数数组转换为字符串，并使用该字符串作为缓存对象的属性。若缓存存在某个值，直接返回该值；否则，调用指定函数计算这些参数值，然后缓存这个值，最后返回这个值，以为为使用上述函数实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用欧几里得算法返回两个整数的最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gcd</span>(<span class="params">a,b</span>)</span>&#123;        <span class="comment">// 省略了对a和b的类型检查</span></span><br><span class="line">    <span class="keyword">if</span>(a &lt; b)&#123;            <span class="comment">// 开始时保证a ≥ b</span></span><br><span class="line">        [a, b] = [b, a];  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(b !== <span class="number">0</span>)&#123;       <span class="comment">// 欧几里得算法</span></span><br><span class="line">        [a, b] = [b, a%b];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gcdmemo = memoize(gcd);</span><br><span class="line">gcdmemo(<span class="number">85</span>, <span class="number">187</span>)          <span class="comment">// =&gt; 17</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在编写记忆的递归函数时，通常希望递归记忆版，而非原始版</span></span><br><span class="line"><span class="keyword">const</span> factorial = memoize(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &lt;= <span class="number">1</span>) ? <span class="number">1</span> : n * factorial(n-<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">factorial(<span class="number">5</span>)              <span class="comment">// =&gt; 120：也为4、3、2和1缓存了值</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端学习</tag>
      </tags>
  </entry>
  <entry>
    <title>JS类</title>
    <url>/2021/10/23/JS/JS%E7%B1%BB/</url>
    <content><![CDATA[<p>当多个对象经常需要共享一个属性时，可以为这些对象定义一个类，这个类的成员或实例，各自拥有属性来保存或定义自己的状态</p>
<p>JavaScript 中，类使用基于原型的继承</p>
<p>若两个对象继承同一个原型，通常（但不必定）意味着它们是通过同一个构造函数或工厂函数创建和初始化的</p>
<span id="more"></span>



<h2 id="类和原型"><a href="#类和原型" class="headerlink" title="类和原型"></a>类和原型</h2><p>JavaScript 中，类意味着一组对象从同一个原型对象继承属性，即原型对象是类的核心特征</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个简单的 JavaScript 类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个工厂函数返回一个新范围对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">range</span>(<span class="params"><span class="keyword">from</span>, to</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 使用Object,create()创建一个对象，继承下面定义的原型对象</span></span><br><span class="line">    <span class="comment">// 这个原型对象保存为这个函数的一个属性，为所有范围对象定义共享方法（行为）</span></span><br><span class="line">    <span class="keyword">let</span> r = <span class="built_in">Object</span>.create(range.methods);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存新范围对象的起点和终点（状态）</span></span><br><span class="line">    <span class="comment">// 这些属性不是继承的，是当前对象独有的</span></span><br><span class="line">    r.from = <span class="keyword">from</span>;</span><br><span class="line">    r.to = to;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最后返回新对象</span></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个原型对象定义由所有范围对象继承的方法</span></span><br><span class="line">range.methods = &#123;</span><br><span class="line">    <span class="comment">// 若x在范围内则返回true，否则返回false</span></span><br><span class="line">    <span class="comment">// 这个方法适用于文本、日期和数值范围</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">includes</span>(<span class="params">x</span>)</span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>.from &lt;= x &amp;&amp; x &lt;= <span class="built_in">this</span>.to;&#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个生成器函数让这个类的实例可迭代</span></span><br><span class="line">    <span class="comment">// 只适用于数值范围</span></span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> x = <span class="built_in">Math</span>.ceil(<span class="built_in">this</span>.from); x &lt;= <span class="built_in">this</span>.to; x++) <span class="keyword">yield</span> x;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回范围的字符串表示</span></span><br><span class="line">    <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + <span class="built_in">this</span>.from + <span class="string">&quot;...&quot;</span> + <span class="built_in">this</span>.to + <span class="string">&quot;)&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用范围对象的实例</span></span><br><span class="line"><span class="keyword">let</span> r = range(<span class="number">1</span>,<span class="number">3</span>);    <span class="comment">// 创建一个范围对象</span></span><br><span class="line">r.includes(<span class="number">2</span>);         <span class="comment">// =&gt; true：2在范围内</span></span><br><span class="line">r.toString();          <span class="comment">// =&gt; &quot;(1...3)&quot;</span></span><br><span class="line">[...r];                <span class="comment">// =&gt; [1, 2, 3];通过迭代器转换为数组</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这段代码定义了一个工厂函数 <code>range()</code>，用于创建新的 <code>Range</code> 对象</li>
<li>使用 <code>range()</code> 函数的 <code>methods</code> 属性保存定义这个类的原型对象</li>
<li><code>range()</code> 函数为每个 <code>Range</code> 对象定义 <code>from</code> 和 <code>to</code> 属性，这两个属性是非共享、非继承属性，定义每个范围对象独有的状态</li>
<li>原型的方法中有一个是计算的名字 <code>Symbol.iterator</code>，即为 <code>Range</code> 对象定义一个迭代器。方法前有一个星号 * ，表示是一个生成器函数</li>
<li>定义在 <code>range.methods()</code> 中的共享方法都会用到在 <code>range()</code> 工厂函数中初始化的 <code>from</code> 和 <code>to</code> 属性，通过 <code>this</code> 关键字引用调用它们的对象</li>
</ul>
<h2 id="类和构造函数"><a href="#类和构造函数" class="headerlink" title="类和构造函数"></a>类和构造函数</h2><p>构造函数是一种专门用于初始化新对象的函数</p>
<p>构造函数要使用 <code>new</code> 关键字调用，使用 <code>new</code> 调用构造函数会自动创建新对象，因此构造函数本身只需初始化新对象的状态</p>
<p>构造函数调用的关键在于构造函数的 <code>prototype</code> 属性将被用作新对象的原型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用构造函数的Range类（ES6之前的老代码）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化新Range对象的构造函数</span></span><br><span class="line"><span class="comment">// 不创建或返回对象，只初始化this</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Range</span>(<span class="params"><span class="keyword">from</span>, to</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 保存新范围对象的起点和终点（状态）</span></span><br><span class="line">    <span class="comment">// 这些属性不是继承的，是当前对象独有的</span></span><br><span class="line">    <span class="built_in">this</span>.from = <span class="keyword">from</span>;</span><br><span class="line">    <span class="built_in">this</span>.to = to;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有Range对象都继承这个对象</span></span><br><span class="line"><span class="comment">// 注意这个属性必须命名为prototype</span></span><br><span class="line">Range.prototype = &#123;</span><br><span class="line">    <span class="comment">// 若x在范围内则返回true，否则返回false</span></span><br><span class="line">    <span class="comment">// 这个方法适用于文本、日期和数值范围</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">includes</span>(<span class="params">x</span>)</span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>.from &lt;= x &amp;&amp; x &lt;= <span class="built_in">this</span>.to;&#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个生成器函数让这个类的实例可迭代</span></span><br><span class="line">    <span class="comment">// 只适用于数值范围</span></span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> x = <span class="built_in">Math</span>.ceil(<span class="built_in">this</span>.from); x &lt;= <span class="built_in">this</span>.to; x++) <span class="keyword">yield</span> x;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回范围的字符串表示</span></span><br><span class="line">    <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + <span class="built_in">this</span>.from + <span class="string">&quot;...&quot;</span> + <span class="built_in">this</span>.to + <span class="string">&quot;)&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用这个新Range类的实例</span></span><br><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> Range(<span class="number">1</span>,<span class="number">3</span>);    <span class="comment">// 创建一个Range对象</span></span><br><span class="line">r.includes(<span class="number">2</span>);             <span class="comment">// =&gt; true：2在范围内</span></span><br><span class="line">r.toString();              <span class="comment">// =&gt; &quot;(1...3)&quot;</span></span><br><span class="line">[...r];                    <span class="comment">// =&gt; [1, 2, 3];通过迭代器转换为数组</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>new.target</code> 表达式用于判断函数是否作为构造函数被调用</p>
<p>若 <code>new.target</code> 是 <code>undefined</code>，那么包含函数就是作为普通函数调用的，没有使用 <code>new</code> 关键字</p>
<p>只适用于以老方式定义的构造函数，使用 <code>class</code> 关键字创建的类不允许不适用 <code>new</code> 调用它们的构造函数</p>
</blockquote>
<p>当且仅当两个对象继承同一个原型对象是，它们才是同一个类的实例</p>
<p>使用 <code>instanceof</code> 操作符测试类的成员关系</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">r <span class="keyword">instanceof</span> Range         <span class="comment">// =&gt; true：r继承了 Range.prototype</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>isPrototypeOf()</code> 方法测试某个对象原型链中是否包含指定原型（用于定义类时未定义构造函数）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">range.methods.isPrototypeOf(r);     <span class="comment">// range.methods 是r的原型对象</span></span><br></pre></td></tr></table></figure>



<p><strong><code>constructor</code> 属性</strong></p>
<p>每个普通 JavaScript 函数自动拥有一个 <code>prototype</code> 属性，这个属性的值是一个对象，有一个不可枚举的 <code>constructor</code> 属性</p>
<p>这个 <code>constructor</code> 属性的值就是该函数对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;      <span class="comment">// 一个函数对象</span></span><br><span class="line"><span class="keyword">let</span> p = F.prototype;       <span class="comment">// 一个与F关联的原型对象</span></span><br><span class="line"><span class="keyword">let</span> c = p.constructor;     <span class="comment">// 与原型关联的函数</span></span><br><span class="line">c === F                    <span class="comment">// =&gt; true：对任何F，F.prototype.constructor === F</span></span><br></pre></td></tr></table></figure>



<p>如下图，构造函数、其原型对象、原型对构造函数的反向引用，以及通过该构造函数创建的实例之间的关系</p>
<p><img src="/2021/10/23/JS/JS%E7%B1%BB/image-20211023134201115.png" alt="image-20211023134201115"></p>
<p>上图使用 Range() 构造函数，没有 <code>constructor</code> 属性，可以显示为原型添加</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Range.prototype = &#123;</span><br><span class="line">    <span class="attr">constructor</span>: Range,     <span class="comment">// 显示设置反向引用constructor</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 方法定义 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="Class-关键字定义类"><a href="#Class-关键字定义类" class="headerlink" title="Class 关键字定义类"></a>Class 关键字定义类</h2><p>ES6 引入 <code>class</code> 关键字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用class重写的Range类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Range</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">from</span>, to</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 保存新范围对象的起点和终点（状态）</span></span><br><span class="line">        <span class="comment">// 这些属性不是继承的，是当前对象独有的</span></span><br><span class="line">        <span class="built_in">this</span>.from = <span class="keyword">from</span>;</span><br><span class="line">        <span class="built_in">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 若x在范围内则返回true，否则返回false</span></span><br><span class="line">    <span class="comment">// 这个方法适用于文本、日期和数值范围</span></span><br><span class="line">    <span class="function"><span class="title">includes</span>(<span class="params">x</span>)</span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>.from &lt;= x &amp;&amp; x &lt;= <span class="built_in">this</span>.to;&#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个生成器函数让这个类的实例可迭代</span></span><br><span class="line">    <span class="comment">// 只适用于数值范围</span></span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> x = <span class="built_in">Math</span>.ceil(<span class="built_in">this</span>.from); x &lt;= <span class="built_in">this</span>.to; x++) <span class="keyword">yield</span> x;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回范围的字符串表示</span></span><br><span class="line">    <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="string">`(<span class="subst">$&#123;<span class="built_in">this</span>.<span class="keyword">from</span>&#125;</span>...<span class="subst">$&#123;<span class="built_in">this</span>.to&#125;</span>)`</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用这个新Range类的实例</span></span><br><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> Range(<span class="number">1</span>,<span class="number">3</span>);    <span class="comment">// 创建一个Range对象</span></span><br><span class="line">r.includes(<span class="number">2</span>);             <span class="comment">// =&gt; true：2在范围内</span></span><br><span class="line">r.toString();              <span class="comment">// =&gt; &quot;(1...3)&quot;</span></span><br><span class="line">[...r];                    <span class="comment">// =&gt; [1, 2, 3];通过迭代器转换为数组</span></span><br></pre></td></tr></table></figure>



<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>在 <code>class</code> 体中，把 <code>static</code> 关键字放在方法声明前可定义静态方法</p>
<p>静态方法是作为构造函数而非原型对象的属性定义的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在上述代码中添加</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">parse</span>(<span class="params">s</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> matches = s.match(<span class="regexp">/^\((\d+)\.\.\.(\d+)\)$/</span>);</span><br><span class="line">    <span class="keyword">if</span>(!matches)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`Cannot parse Range from &quot;<span class="subst">$&#123;s&#125;</span>&quot;.`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Range(<span class="built_in">parseInt</span>(matches[<span class="number">1</span>]), <span class="built_in">parseInt</span>(matches[<span class="number">2</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码定义的方法是 <code>Range.parse()</code>，而非 <code>Range.prototype.parse()</code>，必须通过构造函数而非实例调用它</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">let r = Range.parse(<span class="string">&#x27;(1...10)&#x27;</span>);    <span class="regexp">//</span> 返回一个新Range对象</span><br><span class="line">r.prase(<span class="string">&#x27;(1...10)&#x27;</span>);                <span class="regexp">//</span> TypeError：r.parse不是一个函数</span><br></pre></td></tr></table></figure>



<h3 id="示例：复数类"><a href="#示例：复数类" class="headerlink" title="示例：复数类"></a>示例：复数类</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个Complex类的实例代表复数</span></span><br><span class="line"><span class="comment"> * 复数是一个实数和一个虚数之和</span></span><br><span class="line"><span class="comment"> * 虚数是-1的平方根</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在这种类字段声明标准化后，可以使用</span></span><br><span class="line">    <span class="comment">// 如下方式声明私有字段保存变量</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// #r = 0;</span></span><br><span class="line">    <span class="comment">// #i = 0;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个构造函数定义了它需要在每个实力上创建的实例属性</span></span><br><span class="line">    <span class="comment">// 这两个字段保存复数的实数和虚数部分，即对象的状态</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">real, imaginary</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.r = real;            <span class="comment">// 实数部分</span></span><br><span class="line">        <span class="built_in">this</span>.i = imaginary;       <span class="comment">// 虚数部分</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 两个实例方法，用于复数的加法和乘法</span></span><br><span class="line">    <span class="comment">// 若c和d是这个类两个实例，可以写c.plus(d)或d.times(c)</span></span><br><span class="line">    <span class="function"><span class="title">plus</span>(<span class="params">that</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Complex(<span class="built_in">this</span>.r + that.r, <span class="built_in">this</span>.i + that.i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">times</span>(<span class="params">that</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Complex(<span class="built_in">this</span>.r * that.r - <span class="built_in">this</span>.i * that.i,</span><br><span class="line">                           <span class="built_in">this</span>.r * that.i + <span class="built_in">this</span>.i * that.r);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 两个复数计算方法的静态版本</span></span><br><span class="line">    <span class="comment">// Complex.sum(c,d)和Complex.product(c,d)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">sum</span>(<span class="params">c, d</span>)</span> &#123; <span class="keyword">return</span> c.plus(d); &#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">product</span>(<span class="params">c, d</span>)</span> &#123; <span class="keyword">return</span> c.times(d); &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用获取函数定义的实例方法，因此可以像使用字段一样使用</span></span><br><span class="line">    <span class="comment">// 若使用是私有字段this.#r和this.#i，那下面的获取方法可以使用</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title">real</span>() &#123; <span class="keyword">return</span> <span class="built_in">this</span>.r; &#125;;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">imaginary</span>() &#123; <span class="keyword">return</span> <span class="built_in">this</span>,i; &#125;;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">magintude</span>() &#123; <span class="keyword">return</span> <span class="built_in">Math</span>.hypot(<span class="built_in">this</span>.r, <span class="built_in">this</span>,i); &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每个类都应有一个toString()方法</span></span><br><span class="line">    <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> <span class="string">`&#123;<span class="subst">$&#123;<span class="built_in">this</span>.r&#125;</span>,<span class="subst">$&#123;<span class="built_in">this</span>.i&#125;</span>&#125;`</span>; &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试类的两个实例是否表示相同的值</span></span><br><span class="line">    <span class="function"><span class="title">equals</span>(<span class="params">that</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> that <span class="keyword">instanceof</span> Complex &amp;&amp;</span><br><span class="line">            <span class="built_in">this</span>.r === that.r &amp;&amp;</span><br><span class="line">            <span class="built_in">this</span>.i === that.i;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 若类使用静态字段，则可以如下定义一个常量Complex.ZERO</span></span><br><span class="line">    <span class="comment">// static ZERO = new Complex(0,0);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义几个保存预定义复数的类字段</span></span><br><span class="line">Complex.ZERO = <span class="keyword">new</span> Complex(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">Complex.ONE = <span class="keyword">new</span> Complex(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">Complex.I = <span class="keyword">new</span> Complex(<span class="number">0</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>使用上述的构造函数、实例字段、实例方法、类字段和类方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Complex(<span class="number">2</span>, <span class="number">3</span>);      <span class="comment">// 通过构造函数创建一个新对象</span></span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> Complex(c.i, c.r);  <span class="comment">// 使用c的实例字段</span></span><br><span class="line">c.plus(d).toString()            <span class="comment">// =&gt; &quot;&#123;5,5&#125;&quot;;使用实例方法</span></span><br><span class="line">c.magnitude                     <span class="comment">// =&gt; Math.hypot(2,3);使用获取函数</span></span><br><span class="line">Complex.product(c, d)           <span class="comment">// =&gt; new Complex(0, 13);使用静态方法</span></span><br><span class="line">Complex.ZERO.toString()         <span class="comment">// =&gt; &quot;&#123;0,0&#125;&quot;;使用静态属性</span></span><br></pre></td></tr></table></figure>



<h3 id="为已有类添加方法"><a href="#为已有类添加方法" class="headerlink" title="为已有类添加方法"></a>为已有类添加方法</h3><p>JavaScript 基于原型的继承机制是动态的，即对象从原型继承属性，修改原型属性，已创建的对象继承修改后的原型属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给复数类添加计算共轭复数的方法</span></span><br><span class="line">Complex.prototype.conj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Complex(<span class="built_in">this</span>.r, -<span class="built_in">this</span>.i); &#125;;</span><br></pre></td></tr></table></figure>

<p>内置 JavaScript 类的原型对象也可以添加新属性，在旧版中添加新语言特性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果字符串上没有定义startsWith()方法</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">String</span>.prototype.startsWith)&#123;</span><br><span class="line">    <span class="comment">// ...使用已有的indexOf()方法实现一个</span></span><br><span class="line">    <span class="built_in">String</span>.prototype.startsWith = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.indexOf(s) === <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给内置类型的原型添加方法通常被认为是不好的做法，若 JavaScript 以后的新版本定义了同名方法，会导致兼容性和困惑问题</p>
<h2 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h2><p>面向对象编程中，类可以继承另一个类</p>
<h3 id="子类与原型"><a href="#子类与原型" class="headerlink" title="子类与原型"></a>子类与原型</h3><p>ES6 之前的旧方式定义子类</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Range类的子类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Span</span>(<span class="params">start, span</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(span &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">this</span>.from = start;</span><br><span class="line">        <span class="built_in">this</span>.to = start + span;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.to = start;</span><br><span class="line">        <span class="built_in">this</span>.from = start +span;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保Span的原型继承Range的原型</span></span><br><span class="line">Span.prototype = <span class="built_in">Object</span>.create(Range.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若不想继承Range.prototype.constructor，定义自己的constructor属性</span></span><br><span class="line">Span.prototype.constructor = Span;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过定义自己的toString()方法，Span覆盖从Range继承的toString()方法</span></span><br><span class="line">Span.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`(<span class="subst">$&#123;<span class="built_in">this</span>.<span class="keyword">from</span>&#125;</span>...+<span class="subst">$&#123;<span class="built_in">this</span>.to = <span class="built_in">this</span>.<span class="keyword">from</span>&#125;</span>)`</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="ES6-定义子类"><a href="#ES6-定义子类" class="headerlink" title="ES6 定义子类"></a>ES6 定义子类</h3><p>在 ES6 及之后，继承父类可以通过在类声明中加上一个 <code>extends</code> 子句，对内置类也可以</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Map检查键和值类型的子类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TypedMap</span> <span class="keyword">extends</span> <span class="title">Map</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">keyType, valueType, entries</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 若指定了条目，检查类型</span></span><br><span class="line">        <span class="keyword">if</span>(entries)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> [k, v] <span class="keyword">of</span> entries)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">typeof</span> k !== keyType || <span class="keyword">typeof</span> v !== valueType)&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`Wrong type for entry [<span class="subst">$&#123;k&#125;</span>, <span class="subst">$&#123;v&#125;</span>]`</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用（通过类型检查的）初始化条目初始化父类</span></span><br><span class="line">        <span class="built_in">super</span>(entries);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化子类，保存键和值的类型，后面set()方法要使用</span></span><br><span class="line">        <span class="built_in">this</span>.keyType = keyType;</span><br><span class="line">        <span class="built_in">this</span>.valueType = valueType;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重定义set()方法，为所有新增映射条目 添加类型检查逻辑</span></span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">key, value</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 若键或值得类型不对抛出错误</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.keyType &amp;&amp; <span class="keyword">typeof</span> key !== <span class="built_in">this</span>.keyType)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> is not of type <span class="subst">$&#123;<span class="built_in">this</span>.keyType&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.valueType &amp;&amp; <span class="keyword">typeof</span> value !== <span class="built_in">this</span>.valueType)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`<span class="subst">$&#123;value&#125;</span> is not of type <span class="subst">$&#123;<span class="built_in">this</span>.valueType&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 若类型正确，调用超类的set()方法为映射添加条目，同时返回父类方法返回的值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.set(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上这个类可以使用私有字段，防止用户修改 <code>keyType</code> 和 <code>valueType</code> 属性，绕过类型检查，可以改为 <code>#keyType</code> 和 <code>#valueType</code> </p>
<p>在构造函数中使用 <code>super()</code>，需了解</p>
<ul>
<li>使用 <code>extends</code> 关键字定义类，这个类的构造函数必须使用 <code>super()</code> 调用父类构造函数</li>
<li>没有在子类中定义构造函数，解释器会自动创建，这个隐式定义的构造函数会获取传给他的值，再将这些值传给 <code>super()</code></li>
<li>在通过 <code>super()</code> 调用父类构造函数之前，不能在构造函数中使用 <code>this</code> ，确保父类先于子类初始化</li>
</ul>
<h3 id="委托非继承"><a href="#委托非继承" class="headerlink" title="委托非继承"></a>委托非继承</h3><p>在 OOP 中，在类中创建另一个类的实例，并在需要时委托该实例去达到要求更加方便、灵活。</p>
<p>这种委托策略通常称为“组合”（composition），OOP 的一个准则：能组合不继承（favor composition over inheritance）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过委托实现的类似Set的类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个类似Set的类，但会记录值被添加的次数，可以像使用Set一样</span></span><br><span class="line"><span class="comment"> * 调用add()和remove()，调用count()获取某个值已经被添加多少次</span></span><br><span class="line"><span class="comment"> * 默认迭代器回送至少被添加过1次的值，若想迭代[value, count]对，使用entries()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Histogram</span></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化只涉及创建一个要委托的Map对象</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; <span class="built_in">this</span>.map = <span class="keyword">new</span> <span class="built_in">Map</span>(); &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对给定的键，次数就是映射中的值，若映射中不存在这个键，则为0</span></span><br><span class="line">    <span class="function"><span class="title">count</span>(<span class="params">key</span>)</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.map.get(key) || <span class="number">0</span>; &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个类似Set的方法has()在次数大于0时返回true</span></span><br><span class="line">    <span class="function"><span class="title">has</span>(<span class="params">key</span>)</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.count(key) &lt; <span class="number">0</span>; &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 直方图的大小就是映射中条目的数量</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title">size</span>() &#123; <span class="keyword">return</span> <span class="built_in">this</span>.map.size; &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 若要添加一个键，只需递增其在映射中的次数</span></span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">key</span>)</span> &#123; <span class="built_in">this</span>.map.set(key, <span class="built_in">this</span>.count(key) + <span class="number">1</span>); &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除键需在次数为0时从映射中删除相应键</span></span><br><span class="line">    <span class="function"><span class="title">delete</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="built_in">this</span>.count(key);</span><br><span class="line">        <span class="keyword">if</span>(count === <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.map.delete(key);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.map.set(key, count -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 迭代直方图就是返回映射中存储的键</span></span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123; <span class="keyword">return</span> <span class="built_in">this</span>.map.keys(); &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他迭代器方法直接委托给映射对象</span></span><br><span class="line">    <span class="function"><span class="title">keys</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.map.keys(); &#125;;</span><br><span class="line">    <span class="function"><span class="title">values</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.map.values(); &#125;;</span><br><span class="line">    <span class="function"><span class="title">entries</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.map.entries(); &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Histogram()</code> 构造函数只创建了一个 Map 对象，这个类的方法都委托给了相应的映射方法，实现起来简单</p>
<h3 id="类层次与抽象类"><a href="#类层次与抽象类" class="headerlink" title="类层次与抽象类"></a>类层次与抽象类</h3><p>当存在多级子类的情况，使用继承而不是组合</p>
<p>JavaScript 可以定义抽象类，作为一组相关子类的公共父类，JavaScript 官方没有正式定义抽象方法或抽象类的语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象与具体的集合类层次</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractSet类只定义一个抽象方法has()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractSet</span></span>&#123;</span><br><span class="line">    <span class="comment">// 抛出错误，强制子类必须定义这个方法的可用版本</span></span><br><span class="line">    <span class="function"><span class="title">has</span>(<span class="params">x</span>)</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Abstract method&quot;</span>); &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * NotSet是AbstractSet的一个具体子类，这个集合的成员是不属于其他集合的任何值</span></span><br><span class="line"><span class="comment"> * 因为使用另一个集合定义，所以它不可写；因为有无限个成员，所以不可枚举</span></span><br><span class="line"><span class="comment"> * 这个类只支持检测成员关系和使用数学符号把集合转换为字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotSet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">set</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.set = set;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现继承的抽象方法</span></span><br><span class="line">    <span class="function"><span class="title">has</span>(<span class="params">x</span>)</span> &#123; <span class="keyword">return</span> !<span class="built_in">this</span>.set.has(x); &#125;</span><br><span class="line">    <span class="comment">// 同时覆盖Object方法</span></span><br><span class="line">    <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> <span class="string">`x | x \u2209 <span class="subst">$&#123;<span class="built_in">this</span>.set.toString()&#125;</span> &#125;`</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RangeSet是AbstractSet的一个具体子类</span></span><br><span class="line"><span class="comment"> * 这个集合的成员是介于from和to（含二者）之间的所有z</span></span><br><span class="line"><span class="comment"> * 因为使用另一个集合定义，所以它不可写；因为有无限个成员，所以不可枚举</span></span><br><span class="line"><span class="comment"> * 这个类只支持检测成员关系和使用数学符号把集合转换为字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangeSet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">from</span>, to</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.from = <span class="keyword">from</span>;</span><br><span class="line">        <span class="built_in">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">has</span>(<span class="params">x</span>)</span> &#123; <span class="keyword">return</span> x &gt;= <span class="built_in">this</span>.from &amp;&amp; x &lt;= <span class="built_in">this</span>.to; &#125;</span><br><span class="line">    <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> <span class="string">`&#123; x | <span class="subst">$&#123;<span class="built_in">this</span>.<span class="keyword">from</span>&#125;</span> ≤ x ≤ <span class="subst">$&#123;<span class="built_in">this</span>.to&#125;</span> &#125;`</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * AbstractEnumerableSet是AbstractSet的一个抽象子类</span></span><br><span class="line"><span class="comment"> * 这个抽象类定义了一个抽象的获取方法，返回集合的大小，并且定义了一个抽象迭代器</span></span><br><span class="line"><span class="comment"> * 在此基础上实现了具体的isEmpty()、toString()和equals()方法</span></span><br><span class="line"><span class="comment"> * 实现这个迭代器、大小获取方法以及（继承的）has()方法的子类无偿获得这些具体方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractEnumerableSet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span></span>&#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">size</span>() &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Abstract method&quot;</span>); &#125;</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]()&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Abstract method&quot;</span>); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.size === <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> <span class="string">`&#123;<span class="subst">$&#123;<span class="built_in">Array</span>.<span class="keyword">from</span>(<span class="built_in">this</span>).join(<span class="string">&quot;, &quot;</span>)&#125;</span>&#125;`</span>; &#125;</span><br><span class="line">    <span class="function"><span class="title">equals</span>(<span class="params">set</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 若另一个集合不是AbstractEnumerableSet，那肯定不等于当前集合</span></span><br><span class="line">        <span class="keyword">if</span>(!(set <span class="keyword">instanceof</span> AbstractEnumerableSet)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 若两个集合大小不一样，则它们也不相等</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.size !== set.size) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 循环检查集合的元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> element <span class="keyword">of</span> <span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="comment">// 只要有一个元素不在另一个集合中，就不相等</span></span><br><span class="line">            <span class="keyword">if</span>(!set.has(element)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 元素匹配，两个集合相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SingletonSet是AbstractEnumerableSet的一个具体子类</span></span><br><span class="line"><span class="comment"> * 单体集合是只有一个成员的只读集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonSet</span> <span class="keyword">extends</span> <span class="title">AbstractEnumerableSet</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">member</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.member = member;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现3个抽象方法，同时继承基于这3个方法实现的isEmpty()、toString()和equals()</span></span><br><span class="line">    <span class="function"><span class="title">has</span>(<span class="params">x</span>)</span> &#123; <span class="keyword">return</span> x === <span class="built_in">this</span>.member; &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">size</span>() &#123;<span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123; <span class="keyword">yield</span> <span class="built_in">this</span>.member; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * AbstractWritableSet是AbstractEnumerableSet的一个抽象子类</span></span><br><span class="line"><span class="comment"> * 这个抽象类定义了抽象方法insert()和remove()，分别用于插入和删除个别集合元素</span></span><br><span class="line"><span class="comment"> * 在此基础上实现了具体的add()、subtract()和intersect()方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractWritableSet</span> <span class="keyword">extends</span> <span class="title">AbstractEnumerableSet</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">insert</span>(<span class="params">x</span>)</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Abstract method&quot;</span>); &#125;</span><br><span class="line">    <span class="function"><span class="title">remove</span>(<span class="params">x</span>)</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Abstract method&quot;</span>); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">set</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> element <span class="keyword">of</span> set)&#123;</span><br><span class="line">            <span class="built_in">this</span>.insert(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">subtract</span>(<span class="params">set</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> element <span class="keyword">of</span> set)&#123;</span><br><span class="line">            <span class="built_in">this</span>.remove(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">intersect</span>(<span class="params">set</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> element <span class="keyword">of</span> set)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.has(element))&#123;</span><br><span class="line">                <span class="built_in">this</span>.remove(element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * BitSet是AbstractWritableSet的一个具体子类</span></span><br><span class="line"><span class="comment"> * 这个类是高效的固定大小集合的实现，用于元素为小于某个最大值的非负整数集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BitSet</span> <span class="keyword">extends</span> <span class="title">AbstractWritableSet</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">max</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.max = max;    <span class="comment">// 可存储的最大整数</span></span><br><span class="line">        <span class="built_in">this</span>.n = <span class="number">0</span>;        <span class="comment">// 集合中整数的个数</span></span><br><span class="line">        <span class="built_in">this</span>.numBytes = <span class="built_in">Math</span>.floor(max / <span class="number">8</span>) + <span class="number">1</span>;     <span class="comment">// 需要多少字节</span></span><br><span class="line">        <span class="built_in">this</span>.data = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="built_in">this</span>.numBytes); <span class="comment">// 实际的字节</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内部方法，检测一个值是否为当前集合的合法成员</span></span><br><span class="line">    <span class="function"><span class="title">_valid</span>(<span class="params">x</span>)</span> &#123; <span class="keyword">return</span> <span class="built_in">Number</span>.isInteger(x) &amp;&amp; x &gt;= <span class="number">0</span> &amp;&amp; x &lt;= <span class="built_in">this</span>.max; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试数据数组中指定字节的指定位是否有值，返回true或false</span></span><br><span class="line">    <span class="function"><span class="title">_has</span>(<span class="params">byte, bit</span>)</span> &#123; <span class="keyword">return</span> (<span class="built_in">this</span>.data[byte] &amp; BitSet.bits[bit]) !== <span class="number">0</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断x是否在BitSet中</span></span><br><span class="line">    <span class="function"><span class="title">has</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>._valid(x))&#123;</span><br><span class="line">            <span class="keyword">let</span> byte = <span class="built_in">Math</span>.floor(x / <span class="number">8</span>);</span><br><span class="line">            <span class="keyword">let</span> bit = x % <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._has(byte, bit);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将x插入当前BitSet</span></span><br><span class="line">    <span class="function"><span class="title">insert</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>._valid(x))&#123;                   <span class="comment">// 若这个值有效</span></span><br><span class="line">            <span class="keyword">let</span> byte = <span class="built_in">Math</span>.floor(x / <span class="number">8</span>);     <span class="comment">// 转换为字节和位</span></span><br><span class="line">            <span class="keyword">let</span> bit = x % <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">this</span>._has(byte, bit))&#123;                  <span class="comment">// 若对应的位没有值</span></span><br><span class="line">                <span class="built_in">this</span>.data[byte] |= BitSet.bits[bit];    <span class="comment">// 则设置该位的值</span></span><br><span class="line">                <span class="built_in">this</span>.n++;                               <span class="comment">// 递增集合大小</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Invalid set element:&quot;</span> + x );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">remove</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>._valid(x))&#123;                   <span class="comment">// 若这个值有效</span></span><br><span class="line">            <span class="keyword">let</span> byte = <span class="built_in">Math</span>.floor(x / <span class="number">8</span>);     <span class="comment">// 转换为字节和位</span></span><br><span class="line">            <span class="keyword">let</span> bit = x % <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>._has(byte, bit))&#123;                    <span class="comment">// 若对应的位已经设置了值</span></span><br><span class="line">                <span class="built_in">this</span>.data[byte] &amp;= BitSet.masks[bit];    <span class="comment">// 则取消设置的值</span></span><br><span class="line">                <span class="built_in">this</span>.n--;                                <span class="comment">// 递减集合大小</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Invalid set element:&quot;</span> + x );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取方法，返回集合大小</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title">size</span>() &#123; <span class="keyword">return</span> <span class="built_in">this</span>.n; &#125;</span><br><span class="line">    <span class="comment">// 迭代集合，只依次检查每一位（可以大幅优化）</span></span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">this</span>.max; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.has(x))&#123;</span><br><span class="line">                <span class="keyword">yield</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// has()、insert()和remove()方法会用的几个预定义值</span></span><br><span class="line">BitSet.bits = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>]);</span><br><span class="line">BitSet.nasks = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([~<span class="number">1</span>, ~<span class="number">2</span>, ~<span class="number">4</span>, ~<span class="number">8</span>, ~<span class="number">16</span>, ~<span class="number">32</span>, ~<span class="number">64</span>, ~<span class="number">128</span>]);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>\u2209</code> ==$\notin$</p>
</blockquote>
<p>JavaScript 类的主要特性</p>
<ul>
<li><p>若对象同一个类的成员，则它们都会从同一个原型对象继承属性</p>
</li>
<li><p>ES6 之前，使用 <code>function</code> 关键字创建的函数有 <code>prototype</code> 属性，这个属性的值是一个对象，该对象会用作以 <code>new</code> 调用构造函数而创建的所有对象的原型，通过初始化这个原型对象，可以为类定义共享方法</p>
<blockquote>
<p>原型对象是类的关键属性，构造函数是类的公共标识</p>
</blockquote>
</li>
<li><p>ES6 新增 <code>class</code> 关键字，在底层依然是构造函数和原型机制</p>
</li>
<li><p>子类在类声明中通过 <code>extends</code> 关键字定义</p>
</li>
<li><p>子类可以通过 <code>super</code> 关键字调用父类构造函数或父类中被覆盖的方法</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端学习</tag>
      </tags>
  </entry>
  <entry>
    <title>JS类型、值和变量</title>
    <url>/2021/10/09/JS/JS%E7%B1%BB%E5%9E%8B%E3%80%81%E5%80%BC%E5%92%8C%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<blockquote>
<p>前言：编程语法的词法结构是一套基本规则，规定如何使用这门语言编写程序。同时本篇讲解JavaScript的类型、值和变量</p>
</blockquote>
<span id="more"></span>

<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>JavaScript 支持两种注释</p>
<ul>
<li>单行注释以 // 开头到一行末尾的内容</li>
<li>多行注释位于 /* 和 */ 之间，可以跨行，不能嵌套</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"><span class="comment">/* 注释 */</span> <span class="comment">// 另一个注释</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 多行注释</span></span><br><span class="line"><span class="comment"> * 每行开头的 * 字符非必需，仅为了美观</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>





<h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><p>字面量（literal）是一种直接出现在程序中的数据值，后续解释数指和字符串字面量</p>
<p>字面量示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">12</span>			<span class="comment">// 数值 12</span></span><br><span class="line"><span class="number">1.2</span>			<span class="comment">// 数值 1.2</span></span><br><span class="line">“hello world”   	<span class="comment">// 字符串</span></span><br><span class="line"><span class="literal">true</span>			<span class="comment">// 布尔值</span></span><br><span class="line"><span class="literal">null</span>			<span class="comment">// 无对象</span></span><br></pre></td></tr></table></figure>





<h2 id="标识符和保留字"><a href="#标识符和保留字" class="headerlink" title="标识符和保留字"></a>标识符和保留字</h2><p>标识符用于在 JavaScript中 命名常量、变量、属性、函数和类，以及为某些循环提供标记（label）</p>
<p>JavaScript 标识符必须以<strong>字母、下划线（_）、或美元符号（$）</strong>开头，后续字符可以是字母、数字、下划线、美元符号</p>
<p>JavaScript 不能使用保留字作为常规标识符</p>
<h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>JavaScript 程序使用 Unicode 字符集编写，因此在字符串和注释中可以使用任意 Unicode 字符</p>
<ul>
<li><p>Unicode 转义序列：以 \u 开头，后跟 4 位十六进制数字或包含在一对花括号内的 1~6 位十六进制数字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">caf\u&#123;E9&#125; ;</span><br><span class="line">cafe\u00e9;  </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;u&#123;1f600&#125;&quot;</span>)  <span class="comment">// 打印一个笑脸符号</span></span><br></pre></td></tr></table></figure></li>
<li><p>Unicode 归一化：Unicode 标准为所有字符定义了首选编码并规划了归一化例程，用于把文本转换为适合比较的规范形式</p>
</li>
</ul>
<h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><p>JavaScript 的主要数值类型 Number 用于表示整数和近似实数</p>
<p>JavaScript 使用 IEEE 754 标准定义的 64 位浮点格式表示数值</p>
<h3 id="数值字面量"><a href="#数值字面量" class="headerlink" title="数值字面量"></a>数值字面量</h3><ul>
<li><p>整数字面量</p>
<ul>
<li><p>基数为 10 的整数直接写成数字序列</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">100000000</span></span><br></pre></td></tr></table></figure></li>
<li><p>十六进制字面量以 0x 或 0X 开头，后跟一个十六进制数字字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0xff</span>            <span class="comment">// =&gt; 255</span></span><br><span class="line"><span class="number">0xBADCAFE</span>       <span class="comment">// =&gt; 195939070</span></span><br></pre></td></tr></table></figure></li>
<li><p>二进制或八进制，分别使用前缀 0b 和 0o（或 0B 和 0O）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0b10101</span>			<span class="comment">// =&gt; 21</span></span><br><span class="line"><span class="number">0o377</span>			<span class="comment">// =&gt; 255</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>浮点字面量</p>
<ul>
<li><p>浮点字面量实数值有数值整数部分、小数点和数值的小数部分组成</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">3.14</span></span><br><span class="line"><span class="number">2345.6789</span></span><br><span class="line"><span class="number">.3333333333333</span></span><br></pre></td></tr></table></figure></li>
<li><p>指数计数法，实数值后面跟 e（或 E），跟一个可选的加号或减号，在跟一个整数指数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">6.02e23</span></span><br><span class="line"><span class="number">1.4738223E-32</span>       </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>数值字面量的分隔符：可以用下划线将数值字面量分隔</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> billion = <span class="number">1_000_000_000</span>;	<span class="comment">// 以下划线作为千分位分隔符</span></span><br><span class="line"><span class="keyword">let</span> bytes = <span class="number">0x89_AB_CD_EF</span>;	<span class="comment">// 作为字节分隔符</span></span><br><span class="line"><span class="keyword">let</span> bits = <span class="number">0b0001_1101_0111</span>;	<span class="comment">// 作为半字节分隔符</span></span><br><span class="line"><span class="keyword">let</span> fraction = <span class="number">0.123_456_789</span>;	<span class="comment">// 用于小数分隔</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="数值算术"><a href="#数值算术" class="headerlink" title="数值算术"></a>数值算术</h3><p>JavaScript使用算术操作符来操作数值，如加法（+）、减法（-）、乘法（*）、取模（%），ES6新增取幂（**）</p>
<p>Math对象属性提供一组函数和常量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>,<span class="number">53</span>)				<span class="comment">// =&gt; 2 的 53 次方</span></span><br><span class="line"><span class="built_in">Math</span>.round(<span class="number">.6</span>)				<span class="comment">// =&gt; 1.0：舍入到最接近的整数</span></span><br><span class="line"><span class="built_in">Math</span>.ceil(<span class="number">.6</span>)				<span class="comment">// =&gt; 1.0：向上舍入到一个整数</span></span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="number">.6</span>)				<span class="comment">// =&gt; 0.0：向下舍入到一个整数</span></span><br><span class="line"><span class="built_in">Math</span>.abs(-<span class="number">5</span>)				<span class="comment">// =&gt; 5：绝对值</span></span><br><span class="line"><span class="built_in">Math</span>.max(x,y,z)				<span class="comment">// 返回最大的参数</span></span><br><span class="line"><span class="built_in">Math</span>.min(x,y,z)				<span class="comment">// 返回最小的参数</span></span><br><span class="line"><span class="built_in">Math</span>.random				<span class="comment">// 伪随机数下，其中 0 ≤ x &lt; 1.0</span></span><br><span class="line"><span class="built_in">Math</span>.PI					<span class="comment">// Π：圆周率</span></span><br><span class="line"><span class="built_in">Math</span>.E					<span class="comment">// e：自然对数的底数</span></span><br><span class="line"><span class="built_in">Math</span>.sqrt(<span class="number">3</span>)				<span class="comment">// =&gt; 3 的平方根</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">3</span>,<span class="number">1</span>/<span class="number">3</span>)				<span class="comment">// =&gt; 3 的立方根</span></span><br><span class="line"><span class="built_in">Math</span>.sin(<span class="number">0</span>)				<span class="comment">// 三角函数：还有 Math.cos、Math.aten 等</span></span><br><span class="line"><span class="built_in">Math</span>.log(<span class="number">10</span>)				<span class="comment">// 10 的自然对数</span></span><br><span class="line"><span class="built_in">Math</span>.log(<span class="number">100</span>)/<span class="built_in">Math</span>.LN10			<span class="comment">// 以 10 为底 100 的对数</span></span><br><span class="line"><span class="built_in">Math</span>.log(<span class="number">512</span>)/<span class="built_in">Math</span>.LN2			<span class="comment">// 以 2 为底 512 的对数 </span></span><br><span class="line"><span class="built_in">Math</span>.exp(<span class="number">3</span>)				<span class="comment">// Math.E 的立方</span></span><br></pre></td></tr></table></figure>

<p>ES6 新定义函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.cbrt(<span class="number">27</span>)				<span class="comment">// =&gt; 3：立方根</span></span><br><span class="line"><span class="built_in">Math</span>.hypot(<span class="number">3</span>,<span class="number">4</span>)				<span class="comment">// =&gt; 5：所有参数平方和的平方根</span></span><br><span class="line"><span class="built_in">Math</span>.log10(<span class="number">100</span>)				<span class="comment">// =&gt; 2：以 10 为底的对数</span></span><br><span class="line"><span class="built_in">Math</span>.log2(<span class="number">1024</span>)				<span class="comment">// =&gt; 10：以 2 为底的对数</span></span><br><span class="line"><span class="built_in">Math</span>.log1p(x)				<span class="comment">// (1+x) 的自然对数；精确到非常小的x</span></span><br><span class="line"><span class="built_in">Math</span>.expm1(x)				<span class="comment">// Math.exp(x)-1；Math.log1p() 的逆运算</span></span><br><span class="line"><span class="built_in">Math</span>.sign(x)				<span class="comment">// 对 &lt;、==或 &gt;0的参数返回 -1、0 或 1</span></span><br><span class="line"><span class="built_in">Math</span>.imul(<span class="number">2</span>,<span class="number">3</span>)				<span class="comment">// =&gt; 6：优化的 32 位整数乘法</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">0xf</span>)				<span class="comment">// =&gt; 28：32 位整数中前导 0 的位数</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">3.9</span>)				<span class="comment">// =&gt; 3：剪掉分数部分得到整数</span></span><br><span class="line"><span class="built_in">Math</span>.fround(x)				<span class="comment">// 舍入到最接近的 32 位浮点数</span></span><br><span class="line"><span class="built_in">Math</span>.sinh(x)				<span class="comment">// 双曲线正弦，还有 Math.cosh()、Math.tanh() </span></span><br><span class="line"><span class="built_in">Math</span>.asinh(x)				<span class="comment">// 双曲线反正弦，还有 Math.acosh()、Math.atanh() </span></span><br></pre></td></tr></table></figure>

<p>JavaScript 算术中上溢出结果返回 <code>Infinity</code>，某个负数的绝对值超过最大可表示负数的绝对值，返回 <code>-Infinity</code></p>
<p>下溢出发生在数值操作的结果比最小可表示数值更接近 0 的情况下，返回 0 ；若下溢来自负数，返回 -0</p>
<p>被零除返回 <code>Infinity</code>或 <code>-Infinity</code>，0 除 0 返回非数值 <code>NaN（Not a Number）</code></p>
<p>JavaScript预定义了全局常量 <code>Infinity</code> 和 <code>NaN</code>，这些值也可以通过 <code>Number</code> 对象属性获取</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">Infinity</span>			<span class="comment">// 因为太大而无法表示的整数</span></span><br><span class="line"><span class="number">1</span>/<span class="number">0</span>				<span class="comment">// =&gt; Infinity</span></span><br><span class="line">-<span class="literal">Infinity</span>			<span class="comment">// 因为太小而无法表示的负数</span></span><br><span class="line">-<span class="built_in">Number</span>.MAX_VALUE * <span class="number">2</span>		<span class="comment">// =&gt; -Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="literal">NaN</span>				<span class="comment">// 非数值</span></span><br><span class="line"><span class="built_in">Number</span>.NaN			<span class="comment">// 同上</span></span><br><span class="line"><span class="literal">Infinity</span>/<span class="literal">Infinity</span>		<span class="comment">// =&gt; NaN</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.MIN_VALUE/<span class="number">2</span>		<span class="comment">// =&gt; 0：下溢出</span></span><br><span class="line">-<span class="built_in">Number</span>.MIN_VALUE/<span class="number">2</span>		<span class="comment">// =&gt; -0：负零</span></span><br><span class="line">-<span class="number">1</span>/<span class="literal">Infinity</span>			<span class="comment">// =&gt; -0：负零</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6定义属性</span></span><br><span class="line"><span class="built_in">Number</span>.parseInt()		<span class="comment">// 同全局parseInt()函数</span></span><br><span class="line"><span class="built_in">Number</span>.parseFloat()		<span class="comment">// 同全局parseFloat()函数</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN()			<span class="comment">// 判断 x 是不是 NaN</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite()		<span class="comment">// 判断 x 是数值还是无穷</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger()		<span class="comment">// 判断 x 是不是整数</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger()		<span class="comment">// </span></span><br><span class="line"><span class="built_in">Number</span>.MIN_SAFE_INTEGER		<span class="comment">// =&gt; -(2**53-1)</span></span><br><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER         <span class="comment">// =&gt; 2**53-1</span></span><br><span class="line"><span class="built_in">Number</span>.EPSILON			<span class="comment">// =&gt; 2**52：数值与数值之间最小的差</span></span><br></pre></td></tr></table></figure>

<p>非数值与任何值比较都不相等，也不等于自身，即不能通过 <code>x === NaN</code> 确定是不是非数值，只能通过 <code>x != x</code> 或 <code>Number.isNaN(x)</code></p>
<p>负零值与正零值相等，几乎无法区别</p>
<h3 id="二进制浮点数"><a href="#二进制浮点数" class="headerlink" title="二进制浮点数"></a>二进制浮点数</h3><p>JavaScript使用的 IEEE-754 浮点表示法是一种二进制表示法，可以精确地表示如 1/2、1/8 和 1/1024 等分数，但不能精确表示如0.1这样地数</p>
<p>虽然JavaScript数值有足够大地精度，但仍然可能导致一些问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">.3</span> - <span class="number">.2</span>;			<span class="comment">// 30美分减20美分</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="number">.2</span> - <span class="number">.1</span>;			<span class="comment">// 20美分减10美分</span></span><br><span class="line">x === y;				<span class="comment">// =&gt; false：这两个值不一样</span></span><br><span class="line">x === <span class="number">.1</span>;				<span class="comment">// =&gt; false：.3-.2 不等于 .1</span></span><br><span class="line">y === <span class="number">.1</span>;				<span class="comment">// =&gt; true：.2 -.1 等于 .1</span></span><br></pre></td></tr></table></figure>

<p>若需要使用浮点近似值，可以考虑使用等量整数</p>
<h3 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h3><p>ES2020为 JavaScript 定义了一种新的数值类型 BigInt（整数）</p>
<p>BigInt 增加的目的是为了表示 64 位整数，可以兼容很多其他语言和 API。</p>
<p>BigInt 可以满足对大数（可表示数千甚至数百万个数字）的需求，但是 BigInt 地实现不适合加密，没有考虑防止时序攻击</p>
<p>BigInt 字面量写作一串数字后跟小写字母 n </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1234n</span>							<span class="comment">// 基数为 10 的 BigInt</span></span><br><span class="line"><span class="number">0b111111n</span>						<span class="comment">// 二进制 BigInt</span></span><br><span class="line"><span class="number">0o7777n</span>							<span class="comment">// 八进制 BigInt</span></span><br><span class="line"><span class="number">0x8000000000000000n</span>					<span class="comment">// =&gt; 2n**63n：一个 64 位整数</span></span><br></pre></td></tr></table></figure>

<p>可以用 BigInt() 函数把常规数值或字符串转换为 BigInt 值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BigInt</span>(<span class="built_in">Number</span>.MAX_SAFE_INTEGER)				<span class="comment">// =&gt; 9007199254740991n				</span></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">&quot;1&quot;</span> + <span class="string">&quot;0&quot;</span>.repeat(<span class="number">100</span>);			<span class="comment">// 1 后跟 100 个零</span></span><br><span class="line"><span class="built_in">BigInt</span>(string)						<span class="comment">// =&gt; 10n**100n</span></span><br></pre></td></tr></table></figure>

<p>BigInt 值的算术运算与常规 JavaScript 数值类似，只不过<strong>除法会丢弃余数并会向下（向零）舍入</strong></p>
<p>常规运算操作符可以用于 BigInt ，但不能混用 BigInt 操作数和常规数值操作数</p>
<p>比较操作符允许混合操作数类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &lt; <span class="number">2n</span>					<span class="comment">// =&gt; true</span></span><br><span class="line"><span class="number">2</span> &gt; <span class="number">1n</span>					<span class="comment">// =&gt; true</span></span><br><span class="line"><span class="number">0</span> == <span class="number">0n</span>					<span class="comment">// =&gt; true</span></span><br><span class="line"><span class="number">0</span> === <span class="number">0n</span>				<span class="comment">// =&gt; false：=== 也检查类型是否相等</span></span><br></pre></td></tr></table></figure>

<p>位操作符通常可以用于 BigInt 操作数，但 Math对象的任何函数不接收 BigInt 操作数</p>
<h3 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h3><p>JavaScript 为表示和操作与日期及时间相关的数据定义了 Date 类。Date 是对象，也可以用数值表示形式（自 1970.1.1 起的毫秒数，也叫时间戳）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timestamp = <span class="built_in">Date</span>.now();			<span class="comment">// 当前时间的时间戳（数值）</span></span><br><span class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();				<span class="comment">// 当前时间的日期对象</span></span><br><span class="line"><span class="keyword">let</span> ms = now.getTime();				<span class="comment">// 转换位毫秒时间戳</span></span><br><span class="line"><span class="keyword">let</span> iso = now.toISOString();		        <span class="comment">// 转换位标准格式的字符串</span></span><br></pre></td></tr></table></figure>





<h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><p>JavaScript 中表示文本的类型是 <code>String</code>，即字符串</p>
<p>字符串是 16 位值的不可修改的有序序列，每个值表示一个 Unicode 字符</p>
<h3 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h3><p>JavaScript 字符串可以用一对匹配的单引号、双引号或反引号来包含</p>
<blockquote>
<p>ES6新增可以使用反引号定界字符串</p>
</blockquote>
<p>单引号、双引号、反引号可以相互嵌套</p>
<p>JavaScript 早期版本要求字符串字面量写在一行，ES5 可以在每行末尾加一个反斜杠（ \ ）写道多行上，ES6 的反引号支持跨行字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写在一行但表示两行的字符串：</span></span><br><span class="line"><span class="string">&#x27;two\nlines&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写在三行但只有一行的字符串：</span></span><br><span class="line"><span class="string">&quot;one\</span></span><br><span class="line"><span class="string"> long\</span></span><br><span class="line"><span class="string"> line&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写在两行实际也是两行的字符串：</span></span><br><span class="line"><span class="string">&#x27;two</span></span><br><span class="line"><span class="string"> nlines&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h3><table>
<thead>
<tr>
<th>序列</th>
<th>表示的字符</th>
</tr>
</thead>
<tbody><tr>
<td>\ 0</td>
<td>NUL 字符</td>
</tr>
<tr>
<td>\ b</td>
<td>退格符</td>
</tr>
<tr>
<td>\ t</td>
<td>水平制表符</td>
</tr>
<tr>
<td>\ n</td>
<td>换行符</td>
</tr>
<tr>
<td>\ v</td>
<td>垂直制表符</td>
</tr>
<tr>
<td>\ f</td>
<td>进纸符</td>
</tr>
<tr>
<td>\ r</td>
<td>回车符</td>
</tr>
<tr>
<td>\ “</td>
<td>双引号</td>
</tr>
<tr>
<td>\ ‘</td>
<td>单引号</td>
</tr>
<tr>
<td>\ \</td>
<td>反斜杠</td>
</tr>
<tr>
<td>\ xnn</td>
<td>由 2 为十六进制数字 nn 指定的 Unicode 字符</td>
</tr>
<tr>
<td>\ unnnn</td>
<td>由 4 为十六进制数字 nnnn 指定的 Unicode 字符</td>
</tr>
<tr>
<td>\ u{n}</td>
<td>由码点 n 指定的 Unicode 字符，其中 n 是介于 0 和 10FFFF 之间的 1 到 6 位十六进制数字（ES6）</td>
</tr>
</tbody></table>
<h3 id="字符串使用"><a href="#字符串使用" class="headerlink" title="字符串使用"></a>字符串使用</h3><p>JavaScript 可以使用 + 操作符拼接字符串，可以使用 <code>===</code> 和 <code>!==</code> 操作符比较字符串，也可以使用其比较字符串如： &lt;、 &lt;=、&gt;和 &gt;=</p>
<p>操作字符串的API</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;Hello, world&quot;</span>;</span><br><span class="line">s.length					<span class="comment">// =&gt; 12：返回字符串长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得字符串的一部分</span></span><br><span class="line">s.substring(<span class="number">1</span>,<span class="number">4</span>)				<span class="comment">// =&gt; &quot;ell&quot;：第 2~4 个字符</span></span><br><span class="line">s.slice(<span class="number">1</span>,<span class="number">4</span>)					<span class="comment">// =&gt; &quot;ell&quot;：同上</span></span><br><span class="line">s.slice(-<span class="number">3</span>)					<span class="comment">// =&gt; &quot;rld&quot;：最后 3 个字符</span></span><br><span class="line">s.split(<span class="string">&quot;, &quot;</span>)					<span class="comment">// =&gt; [&quot;Hello&quot;,&quot;world&quot;]：从定界处拆分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 搜索字符串</span></span><br><span class="line">s.indexOf(<span class="string">&quot;l&quot;</span>)					<span class="comment">// =&gt; 2：第一个字母 l 的位置</span></span><br><span class="line">s.indexOf(<span class="string">&quot;l&quot;</span>,<span class="number">3</span>)				<span class="comment">// =&gt; 3：位置 3 后面第一个 l 的位置</span></span><br><span class="line">s.indexOf(<span class="string">&quot;zz&quot;</span>)					<span class="comment">// =&gt; -1：s 并不包含子串 zz</span></span><br><span class="line">s.lastIndexOf(<span class="string">&quot;l&quot;</span>)				<span class="comment">// =&gt; 10：最后一个字母 l 的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 及之后版本中的布尔值搜索函数</span></span><br><span class="line">s.startsWith(<span class="string">&quot;hell&quot;</span>) 				<span class="comment">// =&gt; true：字符串是以这些字符开头的</span></span><br><span class="line">s.endWith(<span class="string">&quot;!&quot;</span>)					<span class="comment">// =&gt; false：s 不是以它结尾的</span></span><br><span class="line">s.includes(<span class="string">&quot;or&quot;</span>)				<span class="comment">// =&gt; true：s包含子串 or</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建字符串的修改版本</span></span><br><span class="line">s.replace(<span class="string">&quot;llo&quot;</span>,<span class="string">&quot;ya&quot;</span>)				<span class="comment">// =&gt; &quot;Heya,world&quot;</span></span><br><span class="line">s.toLowerCase()					<span class="comment">// =&gt; &quot;hello, world&quot;</span></span><br><span class="line">s.toUpperCase()					<span class="comment">// =&gt; &quot;HELLO, WORLD&quot;</span></span><br><span class="line">s.normalize()					<span class="comment">// Unicode NFC 归一化：ES6 新增</span></span><br><span class="line">s.normalize(<span class="string">&quot;NFD&quot;</span>)				<span class="comment">// NFD 归一化。还有 NFKC 和 NFKD</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问字符串的个别（16位值）字符</span></span><br><span class="line">s.charAt(<span class="number">0</span>)					<span class="comment">// =&gt; &quot;H&quot;：第一个字符</span></span><br><span class="line">s.charAt(s.length-<span class="number">1</span>)				<span class="comment">// =&gt; &quot;d&quot;：最后一个字符</span></span><br><span class="line">s.charCodeAt(<span class="number">0</span>)					<span class="comment">// =&gt; 72：指定位置的16位数值</span></span><br><span class="line">s.codePointAt(<span class="number">0</span>)				<span class="comment">// =&gt; 72：ES6，适用于码点大于 16 位的情形</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES2017 新增字符串填充函数</span></span><br><span class="line"><span class="string">&quot;x&quot;</span>.padStart(<span class="number">3</span>)					<span class="comment">// =&gt; &quot;  x&quot;：在左侧添加空格，让字符串长度变成3</span></span><br><span class="line"><span class="string">&quot;x&quot;</span>.padEnd(<span class="number">3</span>)					<span class="comment">// =&gt; &quot;x  &quot;：在右侧添加空格，让字符串长度变成3</span></span><br><span class="line"><span class="string">&quot;x&quot;</span>.padStart(<span class="number">3</span>,<span class="string">&quot;*&quot;</span>)				<span class="comment">// =&gt; &quot;**x&quot;：在左侧添加星号，让字符串长度变成3</span></span><br><span class="line"><span class="string">&quot;x&quot;</span>.padEnd(<span class="number">3</span>,<span class="string">&quot;-&quot;</span>)				<span class="comment">// =&gt; &quot;x--&quot;：在右侧添加破折号，让字符串长度变成3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除空格函数</span></span><br><span class="line"><span class="string">&quot; test &quot;</span>.trim()					<span class="comment">// =&gt; &quot;test&quot;：删除开头和末尾的空格</span></span><br><span class="line"><span class="string">&quot; test &quot;</span>.trimStart()				<span class="comment">// =&gt; &quot;test &quot;：删除左侧的空格。也叫 trimLeft</span></span><br><span class="line"><span class="string">&quot; test &quot;</span>.trimEnd()				<span class="comment">// =&gt; &quot; test&quot;：删除右侧的空格。也叫 trimRight</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 未分类字符串方法</span></span><br><span class="line">s.concat(<span class="string">&quot;!&quot;</span>)					<span class="comment">// =&gt; &quot;Hello, world!&quot;：可以用 + 操作符代替</span></span><br><span class="line"><span class="string">&quot;&lt;&gt;&quot;</span>.repeat(<span class="number">5</span>)				        <span class="comment">// =&gt; &quot;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&quot;：拼接 n 次。ES6 新增</span></span><br></pre></td></tr></table></figure>

<p>JavaScript中的字符串是不可修改的。像 <code>replace()</code> 和 <code>toUpperCase()</code> 这些都返回新字符串</p>
<p>字符串也可以被当成只读数组，用方括号访问</p>
<h3 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h3><p>ES6 及之后的版本，字符串字面量可以用反引号定界，反引号中可以包含模板字面量，模板字面量可以包含任意JavaScript表达式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Bill&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> greeting = <span class="string">&#x27;Hello $&#123; name &#125;.&#x27;</span>;		 <span class="comment">// =&gt; greeting == &quot;Hello Bill.&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>标签化模板字面量</strong>：在开头的反引号前添加函数名（标签），则模板字面量中的文本和表达式的值作为参数传给这个函数</p>
<p>”标签化模板字面量“的值即这个函数的返回值</p>
<p>ES6 提供内置的标签函数：<code>String.raw()</code> ，用于返回反引号中未经处理的文本</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;\n&#x27;</span>.length					<span class="comment">// =&gt; 1：字符串中只包含一个换行符</span></span><br><span class="line"><span class="built_in">String</span>.raw<span class="string">&#x27;\n&#x27;</span>.length				<span class="comment">// =&gt; 2：一个反斜杠字符和一个字母n</span></span><br></pre></td></tr></table></figure>





<h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>布尔值只有两个值：<code>true</code> 和 <code>false</code></p>
<p>JavaScript 的任何值都可以转换为布尔值，以下的值转换为布尔值 <code>false</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">-<span class="number">0</span></span><br><span class="line"><span class="literal">NaN</span></span><br><span class="line"><span class="string">&quot;&quot;</span>		<span class="comment">// 空字符串</span></span><br></pre></td></tr></table></figure>

<p>所有其他值转换为布尔值 <code>true</code></p>
<p>布尔值的 <code>toString()</code> 方法，用于将自己转换为字符串 ”true“ 或 ”false“</p>
<h2 id="null与undefined"><a href="#null与undefined" class="headerlink" title="null与undefined"></a>null与undefined</h2><p><code>null</code> 是关键字，通常用于表示某个值不存在</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span>(<span class="literal">null</span>)			<span class="comment">// =&gt; &quot;object&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>null</code> 可以看作一种特殊对象，表示 ”没对象“</p>
<p><code>undefined</code> 也表示值不存在</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span>(<span class="literal">undefined</span>)			<span class="comment">// =&gt; &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>undefined</code> 情形</p>
<ul>
<li>变量的值未初始化时</li>
<li>查询不存在的对象属性或数组元素</li>
<li>没用明确返回值的函数返回值</li>
<li>没有传值的函数参数的值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>			<span class="comment">// =&gt; true</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span>			<span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure>





<h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><p>ES6 新增的一种原始类型，用作非字符串的属性名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> strname = <span class="string">&quot;string name&quot;</span>;			<span class="comment">// 可以用作属性名的字符串</span></span><br><span class="line"><span class="keyword">let</span> symname = <span class="built_in">Symbol</span>(<span class="string">&quot;propname&quot;</span>);		<span class="comment">// 可以用作属性名的符号</span></span><br><span class="line"><span class="keyword">typeof</span> strname					<span class="comment">// =&gt; &quot;string&quot;：strname 是字符串</span></span><br><span class="line"><span class="keyword">typeof</span> symname					<span class="comment">// =&gt; &quot;symbol&quot;：symname 是符号</span></span><br><span class="line"><span class="keyword">let</span> o = &#123;&#125;;					<span class="comment">// 创建一个新对象</span></span><br><span class="line">o[strname] = <span class="number">1</span>;					<span class="comment">// 使用字符串名定义一个属性</span></span><br><span class="line">o[symname] = <span class="number">2</span>;					<span class="comment">// 使用符号名定义一个属性</span></span><br><span class="line">o[strname]					<span class="comment">// =&gt; 1：访问字符串名字的属性</span></span><br><span class="line">o[symname]					<span class="comment">// =&gt; 2：访问符号名字的属性</span></span><br></pre></td></tr></table></figure>

<p><code>Symbol</code> 类型的 “真实值” 无法获取，即<strong>Symbol类型没有对应的字面量</strong></p>
<p><code>Symbol</code> 值只能通过调用 <code>Symbol()</code> 来获取，且返回的都是唯一的值，即使每次传入的参数相同 </p>
<p>通过调用 <code>toString()</code> 方法可以返回包含参数的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>(<span class="string">&quot;sym_x&quot;</span>);</span><br><span class="line">s.toString						<span class="comment">// =&gt; &quot;Symbol(sym_x)&quot;</span></span><br></pre></td></tr></table></figure>

<p>为了可以与其他代码共享符号值，JavaScript 定义了一个全局符号注册表</p>
<p><code>Symbol.for()</code> 函数接收一个字符串参数，返回一个与该字符串关联的符号值，若没有关联的符号值，创建返回新符号，可以通过 <code>Symbol.keyFor()</code> 得到字符串参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>.for(<span class="string">&quot;shared&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> t = <span class="built_in">Symbol</span>.for(<span class="string">&quot;shared&quot;</span>);</span><br><span class="line">s === t						<span class="comment">// =&gt; true</span></span><br><span class="line">s.toString()					<span class="comment">// =&gt; &quot;Symbol(shared);&quot;</span></span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(t)				<span class="comment">// =&gt; &quot;shared&quot;</span></span><br></pre></td></tr></table></figure>





<h2 id="原始值与对象引用"><a href="#原始值与对象引用" class="headerlink" title="原始值与对象引用"></a>原始值与对象引用</h2><p>JavaScript 中的原始值（undefined、null、布尔值、数值和字符串）是不可修改的，修改后都是返回新的值。比较两个不同的字符串时，当且仅当两个字符串长度相同且每个索引的字符也相同时，才相等</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s.toUpperCase();</span><br><span class="line">s						<span class="comment">// =&gt; &quot;hello&quot;：原始字符串并未改变</span></span><br></pre></td></tr></table></figure>

<p>JavaScript 中的对象和数组是可修改的，即其值是可变的。两个不同的对象和数组即使用完全相同的属性和值，也不是相等的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;, p = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;				<span class="comment">// 两个对象，有相同的属性</span></span><br><span class="line">o === p							<span class="comment">// =&gt; false：不同的对象永远也不会相等</span></span><br><span class="line"><span class="keyword">let</span> a = [], b = [];					<span class="comment">// 两个不同数组</span></span><br><span class="line">a === b							<span class="comment">// =&gt; false：不同的数组永远也不会相等</span></span><br></pre></td></tr></table></figure>

<p>当且仅当两个对象引用同一个底层对象时，才相等</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [];			<span class="comment">// 这个变量引用一个空数组</span></span><br><span class="line"><span class="keyword">let</span> b = a;			<span class="comment">// b 引用同一个数组</span></span><br><span class="line">b[<span class="number">0</span>] = <span class="number">1</span>;			<span class="comment">// 修改变量b引用的数组</span></span><br><span class="line">a[<span class="number">0</span>]				<span class="comment">// =&gt; 1：变化也能通过变量 a 看到</span></span><br><span class="line">a === b				<span class="comment">// =&gt; true：a 和 b 引用同一个对象，相等</span></span><br></pre></td></tr></table></figure>

<p>创建对象或数组的副本，必须显示复制对象或数组的元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>];						</span><br><span class="line"><span class="keyword">let</span> b = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; a.length; i++)&#123;</span><br><span class="line">	b[i] = a[i];			<span class="comment">// 把 a 的元素复制到 b 中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="built_in">Array</span>.from(b);			<span class="comment">// ES6 可以使用 Array.from() 复制数组</span></span><br></pre></td></tr></table></figure>





<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>JavaScript 的类型转换</p>
<table>
<thead>
<tr>
<th>值</th>
<th>转换为字符串</th>
<th>转换为数值</th>
<th>转换为布尔值</th>
</tr>
</thead>
<tbody><tr>
<td>undefined</td>
<td>“undefined”</td>
<td>NaN</td>
<td>false</td>
</tr>
<tr>
<td>null</td>
<td>“null”</td>
<td>0</td>
<td>false</td>
</tr>
<tr>
<td>true</td>
<td>“true”</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>false</td>
<td>“false”</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>“”（空字符串）</td>
<td></td>
<td>0</td>
<td>false</td>
</tr>
<tr>
<td>“1.2”（非空，数值）</td>
<td></td>
<td>1.2</td>
<td>true</td>
</tr>
<tr>
<td>“one”（非空，非数值）</td>
<td></td>
<td>NaN</td>
<td>true</td>
</tr>
<tr>
<td>0</td>
<td>“0”</td>
<td></td>
<td>false</td>
</tr>
<tr>
<td>-0</td>
<td>“0”</td>
<td></td>
<td>false</td>
</tr>
<tr>
<td>1（有限，非零）</td>
<td>“1”</td>
<td></td>
<td>true</td>
</tr>
<tr>
<td>Infinity</td>
<td>“Infinity”</td>
<td></td>
<td>true</td>
</tr>
<tr>
<td>-Infinity</td>
<td>“-Infinity”</td>
<td></td>
<td>true</td>
</tr>
<tr>
<td>NaN</td>
<td>“NaN”</td>
<td></td>
<td>false</td>
</tr>
<tr>
<td>{ }（任何对象）</td>
<td></td>
<td></td>
<td>true</td>
</tr>
<tr>
<td>[ ]（空数组）</td>
<td>“”</td>
<td>0</td>
<td>true</td>
</tr>
<tr>
<td>[9]（一个数值元素）</td>
<td>“9”</td>
<td>9</td>
<td>true</td>
</tr>
<tr>
<td>[‘a’]（任何其他数组）</td>
<td>使用 join()方法</td>
<td>NaN</td>
<td>true</td>
</tr>
<tr>
<td>Function( )[ ]</td>
<td></td>
<td>NaN</td>
<td>true</td>
</tr>
</tbody></table>
<h3 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a><strong>显示转换</strong></h3><ul>
<li><code>Boolean()</code></li>
<li><code>Number()</code></li>
<li><code>String()</code></li>
</ul>
<p>除 <code>null</code> 和 <code>undefined</code> 之外的所有值都有 <code>toString()</code> 方法，返回的结果通常与 <code>String()</code> 相同</p>
<p>某些 JavaScript 操作符会执行隐式类型转换</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">x + <span class="string">&quot;&quot;</span>				<span class="comment">// =&gt; String(x)</span></span><br><span class="line">+x				<span class="comment">// =&gt; Number(x)</span></span><br><span class="line">x-<span class="number">0</span>				<span class="comment">// =&gt; Number(x)</span></span><br><span class="line">!!x				<span class="comment">// =&gt; Boolean(x)：注意这里两次取反</span></span><br></pre></td></tr></table></figure>



<h3 id="数值到字符串"><a href="#数值到字符串" class="headerlink" title="数值到字符串"></a>数值到字符串</h3><p>Number 类定义的  <code>toString()</code> 方法可以接收一个参数（ 2~36 ），用于指定一个基数或底数，默认为 10</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> n =<span class="number">17</span>;</span><br><span class="line"><span class="keyword">let</span> binary = <span class="string">&quot;0b&quot;</span> + n.toString(<span class="number">2</span>);		<span class="comment">// binary == &quot;0b10001&quot;</span></span><br><span class="line"><span class="keyword">let</span> octal = <span class="string">&quot;0o&quot;</span> + n.toString(<span class="number">8</span>);		<span class="comment">// binary == &quot;0o21&quot;</span></span><br><span class="line"><span class="keyword">let</span> hex = <span class="string">&quot;0x&quot;</span> + n.toString(<span class="number">16</span>);		<span class="comment">// hex == &quot;0x11&quot;</span></span><br></pre></td></tr></table></figure>

<p>Number 类定义了 3 种方法</p>
<ul>
<li><code>toFixed()</code> ：转换时可以指定小数点后面位数</li>
<li><code>toExponential()</code> ：使用指数计数法转换，结果为小数点前 1 位，小数点后为指定位数</li>
<li><code>toPrecision()</code> ：按照指定的有效数字转换，若有效数字个数不足以表示数值的整数部分，使用指数计数法</li>
<li>三种方法必要时都会舍去末尾的数字或补 0</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> n = <span class="number">123456.789</span>;</span><br><span class="line">n.toFixed(<span class="number">0</span>)						<span class="comment">// =&gt; &quot;123457&quot;</span></span><br><span class="line">n.toFixed(<span class="number">5</span>)						<span class="comment">// =&gt; &quot;123456.79&quot;</span></span><br><span class="line">n.toExponential(<span class="number">1</span>)					<span class="comment">// =&gt; &quot;1.2e+5&quot;</span></span><br><span class="line">n.toExponential(<span class="number">3</span>)					<span class="comment">// =&gt; &quot;1.235e+5&quot;</span></span><br><span class="line">n.toPrecision(<span class="number">4</span>)					<span class="comment">// =&gt; &quot;1.235e+5&quot;</span></span><br><span class="line">n.toPrecision(<span class="number">7</span>)					<span class="comment">// =&gt; &quot;123456.8&quot;</span></span><br><span class="line">n.toPrecision(<span class="number">10</span>)					<span class="comment">// =&gt; &quot;123456.7890&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="字符串到数值"><a href="#字符串到数值" class="headerlink" title="字符串到数值"></a>字符串到数值</h3><p>把字符串传给 <code>Number()</code> 转换函数，会把字符串当成整数或浮点数字面量解析，只支持基础为 10 的整数，不允许末尾出现无关字符</p>
<p><code>parseInt()</code> 只解析整数，接收可选的第二个参数，用于指定要解析数值的基数或底数（ 2~36 ）</p>
<p><code>parseFloat()</code> 既解析整数也解析浮点数</p>
<p><code>parseInt()</code> 和 <code>parseFloat()</code> 会跳过开头空格，尽量解析多的数字，忽略后面的无关字符。若第一个字符不是有效的数值字面量，返回 <code>NaN</code> </p>
<h3 id="对象到原始值"><a href="#对象到原始值" class="headerlink" title="对象到原始值"></a>对象到原始值</h3><p>所有对象都会继承两个在对象到原始值转换时使用的方法</p>
<ul>
<li><code>toString()</code>：返回对象的字符串表示</li>
<li><code>valueOf()</code>：把对象转换为代表对象的原始值（若存在一个这样的原始值）</li>
</ul>
<p>JavaScript 规范定义了对象到原始值转换的 3 种基本算法</p>
<ul>
<li><p>偏字符串：该算法返回原始值，而且只要可能就返回字符串</p>
<blockquote>
<p>偏字符串算法首先尝试 <code>toString()</code> 方法，若此方法有定义且返回原始值，则使用该原始值；若不存在，或存在但返回对象，尝试 <code>valueOf()</code> 方法，若此方法存在且返回原始值，则使用该原始值，否则，报 <code>TypeError()</code></p>
</blockquote>
</li>
<li><p>偏数值：该算法返回原始值，而且只要可能就返回数值</p>
<blockquote>
<p>与偏字符串算法类似，但是先尝试 <code>valueOf()</code> 方法，再尝试 <code>toString()</code> 方法</p>
</blockquote>
</li>
<li><p>无偏好：该算法不倾向于任何原始值类型，由类定义自己的转换规则</p>
<blockquote>
<p>取决于被转换对象的类</p>
</blockquote>
</li>
</ul>
<p>JavaScript 内置类除了 <code>Date()</code> 类都实现了偏数值算法，<code>Date()</code> 类实现偏字符串算法</p>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>ES6 实现了一种复合声明与赋值语法，叫做解构赋值（destructuring assignment）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x,y] = [<span class="number">1</span>,<span class="number">2</span>];			<span class="comment">// 相当于 let x=1, y=2</span></span><br><span class="line">[x,y] = [x+<span class="number">1</span>,y+<span class="number">1</span>];			<span class="comment">// 相当于 x = x + 1, y =y + 1</span></span><br><span class="line">[x,y] = [y,x];				<span class="comment">// 交换两个变量的值</span></span><br><span class="line">[x,y]					<span class="comment">// =&gt; [3,2]</span></span><br></pre></td></tr></table></figure>

<p>解构赋值左侧变量的个数不一定与右侧变量相同，左侧多余的会被设为 <code>undefined</code> ，右侧多余的会被忽略。左侧的变量列表可以包含额外的逗号，以跳过右侧的某些值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x,y] = [<span class="number">1</span>];			<span class="comment">// x == 1; y == undefined</span></span><br><span class="line">[x,y] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];			<span class="comment">// x == 1; y == 2</span></span><br><span class="line">[,x,,y] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];			<span class="comment">// x == 2; y == 4</span></span><br></pre></td></tr></table></figure>

<p>在解构赋值时，若想把所有未使用或剩余的值收集到一个变量中，可在左侧最后一个变量名前加 3 个点（ … ）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, ...y] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];		<span class="comment">// y == [2,3,4]</span></span><br></pre></td></tr></table></figure>

<p>若变量名与对象属性名相同，可以直接赋值，若左侧包含一个不是右侧属性的变量名，该变量被赋值为 <code>undefined</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于 const sin=Math.sin, cos=Math.cos, tan=Math.tan</span></span><br><span class="line"><span class="keyword">const</span> &#123;sin,cos,tan&#125; = <span class="built_in">Math</span>;</span><br></pre></td></tr></table></figure>

<p>对象解构赋值左侧的每个标识符都可以是一个冒号分隔的标识符对，第一个为要解构其值的属性名，第二个为要把值赋给它的变量名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于 const cosine=Math.cos, tangent=Math.tan</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">cos</span>:cosine,<span class="attr">tan</span>:tangent&#125; = <span class="built_in">Math</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端学习</tag>
      </tags>
  </entry>
  <entry>
    <title>信息与数据模型</title>
    <url>/2021/10/04/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%BF%A1%E6%81%AF%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>数据库系统的核心是数据模型。为一个数据库建立数据模型，需经过以下过程：</p>
<ol>
<li>要深入到现实世界中进行系统需求分析</li>
<li>用概念模型真实地、全面地描述现实世界中地管理对象及联系</li>
<li>通过一定地方法将概念模型转换为数据模型</li>
</ol>
<span id="more"></span>

<p>常见地数据模型有层次模型、网状模型、关系模型和面向对象模型</p>
<h3 id="信息地三种世界及描述"><a href="#信息地三种世界及描述" class="headerlink" title="信息地三种世界及描述"></a>信息地三种世界及描述</h3><p>将客观事物抽象为能用计算机存储和处理地数据需经历三个阶段：现实世界，信息世界，计算机世界（数据世界）</p>
<h5 id="现实世界："><a href="#现实世界：" class="headerlink" title="现实世界："></a>现实世界：</h5><p>现实世界客观存在的世界，在数据库中指的是对某一事物的描述，描述其各方面特征以及是否与其他事物存在联系</p>
<h5 id="信息世界："><a href="#信息世界：" class="headerlink" title="信息世界："></a>信息世界：</h5><p>信息世界是对客观事物的抽象描述，是对现实世界经过分析、归纳和抽象得到的信息，这样的信息具有一定的格式。</p>
<h5 id="计算机世界："><a href="#计算机世界：" class="headerlink" title="计算机世界："></a>计算机世界：</h5><p>计算机世界是对信息世界的再一次抽象，将其信息化，使得信息能够存储在计算机中</p>
<p>这三个领域是由客观到认识，由认识到使用管理地3个不同层次，后一领域是前一领域地抽象描述</p>
<p><img src="https://img-blog.csdnimg.cn/2020081014493058.png#pic_center" alt="三个世界，两级抽象"><img src="/2021/10/04/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%BF%A1%E6%81%AF%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/image-20201106134653255.png" alt="image-20201106134653255" style="zoom: 50%;"></p>
<p>现实世界地事物及联系，通过需求分析转换成为信息世界地概念模型，这个过程由数据库设计人员完成；然后再把概念模型转换为计算机上某个DBMS所支持地逻辑模型，这个过程由数据库设计人员和DBMS共同完成；最后逻辑模型再转换为最底层地物理模型，最终实现，这个过程由DBMS自行完成</p>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><h4 id="数据模型的概念："><a href="#数据模型的概念：" class="headerlink" title="数据模型的概念："></a>数据模型的概念：</h4><p>数据模型是对现实世界中数据特征及数据之间联系的抽象。</p>
<p>数据模型用来描述数据组成、数据关系、数据约束的抽象结构及其说明和对数据进行操作。</p>
<p>数据模型是实现数据抽象的主要工具。</p>
<p>数据模型是数据库系统的核心和基础，决定了数据库系统的结构、数据定义语言和数据操作语言、数据库设计方法、数据库管理系统软件的设计和实现。</p>
<p>数据模型应满足：</p>
<p>1.能比较真实地模拟现实世界</p>
<p>2.容易为人所理解</p>
<p>3.便于在计算机上实现</p>
<h4 id="数据处理三层抽象描述："><a href="#数据处理三层抽象描述：" class="headerlink" title="数据处理三层抽象描述："></a>数据处理三层抽象描述：</h4><h5 id="概念层："><a href="#概念层：" class="headerlink" title="概念层："></a>概念层：</h5><p>概念层是数据抽象级别的最高层，其目的是按用户的观点来对现实世界建模</p>
<p>常用的概念模型有E-R模型</p>
<h5 id="逻辑层："><a href="#逻辑层：" class="headerlink" title="逻辑层："></a>逻辑层：</h5><p>逻辑层是数据抽象的中间层，描述数据库数据整体的逻辑结构</p>
<p>常见的数据模型有层次模型、网状模型、关系模型和面向对象模型</p>
<h5 id="物理层："><a href="#物理层：" class="headerlink" title="物理层："></a>物理层：</h5><p>物理层是数据抽象的最底层，用来描述数据物理存储结构和存储方法</p>
<h4 id="数据模型的要素："><a href="#数据模型的要素：" class="headerlink" title="数据模型的要素："></a>数据模型的要素：</h4><p>数据模型通常由数据结构、数据操作和完整性约束组成</p>
<h5 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h5><p>数据结构描述数据库的组成对象以及对象之间的联系。</p>
<p>数据结构是所描述的对象类型的集合，是对系统<strong>静态特性</strong>的描述</p>
<p>静态特性：数据对象的数据类型、内容、属性以及数据对象之间的联系</p>
<h5 id="数据操作："><a href="#数据操作：" class="headerlink" title="数据操作："></a>数据操作：</h5><p>数据操作是指对数据库中各种对象的实例允许执行的操作的集合，包括操作及有关的操作规则。</p>
<p>数据操作是对系统<strong>动态特性</strong>的描述。</p>
<h5 id="数据的完整性约束条件："><a href="#数据的完整性约束条件：" class="headerlink" title="数据的完整性约束条件："></a>数据的完整性约束条件：</h5><p>数据的完整性约束条件是一组完整性规则。</p>
<p>完整性规则主要描述数据结构中数据之间的语义联系、数据之间的制约和依存关系，以及数据动态变化规则。</p>
<p>数据约束主要用于保证数据的<strong>完整性</strong>、<strong>有效性</strong>、<strong>相容性</strong></p>
<h4 id="数据模型与数据模式的区别："><a href="#数据模型与数据模式的区别：" class="headerlink" title="数据模型与数据模式的区别："></a>数据模型与数据模式的区别：</h4><p>数据模式：以一定的数据模型对一个单位的数据的类型、结构及其相互间的关系所进行的描述。  有型与值之分。</p>
<p>数据模型和数据模式的主要区别在于数据模型是描述现实世界的手段和工具；数据模式是利用这个手段和工具对相互间的关系所进行的描述。</p>
<h3 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h3><h4 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h4><p>实体（Entity）：客观存在并相互区别的事物</p>
<p>属性（Attribute）：实体所具有的某一特性，一个实体由若干个属性刻画</p>
<p>实体型（Entity Type）：用实体类型名和所有属性来共同表示同一类实体</p>
<p>实体集（Entity Set）：同型实体的集合</p>
<p>码（Key）：唯一标识实体的属性集</p>
<p>域（Domain）：属性的取值范围</p>
<p>联系（Relationship）：实体内部的联系（各属性之间的联系）和实体之间的联系（不同实体集之间的联系）</p>
<h4 id="E-R模型："><a href="#E-R模型：" class="headerlink" title="E-R模型："></a>E-R模型：</h4><h5 id="基本概念：-1"><a href="#基本概念：-1" class="headerlink" title="基本概念："></a>基本概念：</h5><p>实体用矩形框表示                                                                                    </p>
<p>属性用椭圆框表示</p>
<p>联系用菱形框表示</p>
<img src="/2021/10/04/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%BF%A1%E6%81%AF%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/image-20201106143451551.png" alt="image-20201106143451551" style="zoom: 67%;">

<p>联系分为：</p>
<p>一对一联系（1：1）；一对多联系（1：n）；多对多联系（m：n）</p>
<h5 id="E-R模型设计原则与设计步骤："><a href="#E-R模型设计原则与设计步骤：" class="headerlink" title="E-R模型设计原则与设计步骤："></a>E-R模型设计原则与设计步骤：</h5><h6 id="设计原则："><a href="#设计原则：" class="headerlink" title="设计原则："></a>设计原则：</h6><p>1.属性应该存在于且只存在于某一个地方（实体或者关联）</p>
<p>2.实体是一个单独的个体，不能存在于另一个实体中成为其属性</p>
<p>3.同一个实体在同一个E-R图内仅出现一次</p>
<h6 id="设计步骤："><a href="#设计步骤：" class="headerlink" title="设计步骤："></a>设计步骤：</h6><p>1.划分和确定实体</p>
<p>2.划分和确定联系</p>
<p>3.确定属性：能够作为属性的“事物”尽量作为属性处理</p>
<p>4画出E-R模型：重复1~3，找出所有实体集、关系集、属性和属值集，绘制E-R图。</p>
<p>5.优化E-R模型：消除数据实体间冗余的联系及属性</p>
<h3 id="逻辑模型"><a href="#逻辑模型" class="headerlink" title="逻辑模型"></a>逻辑模型</h3><h4 id="层次模型："><a href="#层次模型：" class="headerlink" title="层次模型："></a>层次模型：</h4><p>用<strong>树形结构</strong>表示各类实体以及实体间的联系</p>
<p>适用于表示记录类型之间的一对多联系，而对于多对多的联系难以直接表示</p>
<p>优缺点：</p>
<p>1.数据结构简单，查询效率高</p>
<p>2.提供良好的完整性支持</p>
<p>3.不易表示多对多的联系</p>
<p>4.数据操作限制多、独立性较差</p>
<p>5.节点的双亲是唯一的（每节点只有一个副节点）</p>
<h4 id="网状模型："><a href="#网状模型：" class="headerlink" title="网状模型："></a>网状模型：</h4><p>用<strong>图结构</strong>表示各类实体集以及实体集间的联系</p>
<p>网状模型允许节点由多个双亲节点，允许多个节点没有双亲节点</p>
<p>一个子节点可以有多个父节点；在两个节点之间可以有多种联系</p>
<p>对于多对多的联系难以直接表示</p>
<p>优缺点：</p>
<p>1.较为直接地描述现实世界</p>
<p>2.存储效率较高</p>
<p>3.结构较复杂、不易使用</p>
<p>4.数据独立性较差</p>
<h4 id="关系模型："><a href="#关系模型：" class="headerlink" title="关系模型："></a>关系模型：</h4><p>是最重要的一种基本模型，也是目前应用最广泛的数据模型</p>
<p>关系就是一张二维表，有行和列组成</p>
<p>在关系模型中实体以及实体之间的联系都用关系即<strong>二维表</strong>表示</p>
<p>优缺点：</p>
<p>1.有坚实的理论基础</p>
<p>2.结构简单、易用</p>
<p>3.数据具有较强的独立性及安全性</p>
<p>4.查询效率较低</p>
<h4 id="面向对象模型："><a href="#面向对象模型：" class="headerlink" title="面向对象模型："></a>面向对象模型：</h4><p>是用<strong>面向对象</strong>的观点来描述现实世界中的事物（对象）的逻辑结构和对象间的联系等的数据结构</p>
<p>对象：对现实世界中的事物的高度抽象，每个对象是状态和行为的封装</p>
<p>对象的状态是属性的集合，行为是在该对象上操作方法的集合</p>
<p>优缺点：</p>
<p>1.适合处理各种各样的数据类型：面向对象数据库适合存储不同类型的数据，例如图片、声音、视频，包括文本、数字等</p>
<p>2.面向对象程序设计于数据库技术相结合</p>
<p>3.提高开发效率：面向对象数据模型提供强大的特性，例如继承、多态和动态绑定，允许用户不用编写特定对象的代码就可以构成对象并提供解决方案</p>
<p>4.改善数据访问：支持导航式和关联式两种方式的信息访问，比基于关系值得联系更能提高数据访问性能</p>
<p>5.没有准确的定义</p>
<p>6.维护困难</p>
<p>7.不适合所有的应用</p>
<h3 id="概念模型向逻辑模型的转换"><a href="#概念模型向逻辑模型的转换" class="headerlink" title="概念模型向逻辑模型的转换"></a>概念模型向逻辑模型的转换</h3><h4 id="实体的转换："><a href="#实体的转换：" class="headerlink" title="实体的转换："></a>实体的转换：</h4><p>实体转换为关系模型，一个实体对应一个关系模型，实体的名称即是关系模型的名称，实体的属性就是关系模型的属性，实体的码就是关系模型的码</p>
<h4 id="联系的转换："><a href="#联系的转换：" class="headerlink" title="联系的转换："></a>联系的转换：</h4><h5 id="1-：1转换："><a href="#1-：1转换：" class="headerlink" title="1   ：1转换："></a>1   ：1转换：</h5><p>方法一：将1：1联系转换成一个独立的关系模式，与该联系相连的各实体的码以及联系本身的属性均转换为关系模式的属性，<strong>每个实体的码均是该关系模式的码</strong></p>
<p>方法二：与任意一端对应的关系模式合并。合并时，在该关系模式的属性中应加入<strong>另一个关系模式的码</strong>和<strong>联系本身的属性</strong></p>
<p>例：学生（<u>学号</u>，姓名）</p>
<p>​        校园卡（<u>卡号</u>，余额）</p>
<p>​        学生办卡有办卡日期</p>
<p>方法一转换后：</p>
<p>​        实体转换：学生（<u>学号</u>，姓名）   校园卡（<u>卡号</u>，余额）</p>
<p>​        联系转换：办卡（<u>学号</u>，<u>卡号</u>，办卡日期）</p>
<p>方法二转换后：</p>
<p>​        学生（<u>学号</u>，<u>卡号</u>，姓名，办卡日期）或</p>
<p>​        校园卡（<u>卡号</u>，<u>学号</u>，余额，办卡日期）</p>
<h5 id="1-：n转换："><a href="#1-：n转换：" class="headerlink" title="1   ：n转换："></a>1   ：n转换：</h5><p>方法一：转换为一个独立的关系模式，与该联系相连的各实体的码以及联系本身的属性均转换为关系模式的属性，而<strong>关系模式的码为n端实体的码</strong></p>
<p>方法二：与n端对应的关系模式合并，在该关系模式中加入<strong>1端实体的码</strong>和<strong>联系本身的属性</strong></p>
<p>例：学生（<u>学号</u>，性别，姓名）</p>
<p>​        班级（<u>班号</u>，班名）</p>
<p>​        一个学生只能在一个班级学习，一个班级包含多个学生，班级：学生=1：n</p>
<p>方法一转换后：</p>
<p>​        实体转换：学生（<u>学号</u>，性别，姓名）   班级（<u>班号</u>，班名）</p>
<p>​        联系转换：组成（<u>学号</u>，班号）</p>
<p>方法二转换后：<br>        实体转换：学生（<u>学号</u>，性别，姓名）   班级（<u>班号</u>，班名）</p>
<p>​        联系转换：与学生一端合并，学生（<u>学号</u>，<u>班号</u>，性别，姓名）</p>
<h5 id="m-：n转换："><a href="#m-：n转换：" class="headerlink" title="m  ：n转换："></a>m  ：n转换：</h5><p>将联系单独转换为一个独立的关系模式，与该联系相连的各实体的码以及联系本身的属性均转换为关系模式的属性，每个实体的码组成关系模式的码或关系模式的码的一部分</p>
<p>例：学生（<u>学号</u>，性别，姓名）</p>
<p>​        课程（<u>课程号</u>，课程名）</p>
<p>​        一个学生可以选修多门课程，一门课程可以由多个学生选修。   学生：课程=m：n</p>
<p>​        转换后：</p>
<p>​        实体转换： 学生（<u>学号</u>，性别，姓名）    课程（<u>课程号</u>，课程名）</p>
<p>​        联系转换：选修（<u>学号</u>，<u>课程号</u>，成绩）</p>
<p>具有相同码的关系模式将其中一个关系模式的属性都加到另一个关系模式中，去掉同义属性</p>
<h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><p>关系模型的数据结构为具有一定特征的二维表。</p>
<p>在关系数据库中，数据以关系表形式存储实体数据，关系是一个由行和列组成的二维表</p>
<h4 id="关系数据结构："><a href="#关系数据结构：" class="headerlink" title="关系数据结构："></a>关系数据结构：</h4><h5 id="基本术语："><a href="#基本术语：" class="headerlink" title="基本术语："></a>基本术语：</h5><h6 id="表（Table）"><a href="#表（Table）" class="headerlink" title="表（Table）"></a>表（Table）</h6><p>表，也称为关系，是一个二维的数据结构，由表名、构成表的各个列及若干行数据组成</p>
<h6 id="关系（Relation）"><a href="#关系（Relation）" class="headerlink" title="关系（Relation）"></a>关系（Relation）</h6><p>一个关系逻辑上对应一张二维表，可以为每个关系取一个名称进行标识，即表名</p>
<h6 id="列（Column）"><a href="#列（Column）" class="headerlink" title="列（Column）"></a>列（Column）</h6><p>列，也称为字段或属性，每一列有一个名称，每一列表示实体的一个属性，具有相同的数据类型</p>
<h6 id="属性（Attribute）"><a href="#属性（Attribute）" class="headerlink" title="属性（Attribute）"></a>属性（Attribute）</h6><p>一列即一个属性，表中属性的个数称为关系的元或度，列的值称为属性值，属性值得取值范围为值域</p>
<h6 id="行（Row）"><a href="#行（Row）" class="headerlink" title="行（Row）"></a>行（Row）</h6><p>行即元组或记录</p>
<h6 id="元组（Tuple）"><a href="#元组（Tuple）" class="headerlink" title="元组（Tuple）"></a>元组（Tuple）</h6><p>表中得一行即为一个元组</p>
<h6 id="分量（Component）"><a href="#分量（Component）" class="headerlink" title="分量（Component）"></a>分量（Component）</h6><p>元组中的一个属性值，组成元组的元素</p>
<h6 id="码或键（Key）"><a href="#码或键（Key）" class="headerlink" title="码或键（Key）"></a>码或键（Key）</h6><p>在一个关系中，存在这样的属性（或属性组）使得在该关系的任何一个关系状态中的两个元组，在该属性（或属性组）上值得组合都不相同，即这些属性（或属性组）的值都能用来<strong>唯一标识该关系的元组</strong>，这属性（或属性组）即为码</p>
<h6 id="超码或超键（Super-Key）"><a href="#超码或超键（Super-Key）" class="headerlink" title="超码或超键（Super Key）"></a>超码或超键（Super Key）</h6><p>如果在关系的一个码中移去某个属性，它仍然是这个关系的码，即为超键</p>
<h6 id="候选码或候选键（Candidate-Key）"><a href="#候选码或候选键（Candidate-Key）" class="headerlink" title="候选码或候选键（Candidate Key）"></a>候选码或候选键（Candidate Key）</h6><p>若关系中的某一属性（或属性组）的值能唯一标识一个元组，则称该属性（或属性组）为候选码</p>
<h6 id="主码（Primary-Key）"><a href="#主码（Primary-Key）" class="headerlink" title="主码（Primary Key）"></a>主码（Primary Key）</h6><p>在一个关系的若干个候选码中指定一个用来唯一标识关系的元组，则指定的即为主码</p>
<p>当包含两个或多个的键称为<strong>复合码</strong></p>
<p>主码的作用：</p>
<ul>
<li>唯一标识关系的每行</li>
<li>作为关联表的外键，链接两个表</li>
<li>使用主码值来组织关系的存储</li>
<li>使用主码索引快速检索数据</li>
</ul>
<h6 id="全码（All-Key）"><a href="#全码（All-Key）" class="headerlink" title="全码（All-Key）"></a>全码（All-Key）</h6><p>一个关系模式的所有属性集合是这个关系的主码，则这样的主码为全码</p>
<h6 id="主属性（Primary-Attribute）和非主属性（Nonprimary-Attribute）"><a href="#主属性（Primary-Attribute）和非主属性（Nonprimary-Attribute）" class="headerlink" title="主属性（Primary Attribute）和非主属性（Nonprimary Attribute）"></a>主属性（Primary Attribute）和非主属性（Nonprimary Attribute）</h6><p>关系中包含在任何一个候选码中的属性称为主属性，不包含在任何一个候选码中的属性称为非主属性</p>
<h6 id="代理键"><a href="#代理键" class="headerlink" title="代理键"></a>代理键</h6><p>代理键是具有DBMS分配的唯一标识符，每次创建行时由DBMS分配代理键的唯一值</p>
<h6 id="外码或外键（Foreign-Key）"><a href="#外码或外键（Foreign-Key）" class="headerlink" title="外码或外键（Foreign Key）"></a>外码或外键（Foreign Key）</h6><p>当关系中的某个属性（或属性组）不是这个关系的主码或候选码，而是另一关系的主码时，则该属性为外键</p>
<p>外码并不一定要与相应的主码同名</p>
<h6 id="参照关系（Referencing-Relation）和被参照关系（Referenced-Relation）"><a href="#参照关系（Referencing-Relation）和被参照关系（Referenced-Relation）" class="headerlink" title="参照关系（Referencing Relation）和被参照关系（Referenced Relation）"></a>参照关系（Referencing Relation）和被参照关系（Referenced Relation）</h6><p>参照关系即从关系，被参照关系即主关系，值以外码相关联的两个关系。以外码作为主键的关系称为被参照关系；外码所在的关系称为参照关系，被参照关系与参照关系是通过外码相联系的，这种联系通常时一对多的联系</p>
<h6 id="域（Domain）"><a href="#域（Domain）" class="headerlink" title="域（Domain）"></a>域（Domain）</h6><p>属性的取值范围</p>
<h6 id="数据类型（Data-Type）"><a href="#数据类型（Data-Type）" class="headerlink" title="数据类型（Data Type）"></a>数据类型（Data Type）</h6><p>表中每列都有相应的数据类型，它用于限制该列中存储的数据</p>
<h5 id="关系类型-Relation-Type"><a href="#关系类型-Relation-Type" class="headerlink" title="关系类型(Relation Type)"></a>关系类型(Relation Type)</h5><p>关系类型有三类：<strong>基本关系</strong>（基本表或基表）、<strong>查询表</strong>和<strong>视图表</strong></p>
<p>基本表：是实际存在的表，是实际存储数据的逻辑表示</p>
<p>查询表：是查询结果表或查询中生成的临时表</p>
<p>视图表：是由基本表或其他视图表导出的表，是<strong>虚表</strong>，不对应实际存储的数据</p>
<h5 id="关系模式（Relation-Schema）"><a href="#关系模式（Relation-Schema）" class="headerlink" title="关系模式（Relation Schema）"></a>关系模式（Relation Schema）</h5><p>数据库有型和值之分。在关系数据库中，关系模式是型，关系是值，即关系模式是对关系的描述。关系模式是对关系的描述。关系模式是静态的，稳定的，而关系是动态的、随时间不断变化的。</p>
<p>关系模式可以表示为五元组R(U,D,Dom,F)</p>
<ul>
<li>R：关系名</li>
<li>U：组成该关系的属性的集合</li>
<li>D：属性组U中的属性所来自的域</li>
<li>Dom：属性向域的映像集合</li>
<li>F：属性间数据依赖关系的集合</li>
</ul>
<p>五元组可以简化为二元组R(U)</p>
<h5 id="关系数据库（Relation-Database）"><a href="#关系数据库（Relation-Database）" class="headerlink" title="关系数据库（Relation Database）"></a>关系数据库（Relation Database）</h5><p>关系数据库是以关系模型作为数据的逻辑模型</p>
<h4 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h4><h5 id="基本的关系操作"><a href="#基本的关系操作" class="headerlink" title="基本的关系操作"></a>基本的关系操作</h5><p>关系操作包括<strong>数据查询</strong>、<strong>数据维护</strong>和<strong>数据控制</strong></p>
<p>数据控制是为了保证数据的安全性和完整性而采用的<strong>数据存取控制</strong>和<strong>并发控制</strong>等功能</p>
<h6 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h6><p>选择、投影、连接、除、并、交、差、笛卡尔积</p>
<h6 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h6><p>插入、删除、修改</p>
<p>查询的表达能力很强，是其中最主要的部分</p>
<h6 id="关系操作的特点"><a href="#关系操作的特点" class="headerlink" title="关系操作的特点"></a>关系操作的特点</h6><p>集合操作方式，即操作的对象和结果都是集合</p>
<h4 id="关系操作语言的分类"><a href="#关系操作语言的分类" class="headerlink" title="关系操作语言的分类"></a>关系操作语言的分类</h4><p>关系操作的能力可以用两种方式来表示：<strong>代数方式</strong>和<strong>逻辑方式</strong></p>
<p>代数方式主要有<strong>关系代数</strong>，它是通过对关系的操作来表达查询要求的方式</p>
<p>逻辑方式主要有<strong>关系演算</strong>，它是用谓词来表达查询要求的方式</p>
<p>具有关系代数和关系演算双重特点的语言 如SQL</p>
<p>这些语言都具有的特点：</p>
<ul>
<li>具有完备的表达能力</li>
<li>是非过程化的集合操作语言</li>
<li>功能强</li>
<li>能够嵌入高级语言使用</li>
</ul>
<h4 id="关系的完整性约束"><a href="#关系的完整性约束" class="headerlink" title="关系的完整性约束"></a>关系的完整性约束</h4><h5 id="实体完整性约束"><a href="#实体完整性约束" class="headerlink" title="实体完整性约束"></a>实体完整性约束</h5><p>实体完整性约束是指关系的主属性，即主码的组成不能为空，即主属性不能是空值NULL</p>
<h5 id="参照完整性约束"><a href="#参照完整性约束" class="headerlink" title="参照完整性约束"></a>参照完整性约束</h5><p>现实世界中的实体之间往往存在的某种联系</p>
<p>若属性（或属性组）F是基本关系R的外码，它域基本关系S的主码Ks相对应（R和S有可能是同一关系），则对于R中每个元组在F上的值必须为</p>
<ul>
<li>空值</li>
<li>等于S中某个元组的主码值</li>
</ul>
<h5 id="用户完整性约束"><a href="#用户完整性约束" class="headerlink" title="用户完整性约束"></a>用户完整性约束</h5><p>用户定义的完整性约束是针对某一应用环境的完整性约束条件，它反映了某一具体应用所涉及的数据应满足的要求</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>大学课程</tag>
      </tags>
  </entry>
  <entry>
    <title>中小型网络系统总体规划与设计</title>
    <url>/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h2><ul>
<li><p>局域网（LAN）</p>
<p>特点</p>
<ul>
<li>覆盖有限的地理范围</li>
<li>提供高数据传输效率（10Mbps~10Gbps）</li>
<li>易于建立、维护与扩展</li>
</ul>
<p>分类：</p>
<ul>
<li>介质访问方法可分为介质式局域网与交换式局域网</li>
<li>传输介质类型可分为有线局域网与无线局域网</li>
</ul>
</li>
</ul>
<span id="more"></span>

<ul>
<li><p>城域网（MAN）</p>
<p>介于广域网与局域网之间的一种高速网络，覆盖范围为几十公里</p>
</li>
<li><p>广域网</p>
<p>也称远程网，覆盖范围从几十公里到几千公里</p>
<p>因特网是广域网中最大的一个，广域网包含因特网</p>
</li>
</ul>
<h2 id="计算机网络结构的特点"><a href="#计算机网络结构的特点" class="headerlink" title="计算机网络结构的特点"></a>计算机网络结构的特点</h2><p>早期的广域网</p>
<p>逻辑功能上分为两部分：资源子网和通信子网</p>
<p>用户计算机接入</p>
<p>用户计算机可以通过局域网方式连入，也可以通过电话交换网（<strong>PSTN</strong>）、有线电视网（<strong>CATV</strong>）、无线城域网（<strong>WMAN</strong>）、或无线局域网（<strong>WLAN</strong>）接入地区级主干网的城域网</p>
<h2 id="广域网技术的发展（了解）"><a href="#广域网技术的发展（了解）" class="headerlink" title="广域网技术的发展（了解）"></a>广域网技术的发展（了解）</h2><ol>
<li><p>广域网是一种公共数据网络</p>
</li>
<li><p>构建广域网的核心交换技术</p>
<ul>
<li>公共电话交换网PSTN</li>
<li>综合业务数字网ISDN</li>
<li>数字数据网DDN</li>
<li>X.25 分组交换网</li>
<li>帧中继（Frame Replay，FR）网</li>
<li>异步传输模式（Asynchronous Transfer Mode，ATM）网</li>
<li>GE（Gigabit Ethernet，千兆以太网）与10GE的光以太网（Optical Ethernet）</li>
</ul>
</li>
</ol>
<h2 id="局域网技术的发展（了解）"><a href="#局域网技术的发展（了解）" class="headerlink" title="局域网技术的发展（了解）"></a>局域网技术的发展（了解）</h2><p>三个方向：</p>
<p>1.提高以太网的数据传输速率</p>
<p>2.将一个大型局域网划分成多个用网桥或路由器互联的网络</p>
<p>3.将共享介质方式改为交换方式。</p>
<p>​    在交换式局域网的基础上，出现了虚拟局域网（Virtual LAN，VLAN）</p>
<h2 id="城域网技术的发展"><a href="#城域网技术的发展" class="headerlink" title="城域网技术的发展"></a>城域网技术的发展</h2><p>宽带城域网的出现，使得传统的通信网络在概念、技术与应用上都发生了很多的变化。这些变化主要表现在</p>
<ul>
<li>局域网、城域网与广域网在技术上的界限变得越来越模糊了</li>
<li>电信传输网技术与计算机网络技术的界限变得越来越模糊了</li>
<li>电信服务业务与Internet应用的界限变得越来越模糊了</li>
<li>电信传输网、计算机网络与广播电视网的界限变得越来越模糊了</li>
</ul>
<h2 id="宽带城域网的结构"><a href="#宽带城域网的结构" class="headerlink" title="宽带城域网的结构"></a>宽带城域网的结构</h2><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>设计一个宽带城域网将涉及“三个平台和一个出口”，即<strong>网络平台</strong>、<strong>业务平台</strong>、<strong>管理平台</strong>与<strong>城市宽带出口</strong>等问题</p>
<img src="/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/%E7%AC%AC%E4%B8%80%E7%AB%A0/image-20210307191201810-16354230269251.png" alt="image-20210307191201810" style="zoom:67%;">



<h3 id="网络平台的层次结构"><a href="#网络平台的层次结构" class="headerlink" title="网络平台的层次结构"></a>网络平台的层次结构</h3><h4 id="核心交换层的基本功能"><a href="#核心交换层的基本功能" class="headerlink" title="核心交换层的基本功能"></a>核心交换层的基本功能</h4><ul>
<li>核心交换层将多个汇聚层连接起来，<strong>为汇聚层的网络提供高速转发</strong>，为整个城域网提供一个高速、安全与<strong>具有 QoS 保障能力</strong>的数据传输环境</li>
<li>核心交换层实现与主干网络的互联，<strong>提供城市的带宽 IP 数据出口</strong></li>
<li>核心交换层提供带宽城域网的用户<strong>访问 Internet 所需要的路由服务</strong></li>
</ul>
<h4 id="汇聚层的基本功能"><a href="#汇聚层的基本功能" class="headerlink" title="汇聚层的基本功能"></a>汇聚层的基本功能</h4><ul>
<li><strong>汇聚接入层的用户流量</strong>，进行数据分组传输的汇聚、转发、与交换</li>
<li>根据汇聚接入层的用户流量，进行<strong>本地</strong>路由、过滤、流量均衡、Qos 优先级管理，以及安全控制、IP 地址转换、流量整形等处理</li>
<li>根据处理结果把<strong>用户流量转发到核心交换层</strong>或<strong>本地进行路由处理</strong></li>
</ul>
<h4 id="接入层的基本功能"><a href="#接入层的基本功能" class="headerlink" title="接入层的基本功能"></a>接入层的基本功能</h4><ul>
<li>接入层解决的是“最后一公里”的问题。通过各种接入技术，<strong>连接最终用户</strong>，为它所覆盖范围内的用户提供访问 Internet 以及其他的信息服务</li>
</ul>
<h4 id="三层结构思想："><a href="#三层结构思想：" class="headerlink" title="三层结构思想："></a>三层结构思想：</h4><ul>
<li>上层负责下层的数据汇聚</li>
<li>核心层提供出口与 QoS、汇聚本地路由，接入服务用户 </li>
<li>核心层：主要承担高速数据交换的功能</li>
<li>汇聚层：主要承担路由与流量汇聚的功能</li>
<li>接入层：主要承担用户接入与本地流量控制的功能</li>
<li>核心交换层 =&gt; 汇聚层 =&gt; 接入层</li>
</ul>
<h2 id="宽带城域网组建的基本原则（了解）"><a href="#宽带城域网组建的基本原则（了解）" class="headerlink" title="宽带城域网组建的基本原则（了解）"></a>宽带城域网组建的基本原则（了解）</h2><p>可运营性、<strong>可管理性</strong>、可盈利性、可扩展性</p>
<p>宽带的城域网设备必须支持对用户的<strong>身份认证</strong>、<strong>使用权限认证</strong>和<strong>计费功能</strong>。业务管理要支持多ISP、基于IP的虚拟专网VPN等多种增值业务</p>
<p>宽带城域网必须具备<strong>IP地址分配</strong>能力，能够支持动态和静态地址分配，支持网络地址转换<strong>NAT</strong>功能</p>
<p>宽带城域网必须能够为用户提供<strong>带宽保证</strong>，实现<strong>流量工程</strong>，提供个性化用户策略的<strong>Qos保证</strong>。</p>
<h2 id="管理和运营宽带城域网的关键技术"><a href="#管理和运营宽带城域网的关键技术" class="headerlink" title="管理和运营宽带城域网的关键技术"></a>管理和运营宽带城域网的关键技术</h2><h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><ol>
<li>宽带管理</li>
<li><strong>网络管理</strong></li>
<li><strong>服务质量QoS</strong></li>
<li><strong>用户管理</strong></li>
<li><strong>IP 地址的分配与地址转换</strong></li>
<li>多业务接入</li>
<li>统计与计费</li>
<li>网络安全</li>
</ol>
<h3 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h3><ol>
<li><strong>带内网络管理是指利用传统的电信网络，通过数据通信网（ DCN ）或公共交换电话网（ PSTN ）拨号，对网络设备进行数据配置；</strong></li>
<li><strong>带外网络管理是指利用 IP 网络及协议进行网络管理，是利用简单网络管理协议（ SNMP ）建立网络管理系统；</strong></li>
<li><strong>对汇聚层一下采用带内管理，而对汇聚层及其以上设备采取带外管理；</strong></li>
</ol>
<h3 id="服务质量QoS"><a href="#服务质量QoS" class="headerlink" title="服务质量QoS"></a><strong>服务质量QoS</strong></h3><ul>
<li><strong>在带宽城域网业务中有多媒体业务、数据业务与普通话的语音服务；网络服务质量表现在延时、抖动、吞吐量和丢包率等几个方面；</strong></li>
<li>目前宽带城域网保证 QoS 要求的技术主要有：**资源预留(RSVP)<strong>、</strong>区分服务(DiffServ)<strong>、与</strong>多协议标记交换(MPLS)**。</li>
</ul>
<h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>宽带城域网的用户管理应该包括用户认证与接入管理、计费管理等，<strong>能够为用户提供宽带保证，实现流量工程</strong>。</p>
<h3 id="IP-地址分配与地址转换"><a href="#IP-地址分配与地址转换" class="headerlink" title="IP 地址分配与地址转换"></a>IP 地址分配与地址转换</h3><p>为了解决 IP 地址不足的问题，目前的<strong>基本方案是使用内部专用 IP 地址与网络地址转换（ NAT ）技术，只为宽带城域网的关键设备与特殊用户分配固定的公用 IP 地址</strong>。</p>
<h2 id="构建宽带城域网的基本技术与方案"><a href="#构建宽带城域网的基本技术与方案" class="headerlink" title="构建宽带城域网的基本技术与方案"></a>构建宽带城域网的基本技术与方案</h2><h3 id="基于SDH的城域网方案"><a href="#基于SDH的城域网方案" class="headerlink" title="基于SDH的城域网方案"></a>基于SDH的城域网方案</h3><p>早期的SONET/SDH是为传统电信业务服务的，它并不适合于传输IP分组</p>
<h3 id="基于10GE的城域网方案"><a href="#基于10GE的城域网方案" class="headerlink" title="基于10GE的城域网方案"></a>基于10GE的城域网方案</h3><p>光以太网是以太网与 DWDM 技术相结合的产物，其<strong>造价是SONET的1/5，是ATM的1/10</strong>。可运营光以太网的设备和线路必须符合典型网络 99.999% 的高运行可靠性，并具备以下特征</p>
<ol>
<li>能供<strong>根据终端用户的实际应用需求分配带宽</strong>，保证带宽资源充分、合理的应用</li>
<li><strong>具有认证与授权功能</strong>，用户范文网络资源必须经过认证和授权，确保用户和网络资源的安全及合法使用</li>
<li><strong>支持 MPLS（ 多协议标签交换 ）</strong>，具有一定的质量保证，<strong>提供分等级的 Qos 网络服务</strong></li>
<li><strong>提供计费功能</strong>，能及时获得用户的上网时间记录和流量记录，支持按上网时间、用户流量计费，或提供包月计费方式，支持实时计费</li>
<li><strong>支持 VPN 和防火墙</strong>，可以有效的保护网络安全</li>
<li>能够方便、快速、灵活的适应用户和业务的扩展</li>
</ol>
<h3 id="基于弹性分组环RPR技术的城域网（掌握）"><a href="#基于弹性分组环RPR技术的城域网（掌握）" class="headerlink" title="基于弹性分组环RPR技术的城域网（掌握）"></a>基于弹性分组环RPR技术的城域网（掌握）</h3><p>弹性分组环是一种直接<strong>在光纤上高校传输IP分组</strong>的传输技术，它的工作基础是<strong>Cisco公司</strong>提出的<strong>动态分组传送</strong>（Dynamic Packet Transport, DPT）技术</p>
<p>RPR 采用<strong>双环结构</strong>，有<strong>内环</strong>和<strong>外环</strong>。<strong>顺时针传输</strong>的光纤为<strong>外环</strong>，<strong>逆时针传输</strong>的光纤为<strong>内环</strong>。两环均可以用<strong>统计复用</strong>的方法传输 IP 分组，且可以实现“自愈环”的功能，<strong>均可以传输数据分组与控制分组</strong></p>
<p>每一个结点都可以使用两个方向的光纤与相邻结点通信。这样做的目的除了<strong>高效地利用光纤带宽</strong>之外，还有一个目的是<strong>加速控制分组传输</strong>，<strong>提高环的可靠性</strong>，<strong>实行“环自愈”功能</strong>，保证城域网的系统可靠性与服务质量</p>
<p>两个 RPR 节点之间的裸光纤的最大长度可达到 <strong>100km</strong></p>
<ol>
<li><strong>公平性好：</strong>RPR 环中<strong>每个节点都执行</strong> <strong>SRP 公平算法</strong>，是的节点之间能供获得平等的带宽，防止个节点因流量过大而照成环拥塞。同时，RPR 环还支持加权公平法则和入口、出口峰值速率限制，用于保证能够根据用户购买的宽带提供相应的服务</li>
<li><strong>带宽的利用率高：RPR 采用双环结构传输数据分组和控制分组</strong>，<strong>并限制数据帧只在源结点与目的结点之间的光纤段上传输，当源节点成功发送一个数据帧之后，这个数据帧要由目的节点从环中收回</strong>。如此，该数据帧将不再占用下游段的环带宽，从而提高环带宽的利用率</li>
<li><strong>保证服务质量：</strong>RPR 环对不同的业务数据分配不同的优先级，以保证高优先级信息的可靠传输，从而保证了网络服务质量</li>
<li><strong>快速保护和恢复能力：</strong>RPR 有<strong>自愈环</strong>的功能，能够在<strong>50ms</strong>时间内，<strong>隔离出故障节点和光纤段</strong>，并可在没有专用带宽的前提下即能够提供 SDH 及的快速保护和恢复</li>
</ol>
<h2 id="网络接入技术与方法"><a href="#网络接入技术与方法" class="headerlink" title="网络接入技术与方法"></a>网络接入技术与方法</h2><p>目前，可以用作用户接入网的主要有三类：计算机网络、电信通信网与广播电视网</p>
<p>“三网融合”——计算机网络、电信通信网与电视通信网</p>
<ul>
<li>从用户接入角度：用户接入可以分为接入技术与接入方式两种类型，其中接入方式与用户工作环境与需求相关</li>
<li>从技术实现的角度，目前宽带接入技术主要有：<strong>数字用户线（ xDSL ）技术</strong>、<strong>光纤同轴电缆混合网（ HFC ）技术</strong>、<strong>光纤接入技术</strong>、<strong>局域网接入技术</strong>以及<strong>无线接入技术</strong>。其中，无线接入又可以分为无线局域网接入、无线城域网接入与无线 AD hoc 接入</li>
</ul>
<h2 id="各种接入技术的特点"><a href="#各种接入技术的特点" class="headerlink" title="各种接入技术的特点"></a>各种接入技术的特点</h2><h3 id="数字用户线-xDSL-接入技术"><a href="#数字用户线-xDSL-接入技术" class="headerlink" title="数字用户线 xDSL 接入技术"></a>数字用户线 xDSL 接入技术</h3><p>xDSL 中 x 的意思是表示它的不同类型,例如，可以理解 x 是 A、H 或 RA 等，他们对应于不同的数字用户线技术。xDSL 技术根据上行（ 用户到交换局 ）和下行（ 交换局到用户 ）的速率是否相同可分为<strong>速率对称型</strong>和<strong>速率非对称型</strong>两种</p>
<ul>
<li>非对称数字用户线（ Asymmetric Digital Subscriber Line , <strong>ADSL</strong> ）</li>
<li>过比特率数字用户线（ High bitrate DSL, <strong>HDSL</strong> ）</li>
<li>速率自适应数字用户线（ Rate adaptive DSL, <strong>RADSL</strong> ）</li>
<li>甚高比特率数字用户线（ Very high bit rate DSL, <strong>VDSL</strong> ）</li>
</ul>
<p>ADSL 的技术特点主要表现在如下几个方面</p>
<ul>
<li>能够利用现有的用户电话铜双绞线，以重叠和不干扰传统模拟电话业务的方式，即普通电话业务（POTS）的方式，提供高速数字业务。<strong>ADSL 允许用户在保留已有的模拟电话业务</strong>的同时，进行 Internet 在线访问、视频点播（VOD）的新型矿带业务</li>
<li>该技术与本地环路由的实际参数以及用户电话铜双绞线的特性关系都不大，所以用户<strong>不需要进行电缆的重新铺设</strong></li>
<li><strong>上行速率在 64 ~ 640Kbit/s，下行速率在 5000kbit/s ~ 7Mbit/s。用户根据需要自行选择</strong></li>
</ul>
<p>数据用户线 xDSL 接入技术的上行与下行速率：</p>
<table>
<thead>
<tr>
<th>xDSL</th>
<th>上/下行速率（距离 5.5km）</th>
<th>上/下行速率（ 距离 3.6km ）</th>
<th>是否对称</th>
<th>线对称</th>
</tr>
</thead>
<tbody><tr>
<td>ADSL</td>
<td>64kbps/1.5Mbps</td>
<td>640kbps/6Mbps</td>
<td>否</td>
<td>1</td>
</tr>
<tr>
<td><strong>HDSL</strong></td>
<td><strong>1.554Mbps</strong></td>
<td><strong>1.5554Mbps</strong></td>
<td><strong>是</strong></td>
<td>2</td>
</tr>
<tr>
<td>VDL</td>
<td>2.3Mbps/51Mbps</td>
<td>2.3Mbps/51Mbps</td>
<td>否</td>
<td>2</td>
</tr>
<tr>
<td>RADSL</td>
<td>64kbps/1.5Mbps</td>
<td>640kbps/6Mbps</td>
<td>否</td>
<td>1</td>
</tr>
</tbody></table>
<h3 id="光纤同轴电缆合网接入技术"><a href="#光纤同轴电缆合网接入技术" class="headerlink" title="光纤同轴电缆合网接入技术"></a>光纤同轴电缆合网接入技术</h3><p>光纤同轴混合网HFC是<strong>新一代有线电视网络</strong>。光纤同轴电缆混合网HFC是一个<strong>双向传输系统</strong>。光纤结点将光纤干线和同轴分配线相互连接</p>
<ul>
<li><p>光纤同轴电缆合网的基本结构</p>
<ul>
<li>是由电视头端、放大器、馈线与下引线组成。</li>
<li>新一代的有限电视网络，是一个 <strong>双向传输系统</strong> ，光纤节点通过电缆下引线可以为 <strong>500 ~ 2000 个用户服务</strong></li>
<li>改善了信号质量，提高了可靠性**，线路可以使用的宽带甚至可以达到 <strong>1GHz</strong></li>
<li>从用户接入的角度来看，管线到 HFC 是经过双向改造的有限电视网络，是用户通过有线电视宽带接入 Internet 的一种重要的方式</li>
<li>是使用 Cable Modem，通过有限电视宽带接入 Interent 的，数据传输速率可达 10 ~ 36Mbit/s</li>
</ul>
</li>
<li><p>电缆调制解调器（Cable ModeM)</p>
<p><strong>Cable Modem 把用户计算机与有线电视同轴电缆连接起来</strong>，不仅有调制解调功能，也带有加密解密和协议适配，以及网桥、路由器与集线器的部分功能。Cable Modem 利用 <strong>频分复用</strong> 的方法，<strong>将双向信道分为：从计算机终端到网络方向称为上行信道，从网络到计算机终端方向称为下行信道</strong>。上行信道带宽一般在<strong>200 kbps ~ 10 Mbps</strong></p>
<ul>
<li>从 <strong>数据传输</strong> 方向上，Cable Modem 可分为单向、双向两类</li>
<li>从 <strong>传输方式</strong> 上，Cable Modem 可以分为<strong>双向对称式传输</strong>和<strong>非对称式传输两类</strong></li>
<li>从 <strong>同步方式</strong> 上，Cable Modem 可分为类似于 Etheme 的同步交换和类似于 ATM 技术的一部交换两类</li>
<li>从 <strong>接入的角度</strong>，Cable Modem 可分为个人 Cable Modem 和宽带多用户Cable Modem</li>
<li>从 <strong>接口角度</strong>，Cable Modem 可分为外置式，内置式和交互式机顶盒 3 种</li>
</ul>
</li>
</ul>
<h3 id="光纤接入技术"><a href="#光纤接入技术" class="headerlink" title="光纤接入技术"></a>光纤接入技术</h3><p>APON（宽带无源光网络）是 ATMPON 的简称。<strong>ATM 是一种基于信元的传输协议</strong>，能为接入网 <strong>提供动态的宽带分配</strong>，从而更适合宽带数据业务的需求</p>
<p>EPON（以太网无源光网络）是级语以太网的 PON 技术。EPON 采用点到多点结构、无源光纤传输，在以太网之上提供多种业务，<strong>EPON 是一种实现光纤到户的重要技术</strong></p>
<ul>
<li>无线光纤网（PON）是 ITU “基于无源光纤网的高速光纤接入系统”下进行标准化的</li>
<li><strong>OC-3, 155.520Mbit/s 的对称业务</strong></li>
<li><strong>上行 OC-3, 155.520Mbit/s; 下行 OC-12, 622.020Mbit/s 的不对称业务</strong></li>
<li><strong>OC-(n) = 51.84 * n Mbps</strong></li>
<li>传输介质可以是一根或两根单模光纤，双向传输通过波分复用（一根或两根光纤）实现</li>
</ul>
<h3 id="宽带无线接入技术"><a href="#宽带无线接入技术" class="headerlink" title="宽带无线接入技术"></a>宽带无线接入技术</h3><ol>
<li><p>无线接入技术的分类与应用</p>
<p><strong>近距离使用可以采用 IEEE802.11 标准的无线局域网技术</strong>（WLAN），它可以满足一定地理范围内的用户无线接入需求；<strong>远距离使用则采用 IEEE802.16 标准的 WiMAX</strong>，该技术可以在 50km 范围内提供最高 70Mbit/s 的传输速率</p>
<p>IEEE802.11 标准于 IEEE802.16标准均针对无线环境，但由于适用对象不同，采用的技术于协议解决问题的重点也不相同IEEE802.11 标准的重点在解决局域网范围的移动节点通信问题，而 IEEE802.16 标准的重点是解决建筑物之间的数据通信问题**</p>
</li>
<li><p>IEEE802.11 标准与无线局域网</p>
<ul>
<li>IEEE802.11 定义了使用<strong>红外</strong>、<strong>调频扩频</strong>与<strong>直接序列扩频</strong>技术，数据传输速率为 1Mbit/s 或 2Mbit/s</li>
<li><strong>IEEE802.11a 将传输速率提高到 53Mbit/s</strong></li>
<li>IEEE802.11b 定义了使用直序扩频技术，传输速率为 1Mbit/s、2Mbit/s、5.5Mbit/s 与 11Mbit/s</li>
</ul>
</li>
<li><p>IEEE802.16 标准与无线城域网</p>
<ul>
<li>按 IEEE802.16 标准建立采用 <strong>全双工、宽带通信方式</strong> 工作的基站</li>
<li>IEEE802.16 标准规定了无线网络使用更高的、毫米波 <strong>10 ~ 66GHz</strong> 波段的频率</li>
<li>在 IEEE802.16 标准上增加了两个物理层标准 IEEE802.16d 与 IEEE802.16e;</li>
<li><strong>与 IEEE802.16 标准工作组对应的论坛组织是 WiMAX，最高的速率为 134Mib/s</strong></li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>协议标准</th>
<th>使用频段</th>
<th>信道条件</th>
<th>固定/移动</th>
<th>行到带宽（MHz）</th>
<th>传输速度（Mbit/s）</th>
<th>额定小区半径（Km）</th>
</tr>
</thead>
<tbody><tr>
<td>IEEE802.16</td>
<td>10~66GHz</td>
<td>视距</td>
<td>固定</td>
<td>25/28</td>
<td>32~134</td>
<td>&lt;5</td>
</tr>
<tr>
<td>IEEE802.16a</td>
<td>&lt;11GHz</td>
<td>非视距</td>
<td>固定</td>
<td>1.25/20</td>
<td>75</td>
<td>5~10</td>
</tr>
<tr>
<td>IEEE802.16d-2004</td>
<td>10~66GHz &lt; 11GHz&gt;</td>
<td>视距 + 非视距</td>
<td>固定</td>
<td>1.25/20</td>
<td>75</td>
<td>5~10</td>
</tr>
<tr>
<td>IEEE802.16e-2005</td>
<td>&lt;6GHz</td>
<td>非视距</td>
<td>固定 移动 + 漫游</td>
<td>1.25/20</td>
<td>75</td>
<td>若干</td>
</tr>
</tbody></table>
<p><img src="/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/%E7%AC%AC%E4%B8%80%E7%AB%A0/image-20210322085836224-16354230269262.png" alt="image-20210322085836224"></p>
]]></content>
      <categories>
        <category>NCRE</category>
      </categories>
      <tags>
        <tag>网络技术</tag>
      </tags>
  </entry>
  <entry>
    <title>路由器及其配置</title>
    <url>/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/%E7%AC%AC%E4%B8%83%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="路由器基础与基本命令"><a href="#路由器基础与基本命令" class="headerlink" title="路由器基础与基本命令"></a>路由器基础与基本命令</h2><ul>
<li>路由器是工作在<strong>网络层</strong>的设备。路由器负责将数据分组从源端主机经<strong>最佳路径</strong>传送到目的端主机</li>
<li>路由器主要用于同类或异类局域网以及局域网与广域网之间的互联</li>
<li>是连接不同逻辑子网的网络互连设备</li>
<li>路由器具有异构网络互连、广域网互连、和<strong>隔离广播信息</strong>的能力。</li>
</ul>
<span id="more"></span>

<h3 id="路由器的基本功能"><a href="#路由器的基本功能" class="headerlink" title="路由器的基本功能"></a>路由器的基本功能</h3><ol>
<li>路由选择<ul>
<li>路由选择就是路由器依据目的IP地址的网络地址部分，通过路由选择算法确定一条从源结点到达目的结点的最佳路由</li>
<li>路由器通过路由协议、网络连接的情况及网络的性能来建立网络的拓结构</li>
<li>路由算法为网络上的路由产生一个权值，路由器通过权值来选择最佳路由，权值越小，路由越佳</li>
</ul>
</li>
<li><strong>分组转发</strong><ul>
<li>对于一台路由器，其分组转发的任务即是在收到数据包后，根据<strong>路由表</strong>所提供的最佳路径的信息，将其转发给下一跳的路由器、目的端口或是缺省路由器</li>
<li>缺省路由也称为缺省网关，它是与主机在同一个子网中的路由器端口的IP地址。</li>
<li>路由器也有它的缺省网关。如果目标网络没有直接显示在路由表里的时候，那么就将数据分组传送给缺省网关。它一般指向与该路由器的一个端口的直接相连接的，并且通往Internet的出口路由器。</li>
<li><strong>分组转发的思想</strong><ul>
<li><strong>目的IP地址，全程不变。</strong></li>
<li><strong>目的MAC地址，逐跳修改。</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h3><p>路由器通过对路由表的查询来选择最佳路径的策略，路由表中保存着各种传输路径的相关数据，供路由选择时使用</p>
<p>路由表的内容主要包括</p>
<ul>
<li>目的网络地址及其所对应的目的端口</li>
<li>下一跳路由器的名字</li>
<li>缺省路由的信息。</li>
</ul>
<p>路由表可以是由系统管理员固定设置好的，也可以由系统动态修改，可以由路由器自动调整，也可以由主机控制</p>
<h4 id="路由表实例一-（cisco12000上的路由表）"><a href="#路由表实例一-（cisco12000上的路由表）" class="headerlink" title="路由表实例一 （cisco12000上的路由表）"></a>路由表实例一 （cisco12000上的路由表）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C   212.112.7.0/24 is directly connected, FastEthernet2/5</span><br><span class="line">​   212.112.37.0/30 is subnetted, 1 subnets</span><br><span class="line">C   212.112.37.16/24 is directly connected, POS3/0</span><br><span class="line">S   167.105.125.128 [1/0] via 202.112.7.1</span><br><span class="line">S*  0.0.0.0/0 [1/0] via 202.112.41.217</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/%E7%AC%AC%E4%B8%83%E7%AB%A0/image-20210321100110936.png" alt="image-20210321100110936"></p>
<p>路由表项</p>
<ul>
<li>路由源码<ul>
<li>“C”: 直连</li>
<li>“S”: 静态</li>
<li>“I” : IGRP</li>
<li>“O”: OSPF</li>
<li>“R”: RIP</li>
<li>“i”: IS-IS</li>
<li>“B”: BGP</li>
<li>“E”: EGP</li>
</ul>
</li>
<li>第2列是目的网络地址和掩码</li>
<li>第3列是目的端口或下一跳路由器地址，如果有下一跳路由器，则为下一跳路由器的IP地址</li>
<li>缺省路由的路由表项<ul>
<li>网络地址和掩码全是0</li>
</ul>
</li>
</ul>
<h4 id="路由表实例二-（三层交换机上的路由表）"><a href="#路由表实例二-（三层交换机上的路由表）" class="headerlink" title="路由表实例二 （三层交换机上的路由表）"></a>路由表实例二 （三层交换机上的路由表）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">O    222.29.2.0/24 [110/3] via 162.105.1.145,00:13:43,vlan1</span><br><span class="line">O    222.29.32.0/24 [110/3] via 162.105.1.145,00:13:43,vlan1</span><br><span class="line">     202.37.140.0/24 is variably subnetted, 3 subnets,2 masks</span><br><span class="line">O E2 202.37.140.40/289 [110/20] via 162.105.1.145,00:13:43,Vlan1</span><br><span class="line">O E1 202.37.140.0/28 [110/22] via 162.105.1.145,00:13:43,Vlan1</span><br></pre></td></tr></table></figure>

<p>第2列表示路由类型</p>
<ul>
<li>E1：OSPF外部路由类型1</li>
<li>E2：OSPF外部路由类型2</li>
</ul>
<p>第4列，如 [110/22]：<strong>110是管理距离，22是权值（metric）或成本</strong></p>
<p><strong>管理距离</strong>用于衡量路由表中给定的路由信息源的“<strong>可信度</strong>”</p>
<table>
<thead>
<tr>
<th>路由协议</th>
<th>管理距离</th>
<th>路由协议</th>
<th>管理距离</th>
</tr>
</thead>
<tbody><tr>
<td>直接连接</td>
<td>0</td>
<td>静态路由</td>
<td>1</td>
</tr>
<tr>
<td>外部BGP</td>
<td>20</td>
<td>内部EIGRP</td>
<td>90</td>
</tr>
<tr>
<td>IGRP</td>
<td>100</td>
<td>OSPF</td>
<td>110</td>
</tr>
<tr>
<td>IS-IS</td>
<td>115</td>
<td>RIP</td>
<td>120</td>
</tr>
<tr>
<td>外部EIGRP</td>
<td>170</td>
<td>内部BGP</td>
<td>200</td>
</tr>
<tr>
<td>未知</td>
<td>255</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>权值是路由器通过路径选择算法为网络上的路径产生的一个数字。路由器根据这个值确定最佳路径</p>
<p>路由器常用的权值： （了解）</p>
<ul>
<li>带宽：链路的数据能力</li>
<li>延迟：数据包从源送到目的所需的时间</li>
<li>负载：链路上的活动数量</li>
<li>可靠性：链路的差错率</li>
<li>跳数：通过路由器的数量</li>
<li>滴答数：用IBM PC的时钟滴答计数延迟</li>
<li>花费：cost，一般由管理员指定。</li>
</ul>
<h3 id="路由器的结构"><a href="#路由器的结构" class="headerlink" title="路由器的结构"></a>路由器的结构</h3><p><img src="/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/%E7%AC%AC%E4%B8%83%E7%AB%A0/image-20210321115048654.png" alt="image-20210321115048654"></p>
<ul>
<li>中央处理器<ul>
<li>CPU是路由器的处理中心，CPU负责实现路由协议、路径选择计算、交换路由信息、查找路由表、分发路由表和维护各种表格，以及转发数据包等功能</li>
<li>CPU的处理能力直接影响路由表查找事件、吞吐量和路由器的性能</li>
</ul>
</li>
<li>内存<ul>
<li>只读内存（Read Only Memory，ROM） <ul>
<li>ROM中包括开机开机诊断程序、引导程序和操作系统软件</li>
<li>不能修改其中保存的内容</li>
</ul>
</li>
<li>随机存储器（RAM）<ul>
<li>RAM是可读可写存储器。用来存储用户的数据包队列以及路由器在运行过程中产生的<strong>中间数据</strong>，如路由表、ARP缓冲区等</li>
<li>RAM还用来存储路由器的运行配置文件</li>
<li>当<strong>路由器被关闭或重新启动时，RAM中的内容都将丢失</strong></li>
</ul>
</li>
<li>非易失性随机存储器（NVRAM）<ul>
<li>NVRAM是可读可写存储器。是用来<strong>存储路由器的启动配置文件</strong></li>
<li>在路由器断电时，其内容仍能保持</li>
</ul>
</li>
<li>闪存（FLASH）<ul>
<li>是可擦写的ROM。它主要负责<strong>保存操作系统的映像文件和一些微代码</strong></li>
<li>在路由器断电时，其内容仍能保持。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="路由器的工作模式"><a href="#路由器的工作模式" class="headerlink" title="路由器的工作模式"></a>路由器的工作模式</h3><ol>
<li><p>用户模式（User EXEC）</p>
<ul>
<li>当通过控制台或Telnet成功登录到路由器后，将会看到</li>
<li>它是一种只读模式，用户可以浏览关于路由器的某些信息，但不能进行任何修改</li>
<li>该模式默认的提示符为：<code>router&gt;</code></li>
</ul>
</li>
<li><p>特权模式（Priviledged EXEC）</p>
<ul>
<li>在用户EXEC模式提示符后键入enable命令并按提示输入使能口令后将进入特权模式</li>
<li>可以管理系统时钟、进行错误检测、查看和保存配置文件、清楚闪存、处理并完成路由器的冷启动等操作</li>
<li>该模式不能对端口及网络协议进行配置</li>
<li>该模式默认的提示符为：<code>router#</code></li>
</ul>
</li>
<li><p>全局配置模式（Global Configuration）</p>
<ul>
<li>在特权EXEC模式下，通过键入<code>configure terminal</code>命令可以进入</li>
<li>全局配置模式用于配置路由器的全局性的参数（主机名、口令、TFTP服务器、静态路由、访问控制列表等），更改已有配置等</li>
<li>全局配置模式的默认提示符为:<code>router(config)#</code></li>
</ul>
</li>
<li><p>其他配置模式：包括接口配置模式、虚拟终端配置模式、路由配置模式等</p>
<ul>
<li><p>接口配置模式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">router (config)#interface f0/12</span><br><span class="line">router（config-if）#</span><br></pre></td></tr></table></figure></li>
<li><p>虚拟终端配置模式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">router (config)#line vty 0 15</span><br><span class="line">router（config-line）#</span><br></pre></td></tr></table></figure></li>
<li><p>路由配置模式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">router (config)#router rip</span><br><span class="line">router（config-router）#</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>设置模式（Setup）</p>
<ul>
<li>当通过console端口进入一台刚出场的没有任何配置的路由器启动时会进入设置模式</li>
<li>系统以对话框提示用户设置路由器，协助用户建立第一次的配置文件</li>
</ul>
</li>
<li><p>RXBOOT模式</p>
<ul>
<li>RXBOOT模式是路由器的维护模式</li>
<li>在密码丢失时，可以进入RXBOOT模式，以<strong>恢复密码</strong></li>
</ul>
</li>
</ol>
<h3 id="路由器的基本操作与配置方法"><a href="#路由器的基本操作与配置方法" class="headerlink" title="路由器的基本操作与配置方法"></a>路由器的基本操作与配置方法</h3><ul>
<li><p>路由器的配置方式</p>
<ul>
<li><strong>AUX</strong>，通过<strong>远程拨号配置</strong>路由器</li>
</ul>
</li>
<li><p>使用控制端口(Console)配置路由器</p>
</li>
<li><p>使用telnet配置路由器</p>
<ul>
<li><p>必备条件</p>
<ol>
<li>作为模拟终端的计算机与路由器都必须与网络连通，它们之间能够相互通信</li>
<li>计算机必须有访问路由器的权限</li>
<li>路由器必须预先配置好远程登录的密码</li>
</ol>
</li>
<li><p>路由器的配置（08下）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">router (config)#line vty 0 15</span><br><span class="line">router（config-line）#password 7 zzz307</span><br></pre></td></tr></table></figure></li>
<li><p>远程登录的具体步骤</p>
<ul>
<li>进入“运行串口”，输入 <code>telnet 202.112.7.4</code></li>
</ul>
</li>
</ul>
</li>
<li><p>使用TFTP配置路由器（了解）</p>
<ol>
<li><p>在网络上必须配备一台计算机作为TFTP server,且必须安装并运行TFTP server软件。</p>
</li>
<li><p>路由器的操作步骤</p>
<ul>
<li><p>拷贝配置文件到TFTP server</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">Router#</span><span class="bash">write network</span></span><br><span class="line">Remote host [ ]? 202.105.130.120  </span><br><span class="line">Name of configuration file to write [router-config]?   </span><br><span class="line">Write file router-config on host 202.105.130.120 ? [confirm] </span><br><span class="line">\################</span><br><span class="line">Writing router-config ……</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="路由器基本配置"><a href="#路由器基本配置" class="headerlink" title="路由器基本配置"></a>路由器基本配置</h2><ul>
<li><p>配置主机名</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Router（config）<span class="comment">#hostname router-phy</span></span><br></pre></td></tr></table></figure></li>
<li><p>配置超级用户口令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Router（config）#enable secret phy123</span><br><span class="line">Router（config）#enable password 7 phy123</span><br></pre></td></tr></table></figure></li>
<li><p>配置系统时钟</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">Router#</span><span class="bash"> calendar <span class="built_in">set</span> hh:mm:ss &lt;1 -31&gt; MONTH &lt;1993-2035&gt;</span></span><br><span class="line">如：Router# calendar set 10:24:00 22 march 2007</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="路由器公用命令"><a href="#路由器公用命令" class="headerlink" title="路由器公用命令"></a>路由器公用命令</h2><ul>
<li><p>退出命令（exit）</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Router（config-if）#exit</span><br><span class="line">Router（config）#exit</span><br><span class="line"><span class="meta">Router#</span><span class="bash"></span></span><br><span class="line"><span class="bash">Router（config-if）<span class="comment">#end</span></span></span><br><span class="line"><span class="meta">Router#</span></span><br></pre></td></tr></table></figure></li>
<li><p>保存配置</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">Router#</span><span class="bash"> write memory            //保存到路由器的NVRAM中</span></span><br><span class="line"><span class="meta">Router#</span><span class="bash"> write network tftp      //保存到TFTP服务器中</span></span><br></pre></td></tr></table></figure></li>
<li><p>删除配置</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Router<span class="comment"># write erase</span></span><br></pre></td></tr></table></figure></li>
<li><p>网络的基本检测命令</p>
<ul>
<li><p>telnet</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Router&gt; telnet paris (或IP地址)</span><br></pre></td></tr></table></figure></li>
<li><p>ping</p>
</li>
<li><p>trace</p>
</li>
<li><p>show命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">Router&gt;</span><span class="bash">show flash</span></span><br><span class="line"><span class="meta">Router&gt;</span><span class="bash">show clock</span></span><br><span class="line"><span class="meta">Router&gt;</span><span class="bash">show version</span></span><br><span class="line"><span class="meta">Router&gt;</span><span class="bash">show configuration</span></span><br><span class="line"><span class="meta">Router#</span><span class="bash"> show ip route          //注意模式与命令的拼写</span></span><br><span class="line"><span class="meta">Router#</span><span class="bash"> show ip protocols</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="接口配置、-Pos接口配置"><a href="#接口配置、-Pos接口配置" class="headerlink" title="接口配置、 Pos接口配置"></a>接口配置、 Pos接口配置</h2><ul>
<li><p>路由器接口的基本配置 </p>
<ol>
<li><p>配置接口描述信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Router（config）#int g6/0</span><br><span class="line">Router（config-if）#description to-beijing </span><br></pre></td></tr></table></figure></li>
<li><p>配置接口带宽</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Router（config）#int POS3/0</span><br><span class="line">Router（config-if）#bandwidth 2500000 (设置接口带宽为2.5Gbps)</span><br></pre></td></tr></table></figure></li>
<li><p>配置接口的IP地址</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Router（config-if）<span class="comment">#ip add 202.112.7.249 255.255.255.252</span></span><br></pre></td></tr></table></figure></li>
<li><p>接口的开启与关闭</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Router（config-if）<span class="comment">#shutdown</span></span><br><span class="line">Router（config-if）<span class="comment">#no shutdown</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>局域网接口配置</p>
<ol>
<li><p>配置标准以太网接口（Ethernet）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Router（config）# interface Ethernet0 </span><br><span class="line">Router（config-if）# description TO Beijing </span><br><span class="line">Router（config-if）# ip address 202.112.7.4 255.255.255.0 </span><br><span class="line">Router（config-if）# bandwidth 10000 </span><br><span class="line">Router（config-if）# no shutdown </span><br><span class="line">Router（config-if）# exit</span><br></pre></td></tr></table></figure></li>
<li><p>配置快速以太网接口（Fast Ethernet)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Router（config）# interface f2/1 </span><br><span class="line">Router（config-if）# description TO BEIJING </span><br><span class="line">Router（config-if）# ip address 202.111.41.145.255.255.255.240 </span><br><span class="line">Router（config-if）# bandwidth 100000</span><br><span class="line">Router（config-if）# duplex full </span><br><span class="line">Router（config-if）# no ip directed-broadcast </span><br><span class="line">Router（config-if）# no ip proxy-arp </span><br><span class="line">Router（config-if）# no shutdown </span><br><span class="line">Router（config-if）# exit </span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>广域网接口配置</p>
<ol>
<li><p>配置异步串行口(用于连接modem，为用户提供<strong>拨号上网服务</strong>)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Router（config）<span class="comment"># interface a1（异步口，以a开头）</span></span><br><span class="line">Router（config-if）<span class="comment"># ip unnumbered ethernet0 </span></span><br><span class="line">Router（config-if）<span class="comment"># Encapsulation ppp （不能封装为HDLC）</span></span><br><span class="line">Router（config-if）<span class="comment"># Async default ip address 202.112.7.129 </span></span><br><span class="line">Router（config-if）<span class="comment"># Async dynamic routing </span></span><br><span class="line">Router（config-if）<span class="comment"># Async mode interactive </span></span><br><span class="line">Router（config-if）<span class="comment"># no shutdown </span></span><br><span class="line">Router（config-if）<span class="comment"># Exit </span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>配置同步串行口</strong></p>
<p>高速同步串行接口类型是Serial，可简写为s。它主要用于<strong>DDN专线、帧中继、卫星、微波等广域网连接</strong></p>
<p>需要配置的参数主要有接口带宽、接口协议和接口的IP地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Router（config）# Interface s1/1 （同步口，以s开头）</span><br><span class="line">Router（config-if）# Description TOBEIJING </span><br><span class="line">Router（config-if）# Bandwidth 2048 （带宽为2M）</span><br><span class="line">Router（config-if）# Ip address 212.112.41.81 255.255.255.252 </span><br><span class="line">Router（config-if）# Encapsulation hdlc （封装HDLC或PPP协议，HDLC为缺省）</span><br><span class="line">Router（config-if）# No ip directed-broadcast </span><br><span class="line">Router（config-if）# No ip proxy-arp </span><br><span class="line">Router（config-if）# No shutdown </span><br><span class="line">Router（config-if）# Exit </span><br></pre></td></tr></table></figure></li>
<li><p><strong>配置POS接口</strong>（综合题）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Router（config）# Interface POS3/0 </span><br><span class="line">Router（config-if）# Description TO BEIJING </span><br><span class="line">Router（config-if）# Bandwidth 2500000 （单位是Kbps）</span><br><span class="line">Router（config-if）# Ip address 212.14.37.18 255.255.255.252 </span><br><span class="line">Router（config-if）# Crc 32 （可选的CRC校验位是16和32）</span><br><span class="line">Router（config-if）# Pos framing sdh （可选帧格式是SDH和SONET）</span><br><span class="line">Router（config-if）# No ip directed-broadcast </span><br><span class="line">Router（config-if）# Pos flag sls0 2</span><br></pre></td></tr></table></figure>

<p> <strong>（sls0=00表示是SONET帧数据，sls0＝10（十进制2）表示是SDH帧）</strong></p>
</li>
<li><p>loopback接口配置</p>
<p>loopback接口没有一个实际的物理接口与之相对应，也没有与其他网络节点相连接的物理链路</p>
<p>它是一个<strong>虚拟的接口</strong>，loopback接口号的有效值为<strong>0~2147483647</strong></p>
<p>主要作用是他作为一台路由器的管理地址，使网络管理员可以随时登录到路由器上，对路由器进行配置管理</p>
<p>它还可以作为动态路由协议ospf和bgp的router id ，使路由器功能更加稳定可靠</p>
<p>每台路由器上都配置一个环回接口，它<strong>永远处于激活状态</strong></p>
<p>网络管理员为loopback接口分配一个IP地址作为管理地址，其<strong>掩码应为255.255.255.255</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Router（config）<span class="comment"># Int loopback 0 </span></span><br><span class="line">Router（config-if）<span class="comment"># Ip address 192.168.1.1 255.255.255.255 （掩码一定为255.255.255.255）</span></span><br><span class="line">Router（config-if）<span class="comment"># No ip route-cache </span></span><br><span class="line">Router（config-if）<span class="comment"># No ip mroute-cache </span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="访问控制列表"><a href="#访问控制列表" class="headerlink" title="访问控制列表"></a>访问控制列表</h2><ul>
<li>IP访问控制列表的主要功能<ul>
<li>通过灵活地增加访问控制列表，ACL可以当作一种网络控制的有力工具，用来过滤流入和流出路由器接口的数据包</li>
</ul>
</li>
<li>IP访问控制列表的过滤准则<ul>
<li>过滤源地址或目的地址</li>
<li>过滤端口号</li>
<li>过滤协议（ICMP、TCP、UDP）</li>
</ul>
</li>
<li>访问控制列表的分类<ul>
<li>标准访问控制列表：只能检查数据包的<strong>源地址</strong>。表号的范围是：<strong>1-99</strong>，<strong>扩展后是1300-1999</strong></li>
<li>扩展访问控制列表：检查数据包的<strong>源地址与目的地址</strong>。根据源网络，目的网络，子网掩码，主机的ip地址决定数据包的过滤</li>
<li>该列表还可以检查指定的<strong>协议</strong>以及<strong>端口号</strong>，表号范围是<strong>100-199</strong>，<strong>扩展后是2000-2699</strong></li>
</ul>
</li>
</ul>
<h4 id="配置IP访问控制列表"><a href="#配置IP访问控制列表" class="headerlink" title="配置IP访问控制列表"></a>配置IP访问控制列表</h4><ol>
<li>首先在全局配置模式下定义访问列表，然后将其应用到接口中，使通过该接口的数据包需要进行相应的匹配，然后决定被通过还是拒绝</li>
<li>并且访问列表语句按顺序自上向下开始匹配数据包</li>
<li>如果一个数据包头与访问权限表的某一语句不匹配，则继续检测列表中的下一个语句</li>
<li>在执行到访问列表的最后，还没有与其相匹配的语句，数据包将被隐含的“拒绝”语句所拒绝</li>
</ol>
<p>ACL语句的顺序非常重要。若要允许除202.204.4.2意外的所有源地址通过路由器，需要先配置“deny 202.202.4.2”再配置“permit any”</p>
<ul>
<li><p>配置访问控制列表的两个重要参数</p>
<ul>
<li>表号和名字<ul>
<li>表号是用来标识或是引用某个访问控制列表</li>
<li>访问控制列名的名字用字符串来表示</li>
</ul>
</li>
<li>通配符掩码<ul>
<li>访问控制列表的通配符掩码是一个32bit的数字字符串，它点分成4个8位，每组包含8bit</li>
<li>在通配符掩码位中，表示形式与IP地址的子网掩码相同</li>
<li>它实际上即是<strong>子网掩码的反码</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>配置IP访问控制列表</strong></p>
<ul>
<li><p><strong>配置标准访问控制列表</strong></p>
<p>在全局模式下，命令格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">access-list access-list-number &#123;permit | deny&#125; source wildcard-mask</span><br></pre></td></tr></table></figure></li>
<li><p>配置扩展访问控制列表</p>
<ol>
<li><p>使用access-list命令</p>
<p>在全局配置模式下，命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">access-list access-list-number &#123;permit | deny&#125; protocol source wildcard-mask destination wildcard-mask [operator] [operand]</span><br></pre></td></tr></table></figure>

<p>其中：operator(操作)，操作有“lt”（小于）、“gt”（大于）、“eq”（等于）、“neq”(不等于)、operatand（操作数），指的是端口号</p>
</li>
<li><p>使用ip access-list命令</p>
<p>在全局配置模式下，命令格式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ip access-list extended | standard access-list-number | name</span><br></pre></td></tr></table></figure>

<p>在扩展或标准访问控制列表模式下(如：Router(config-ext-nacl)#)，配置过滤规则，命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">permit | deny protocol source wildcard-mask destination wildcard-mask [operator] [operand]</span><br></pre></td></tr></table></figure></li>
<li><p>用名字标识访问控制列表的配置方法</p>
<p>在全局配置模式下，命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip access-list extended | standard access-list-number | name</span><br></pre></td></tr></table></figure>

<p>在扩展或标准访问控制列表模式下（如：Router(config-ext-nacl)#）,配置过滤准则，命令格式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">permit|deny protocol <span class="built_in">source</span> wildcard-mask destination wildcard-mask [operator] [operand]</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="静态路由配置"><a href="#静态路由配置" class="headerlink" title="静态路由配置"></a>静态路由配置</h2><ul>
<li><p>静态路由的配置方法</p>
<p>Router（config）# <strong>ip route</strong> &lt;**目的网络地址**&gt;&lt;**子网掩码**&gt;&lt;**下一跳路由器的IP地址**&gt; </p>
<p>如：<code>Router（config）# ip route 59.65.96.0 255.255.240.0 222.112.37.1</code></p>
</li>
<li><p>静态默认路由的配置方法</p>
<p>默认路由指路由器对接收的数据包找不到匹配路由表项时，如果路由表中有默认路由，路由器按默认路由的下一跳地址转发数据包</p>
<p>Router（config）# ip route <strong>0.0.0.0 0.0.0.0</strong> &lt;下一跳路由器的IP地址&gt;</p>
</li>
</ul>
<h2 id="动态路由配置"><a href="#动态路由配置" class="headerlink" title="动态路由配置"></a>动态路由配置</h2><h3 id="RIP动态路由协议的配置"><a href="#RIP动态路由协议的配置" class="headerlink" title="RIP动态路由协议的配置"></a>RIP动态路由协议的配置</h3><p>RIP路由协议只依据路由器<strong>跳数</strong>（hop数）决定最佳路径，不考虑带宽、延时和其他因素</p>
<p>具有<strong>最小跳数值的路径为”最优”路径</strong>。RIP限制最大跳数为<strong>15</strong>，如果为16，意味着路径不可达</p>
<p>另外，RIP在路由更新报文中部携带子网掩码信息，不支持VLSM。RIP定时更新路由周期为30秒。</p>
<p>RIP有两个版本：v1和v2。版本2提供了VLSM，多点广播路由更新和路由更新认证等新功能</p>
<ul>
<li><p><strong>RIP的基本配置</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">Router(config)#</span><span class="bash">router rip</span></span><br><span class="line"><span class="meta">Router(config-router)#</span><span class="bash">network 159.105.0.0</span></span><br><span class="line"><span class="meta">Router(config-router)#</span><span class="bash">network 212.112.7.0（网络地址写类地址，主机号都为0）</span></span><br></pre></td></tr></table></figure></li>
<li><p>RIP的高级配置</p>
<ul>
<li><p>配置被动接口</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Router(config)<span class="comment">#router rip </span></span><br><span class="line">Router(config-router)<span class="comment">#passive-interface ethernet 0</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>配置路由过滤</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Router(config)<span class="comment">#access-list 12 deny any</span></span><br><span class="line">Router(config)<span class="comment">#router rip</span></span><br><span class="line">Router(config-router)<span class="comment">#distribute-list 12 in ethernet0</span></span><br></pre></td></tr></table></figure></li>
<li><p>配置管理距离</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">Router(config)#</span><span class="bash">router rip</span> </span><br><span class="line"><span class="meta">Router(config-router)#</span><span class="bash">distance 50</span></span><br></pre></td></tr></table></figure></li>
<li><p>定义邻居路由器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">Router(config)#</span><span class="bash">router rip</span> </span><br><span class="line"><span class="meta">Router(config-router)#</span><span class="bash">neighbor 202.112.7.2</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="OSPF动态路由协议的配置"><a href="#OSPF动态路由协议的配置" class="headerlink" title="OSPF动态路由协议的配置"></a>OSPF动态路由协议的配置</h3><ul>
<li><p>OSPF的基本配置</p>
<ul>
<li><p>使用network命令定义参与OSPF的子网地址</p>
<p>配置单个IP地址参与OSPF </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Router (config) # router ospf 63 （进程号）</span><br><span class="line">Router (config-router) # network 131.107.25.1 0.0.0.0（反掩码） area 0 </span><br></pre></td></tr></table></figure>

<p>网络地址参与OSPF </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Router (config-router) # network 133.181.0.0 0.0.255.255 area 0</span><br></pre></td></tr></table></figure></li>
<li><p>定义参与OSPF的子网地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Router (config-router) # area 0 range 212.37.123.0 255.255.255.0 （正掩码）</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>常用OSPF参数的配置（了解）</p>
<ul>
<li><p>配置被动接口(包括路由器和第三层交换机的配置) </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Router (config-router) # passive-interface Ethernet 0 </span><br><span class="line">Router (config-router) # passive-interface vlan37 </span><br></pre></td></tr></table></figure></li>
<li><p>配置路由过滤</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Router (config) # access-list 12 deny any </span><br><span class="line">Router (config) # router ospf 63 </span><br><span class="line">Router (config-router) # distribute-list 12 in serial 0 </span><br></pre></td></tr></table></figure></li>
<li><p>配置管理距离</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Router (config-router) # distance 10 </span><br></pre></td></tr></table></figure></li>
<li><p>配置引入外部路由到OSPF的参数</p>
<p>配置OSPF引入外部路由的花费值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Router (config-router) # redistribute metric 100 </span><br></pre></td></tr></table></figure>

<p>配置引入外部路由时缺省的标记值</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Router (config-router) <span class="comment"># redistribute tag 10 </span></span><br></pre></td></tr></table></figure>

<p>配置引入外部路由时缺省的外部路由类型</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Router (config-router) # redistribute connected metric-type 1 subnets </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="路由器的DHCP配置"><a href="#路由器的DHCP配置" class="headerlink" title="路由器的DHCP配置"></a>路由器的DHCP配置</h2><p>IP地址分配有<strong>静态分配</strong>和<strong>动态分配</strong>两种分配方式</p>
<p>动态分配是使用动<strong>态主机配置协议（DHCP）</strong>，由网络站点提出DHCP请求，从DHCP服务器上自动获取一个IP地址与缺省网关、域名及域名服务器的IP地址等相关的TCP/IP属性的信息</p>
<ol>
<li><p>配置IP地址池的名称，并进入DHCP Pool配置模式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Router (config) # ip dhcp pool ttt </span><br></pre></td></tr></table></figure></li>
<li><p>配置IP地址池的子网地址和子网掩码</p>
<ul>
<li><p>在DHCP Pool配置模式下，命令格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">- network &lt;network-number&gt; [mask | /prefix-length]</span><br><span class="line"><span class="meta">Router(dhcp-config)#</span><span class="bash">network 201.23.98.0 255.255.255.0</span></span><br><span class="line"><span class="meta">Router(dhcp-config)#</span><span class="bash">network 201.23.98.0/24</span></span><br></pre></td></tr></table></figure></li>
<li><p>配置不用于动态分配的IP地址（除外地址），命令格式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ip dhcp excluded-address low-address [high-address]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>排除从201.23.98.2到201.23.98.10的一段IP地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">Router(config)#</span><span class="bash">ip dhcp excluded-address 201.23.98.2 201.23.98.10</span></span><br></pre></td></tr></table></figure></li>
<li><p>排除单个IP地址201.23.98.193</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">Router(config)#</span><span class="bash">ip dhcp excluded-address 201.23.98.193</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>配置IP地址池的缺省网关，命令格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">- default-router address [address2 ... address8]</span><br><span class="line"><span class="meta">Router(dhcp-config)#</span><span class="bash">default-router 201.23.98.1</span></span><br></pre></td></tr></table></figure></li>
<li><p>配置IP地址池的域名系统</p>
<ul>
<li><p>配置IP地址池的域名</p>
<p>在DHCP Pool配置模式下：</p>
<p>命令格式：domain-name <name></name></p>
<p>Router(dhcp-config)#domain-name pku.edu.cn</p>
</li>
<li><p>配置IP地址池的域名服务器的IP地址</p>
<p>在DHCP Pool配置模式下：</p>
<p>命令格式：dns-server address [address2 … address8]</p>
<p>Router(dhcp-config)#dns-server address 212.105.129.27 212.105.129.26</p>
</li>
</ul>
</li>
<li><p>配置IP地址池的地址租约时间</p>
<p>在DHCP Pool配置模式下： （注意单位）</p>
<p>命令格式：lease {days [hours][minutes]|infinite}</p>
<p>例：设置租约时间为5小时</p>
<p>Router(dhcp-config)#lease 0 5</p>
</li>
<li><p>取消地址冲突记录日志</p>
<p>在全局配置模式下：</p>
<p>Router(config)#no ip dhcp conflict logging</p>
</li>
</ol>
<p>一个完整的DHCP配置信息：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">no ip dhcp conflict logging</span><br><span class="line">ip dhcp exeluded-address 182.105.246.2 182.105.246.10</span><br><span class="line">ip dhcp exeluded-address 182.105.247.200 182.105.247.254 </span><br><span class="line">ip dhcp pool 246</span><br><span class="line">network 182.105.246.0 255.255.255.0</span><br><span class="line"> default-router 182.105.246.1</span><br><span class="line"> domain-name pku.edu.cn</span><br><span class="line"> dns-server 182.105.129.26 182.105.129.27 222.112.7.13</span><br><span class="line"> lease 0 5</span><br><span class="line">ip dhcp pool 247</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>NCRE</category>
      </categories>
      <tags>
        <tag>网络技术</tag>
      </tags>
  </entry>
  <entry>
    <title>交换机及其配置</title>
    <url>/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/%E7%AC%AC%E5%85%AD%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="交换机的基本概念"><a href="#交换机的基本概念" class="headerlink" title="交换机的基本概念"></a>交换机的基本概念</h2><p>基本概念</p>
<ul>
<li>局域网交换机是一种 <strong>基于 MAC 地址</strong> 识别，完成转发数据帧功能的一种网络连接设备</li>
<li>工作在数据链路层，<strong>根据端口数据帧中的 MAC 地址进行数据帧的过滤、转发（也是交换机的工作原理）</strong></li>
<li>交换机作为汇聚中心，能将多台数据终端设备连接在一起，构成<strong>星状的网络</strong></li>
<li>交换式局域网具有<strong>独占</strong>传输通道、<strong>独享</strong>信道带宽，<strong>同时允许多对站点</strong>进行通信、<strong>系统带宽等于所有端口带宽之和</strong>等特性</li>
</ul>
<span id="more"></span>



<p>基本功能</p>
<ul>
<li>建立和维护一个表示 <strong>MAC 地址与交换机端口对应关系的交换表</strong></li>
<li><strong>在发送节点和接受节点之间建立一条虚拟连接</strong> [即发送方所连的交换机端口（源端口）到接收方所连的交换机端口（目的端口）之间建立虚连接]</li>
<li><strong>完成数据帧的转发或过滤</strong></li>
</ul>
<h2 id="交换表的内容"><a href="#交换表的内容" class="headerlink" title="交换表的内容"></a>交换表的内容</h2><p>交换表主要包括<strong>目的 MAC 地址</strong>、与目的 MAC 地址<strong>对应的交换机端口号</strong>以及它<strong>所属的虚拟子网</strong>。其中，虚拟子网用 VLAN ID 标识。</p>
<p>小型交换机的交换表（cisco-3XXX及以下型号）</p>
<ul>
<li><p>交换机通过在超级用户模式下，<strong>使用 show mac-address-talbe 命令查看</strong></p>
</li>
<li><p>该交换表的第一列为目的MAC地址，第二列为地址类型，第三列为VLAN的ID号，第四号为该目的MAC地址所对应的交换机的端口号</p>
<p><img src="https://bluexiaowei.github.io/NCRE3/static/images/06-01.png" alt="小型交换机的交换报表"></p>
</li>
</ul>
<p>大型交换机的交换表（cisco-4000及以上型号）</p>
<ul>
<li><p>交换机通过在超级用户模式下，<strong>使用 show cam dynamic 命令查看</strong></p>
</li>
<li><p>第一列是VLAN的ID号，第二列是目的MAC地址，第三列是该地址相对应的交换机的端口号。</p>
<p><img src="https://bluexiaowei.github.io/NCRE3/static/images/06-02.png" alt="大型交换机的交换表"></p>
</li>
</ul>
<h2 id="交换机的交换结构"><a href="#交换机的交换结构" class="headerlink" title="交换机的交换结构"></a>交换机的交换结构</h2><ul>
<li><p>软件执行交换结构</p>
<ul>
<li>交换机接收到数据帧后，先将其由<strong>串行代码转化为并行代码</strong>，暂时存储在交换机的快速缓存RAM中</li>
<li>交换机的CPU开始根据数据帧中的目的MAC地址进行查询交换表</li>
<li>确定了目的端口后，交换机在源端口与目的端口之间建立起虚连接，然后将以并行代码形式存储在<strong>RAM</strong>中的数据帧<strong>转化为串行代码</strong>，发送到目的端口</li>
<li>上述的步骤都是<strong>由软件控制完成</strong>的。<img src="/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210320141519773.png" alt="image-20210320141519773"> </li>
</ul>
</li>
<li><p>矩阵交换结构</p>
<ul>
<li>在矩阵交换结构中，交换机确定了目的端口后，根据源端口与目的端口打开<strong>交换矩阵</strong>中相应的开关，在两个端口之间建立连接</li>
<li>通过建立的这个传输通道来完成数据帧的传输</li>
<li>优点：交换速率快、时延小、易于实现</li>
<li>缺点：扩展与可管理性较差<img src="/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210320141619667.png" alt="image-20210320141619667"></li>
</ul>
</li>
<li><p>总线交换结构</p>
<ul>
<li>总线交换结构的交换机拥有一条很高带宽的背部总线</li>
<li>交换机的所有的端口都挂接在这条背部总线上，总线按时隙分为多条逻辑通道，各个端口都可以往该总线上发送数据帧，这些<strong>数据帧都按时隙在总线上传输</strong>，并从各自的目的端口中输出数据帧</li>
<li>总线交换结构对总线的带宽有较高的要求，<strong>设交换机的端口数为M，每个端口的带宽为N，则总线的带宽应为M×N</strong>。<img src="/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210320141728741.png" alt="image-20210320141728741"></li>
</ul>
</li>
<li><p>共享存储器交换结构</p>
<ul>
<li>共享存储交换结构将<strong>共享存储RAM</strong>代替了总线交换结构中的总线，数据帧通过共享存储器实现从源端口直接传送到目的端口，它是总线交换结构的改进。</li>
<li>优点：<strong>结构简单、易于实现</strong></li>
<li>缺点：当交换机的端口数量不断增加，存储容量不断扩大的同时，数据交换的时延也会越来越大。而且共享存储交换结构的成本比较高。<strong>适合小型交换机</strong>采用。</li>
</ul>
</li>
</ul>
<p><img src="/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210320141810557.png" alt="image-20210320141810557"></p>
<h2 id="交换机的交换模式"><a href="#交换机的交换模式" class="headerlink" title="交换机的交换模式"></a>交换机的交换模式</h2><p>交换机的交换方式有 <strong>静态交换和动态交换</strong> 两种</p>
<ul>
<li>静态交换时由人工完成端口之间传输通道的建立</li>
<li><strong>动态交换方式中依据目的 MAC 地址查询交换表，根据表中给出的输出端口来临时建立传输通道，这个传输通道在一个数据帧传送完成后自动断开</strong>。</li>
</ul>
<p><strong>交换机最常采用的交换方式是动态交换方式</strong>。动态交换模式组要由存储转发和直通两种模式。而直通模式又有快速转发交换和碎片丢弃交换两种，归纳起来，交换机主要有<strong>快速转发</strong>、<strong>碎片丢弃</strong>和<strong>存储转发</strong>三种交换模式。</p>
<ul>
<li>快速转发交换模式<ul>
<li><strong>快速转发交换模式，也称作直通交换模式</strong>，它是在交换机接收了帧的前 14 个字节，即 <strong>接收到帧中 6 个 字节的目的地址后便理机转发数据帧</strong>。该交换模式会在整个数据帧到之前就开始转发</li>
<li>优点：端口交换时间短、延时小和交换速度快</li>
<li>缺点：不能进行检查纠错、速度匹配和流量控制，可靠性较差</li>
<li><strong>适合小型交换机</strong></li>
</ul>
</li>
<li>碎片丢弃交换模式<ul>
<li>碎片丢弃交换模式也被称为无分段交换模式</li>
<li><strong>这种交换模式实在开始转发数据帧前，先过滤掉造成大部分数据报错误的冲突片</strong></li>
<li><strong>采用这种交换模式的交换机在转发数据时，先检查数据包的长度是否够 64 字节</strong>。如果帧的长度小于 64， 则被视为碎片，交换机直接丢弃；而任何大于 64 字节的数据帧都被交换机视为有效帧，进行转发</li>
<li>优点：过滤掉了冲突碎片，提高了网络传输的效率和宽带的利用率</li>
</ul>
</li>
<li>存储转发交换模式<ul>
<li>存储转发交换模式 <strong>将接收到的整个数据帧保存在缓冲区</strong>中，然后进行<strong>循环冗余码校验检查，在对错误数据帧进行处理后，才取出数据帧的目的地址，进行转发操作</strong></li>
<li>缺点：进行数据处理的<strong>延时大</strong>、交换速度相对较慢</li>
<li>优点：对数据帧进行链路差错校验，可靠性较高，能有效的改善网络性能；同时它可以<strong>支持不同速率的端口</strong>，保持高速端口与低速端口之间协同工作。</li>
</ul>
</li>
</ul>
<h2 id="虚拟局域网技术"><a href="#虚拟局域网技术" class="headerlink" title="虚拟局域网技术"></a>虚拟局域网技术</h2><ul>
<li>虚拟网 VLAN 是以交换式网络为基础，把用户的终端设备划分为若干个逻辑工作组，每个逻辑工作组就是一个 VLAN</li>
<li>该逻辑组<strong>都是一个独立的逻辑网段和广播域</strong></li>
<li>这个逻辑组的设定不受实际交换机区段的限制，也<strong>不受用户所在的物理位置和物理网段的限制</strong></li>
<li>逻辑组的设定在交换机中是<strong>通过软件完成</strong>的</li>
</ul>
<p>VLAN 的特征</p>
<ul>
<li>VLAN 工作在数据链路层<strong>，即OSI 参考模型的第二层</strong></li>
<li>VLAN 可隔离广播信息，每个 VLAN 为一个广播域，<strong>VLAN 中的广播信息只能发送给这一个 VLAN 内部的成员，并不发送给其他 VLAN 成员</strong></li>
<li>一个 VLAN 就是一个独立的逻辑网络，每个 VLAN 都具有唯一的子网号。<strong>不同 VLAN 中的主机之间必须通过路由器或者三层交换机，才能实现相互通信</strong></li>
</ul>
<p>VLAN 的标识</p>
<ul>
<li>VLAN 通常用 <strong>VLAN ID （Vlan 号）和 VLAN name（Vlan 名）</strong> 标识</li>
<li>IEEE 802.1Q 协议规定，<strong>VLAN ID 用 12 位（bit）表示</strong>，可以支持 4096 个 VLAN。其中 <strong>1 ~ 1005 是标准范围，1006 ~ 1024 为保留范围，1025 ~ 4096 是扩展范围</strong>。但并不是所有交换机都能支持 4096 个 VLAN</li>
<li>一部分交换机只支持标准范围 1 ~ 1005，其中能 <strong>用与以太网的 VLAN ID 为 1 ~ 1000</strong>, 而 <strong>1002 ~ 1005 为 FDDI 和令牌环网使用的 VLAN ID</strong></li>
<li>VLAN name 用 <strong>32 个字符表示</strong>，可以是<strong>字母和数字</strong>。若创建一个 VLAN 时，没有给定名字，则系统按默认方式，自动给出命名，<strong>默认为 VLAN00xxx(xxx 即为该 VLAN 的 VLAN ID)</strong></li>
</ul>
<p>VLAN Trunk</p>
<ul>
<li><p>VLAN Trunk（虚拟网中继）技术即是实现在多个交换机之间或是在交换机与路由器之间进行多个VLAN信息传输的技术</p>
</li>
<li><p>Trunk是一种<strong>封装技术</strong>，它是一条点到点的链路，主要功能就是仅通过一条链路就可以连接多个交换机从而扩展已配置的多个VLAN</p>
</li>
<li><p>VLAN Trunk的标准机制是<strong>帧标签</strong></p>
<blockquote>
<p>帧标签卫每一个数据帧指定一个唯一的VLAN ID，这样即可表示该数据帧是属于哪一个VLAN的</p>
</blockquote>
</li>
</ul>
<p><img src="/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/%E7%AC%AC%E5%85%AD%E7%AB%A0/image-20210320142738401.png" alt="image-20210320142738401"></p>
<p>​    在主干线路上要传输多个VLAN（VLAN1、VLAN2、VLAN3）的信息，则连接主干线路的两台交换机端口应具有Trunk功能。</p>
<p>划分VLAN的方法</p>
<ul>
<li>基于端口划分VLAN<ul>
<li>由网络管理员根据交换机端口进行静态的VALN 分配，每个端口属于一个VLAN</li>
<li>当在交换机上将其某一个端口分配给一个VLAN 时，将一直保持不变直到网络管理员改变这种配置</li>
</ul>
</li>
<li>基于MAC地址</li>
<li>基于第三层协议类型或地址<ul>
<li>按照网络层协议类型（TCP/IP、IPX、DECNET等）或按网络地址定义VLAN成员。</li>
</ul>
</li>
</ul>
<h2 id="生成树协议STP"><a href="#生成树协议STP" class="headerlink" title="生成树协议STP"></a>生成树协议STP</h2><p>STP 的基本概念</p>
<ul>
<li>生成树协议（STP）时一个 <strong>二层链路管理协议</strong>。它主要功能时在保证网络中没有回路的基础上，<strong>允许在第二层链路中提供冗余路径</strong>，以保证网络可靠、稳定的运行</li>
<li><strong>IEEE 802.1D 是最早的 STP 的标准</strong>，它提供了动态冗余切换机制，是目前最为流行、应用最广泛的 STP 标准</li>
<li><strong>STP 运行在交换机和网桥设备上</strong>，通过计算机建立一个稳定的树状结构网络，来避免网络中回路的产生</li>
</ul>
<p>STP 的工作原理：<strong>通过在交换机之间传递网桥协议数据单元（BPDU），并运用生成树算法（STA）</strong>对其进行比较计算</p>
<ul>
<li>首先进行根网桥选择（根网桥为整个生成树拓扑结构的核心，所有数据传输均通过根网桥）</li>
<li>然后确定交换机冗余链路端口的工作状态，让一些端口进入<strong>阻塞工作模式</strong>，另一些端口进入转发工作模式</li>
<li>其中设置为阻塞模式的端口不能进行数据流的转发和接收，但仍作为一个激活的端口，可进行 BPDU 的接收和读取</li>
<li>如果<strong>网络拓扑发生变化</strong>或是生成树中的一个路径因故障而失效时，<strong>生成树就会重新计算</strong>，激活其他的备份链路，生成新的树拓扑，并强制将原来的故障链路变为备份链路，这时端口状态也会随之改变，以保证数据的传输路径是唯一的</li>
<li><strong>交换机与网桥在STP的工作过程中是有区别的</strong>。交换机要对VLAN进行处理，它指定一个根交换机，并为每一个VLAN选择一个根网络，然后再确定各个冗余端口的阻塞或转发状态，保证唯一的传输路径，并将其他的冗余链路作为备份链路，生成无回路的拓扑结构</li>
</ul>
<p>BPDU 中携带了实现生成树算法的有关信息，包括：<strong>Root Id、Root Path Cost、Bridge ID、Port ID、Hello time、Max Age</strong></p>
<ul>
<li>BPDU 数据包有两种类型，一种是包含 <strong>配置信息的配置 BPDU（不超过 35 个字节）</strong>，另一种包含 <strong>拓扑变化信息的拓扑变化通知 BPDU （不超过 4 个字节）</strong>。</li>
<li>在配置 BPDU 包的 Bride ID 信息，是选取根网桥或根交换机的主要依据；</li>
<li>一般情况下，Bridge ID 值最小的成为根网桥或根交换机；</li>
<li>Bridge ID 用 8 个字节表示，后 6 个字节为交换机的 MAC 地址，前 2 个字节为优先级值；</li>
<li>优先级值越小，优先级越高（根网桥或根交换机）；</li>
<li><strong>优先级取值范围 0 ~ 61440， 增质量为 4096， 交换机的优先级一般默认为 32768</strong>，可以使用命令人工设置；</li>
<li>一台交换机的优先级设置 8189，优先级高级其他交换机，会成为根交换机；</li>
<li>选择根网桥时，优先级相同，会根据 MAC 地址的值决定根网桥，<strong>MAC 的值最小的为根网桥</strong>；</li>
<li>默认情况下，交换机 <strong>每 2 秒定时发送一次 BPDU</strong>，当检测到网络拓扑变化或故障发生时，也会发送新的 BPDU，以及时进行生成树的更新。</li>
</ul>
<h2 id="交换机的配置"><a href="#交换机的配置" class="headerlink" title="交换机的配置"></a>交换机的配置</h2><h3 id="交换机的配置方式"><a href="#交换机的配置方式" class="headerlink" title="交换机的配置方式"></a>交换机的配置方式</h3><ul>
<li><p>使用Console端口配置</p>
<ul>
<li>使用控制（<strong>Console</strong>）端口配置交换机，常用于交换机刚出厂并进行第一次配置时所采用的模式</li>
<li>Console是一个用来连接配置终端的异步串行口，接口标准为<strong>RJ-45</strong></li>
<li>是交换机刚出厂时，第一次对其进行配置所用的方法</li>
<li>使用Console端口配置交换机时，需要准备一台已经安装了超级终端软件的计算机作为配置终端，同时还需要一条由厂家提供的RJ-45到9针或25针异步串行接口的信号电缆</li>
<li>使用超级终端软件对异步串行口进行参数配置：<strong>传输速率9600</strong>，<strong>数据位8位</strong>，<strong>停止位1位</strong>。</li>
</ul>
</li>
<li><p>使用telnet命令配置</p>
<ul>
<li>使用 <strong>Telnet</strong> 配置交换机，常用于远程配置模式，该模式要求交换机已经连接到网上，而且已配置了交换机的设备管理地址</li>
</ul>
</li>
<li><p>使用浏览器配置交换机</p>
<ul>
<li>使用浏览器（<strong>IE</strong>）配置交换机，主要用于交换机被设置成 WEB 服务器，然后通过网络上的任意一个终端站点使用浏览器对交换机进行配置</li>
</ul>
</li>
<li><p>具体步骤</p>
<ol>
<li><p>交换机的配置</p>
</li>
<li><p>启用交换机的HTTP Server</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CatOS:    Catalyst6500&gt; (enable)  set ip http server enable</span><br><span class="line">Cisco IOS:  switch-3548(config)#ip http server</span><br></pre></td></tr></table></figure></li>
<li><p>配置HTTP用户认证方式:   enable、 local、tacacs</p>
</li>
<li><p>下载并安装Jave-plugin插件</p>
</li>
<li><p>使用Web浏览器监控和配置交换机</p>
</li>
</ol>
</li>
</ul>
<h3 id="配置交换机的系统信息"><a href="#配置交换机的系统信息" class="headerlink" title="配置交换机的系统信息"></a>配置交换机的系统信息</h3><ul>
<li><p>配置交换机的主机名</p>
<ul>
<li><p>Cisco IOS</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">switch-3548(config)#</span><span class="bash">hostname switch-PHY-3548</span></span><br><span class="line">switch-PHY-3548(config) #</span><br></pre></td></tr></table></figure></li>
<li><p>CatOS</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CatOS6500 &gt; (enable) set system name switch-PHY-6500</span><br><span class="line"> System name set.  </span><br><span class="line">switch-PHY-6500 &gt; (enable) </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>配置超级用户口令</p>
<ul>
<li><p>Cisco IOS</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">switch-3548(config)#</span><span class="bash"> <span class="built_in">enable</span> password zzz(明文)</span></span><br><span class="line"><span class="meta">switch-3548(config)#</span><span class="bash"> <span class="built_in">enable</span> password 7 zzz(加密)</span></span><br><span class="line"><span class="meta">switch-3548(config)#</span><span class="bash"> <span class="built_in">enable</span> secret 5 zzz(加密)</span></span><br></pre></td></tr></table></figure></li>
<li><p>CatOS</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">CatOS6500&gt;</span><span class="bash"> (<span class="built_in">enable</span>) <span class="built_in">set</span> enablepass</span></span><br><span class="line">Enter old password:  </span><br><span class="line">Enter new password:</span><br><span class="line">Retype new password:</span><br><span class="line">Password changed.</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>设置远程登录口令</p>
<ul>
<li><p>Cisco IOS</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">switch-3548 (config)#line vty 0 4</span><br><span class="line">switch-3548 (config-line)# password 0 zzz (明文) </span><br><span class="line">switch-3548 (config-line)# password 7 zzz (加密) </span><br><span class="line">switch-3548 (config-line)#</span><br></pre></td></tr></table></figure></li>
<li><p>CatOS</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">CatOS6500&gt;</span><span class="bash"> (<span class="built_in">enable</span>) <span class="built_in">set</span> password</span> </span><br><span class="line">Enter old password:  </span><br><span class="line">Enter new password:</span><br><span class="line">Retype new password:</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>交换机的基本配置一般都是用过 <strong>使用 Console 端口配置方式</strong> 完成，配置的主要内容哟配置交换机的主机名、超级用户口令、设备管理地址和远程登录口令</p>
</li>
<li><p>关于交换机配置命令语句，主要时以 Cisco IOS（35 系类）和 Catalyst OS（65 系列）两种交换机操作系统来讲解</p>
</li>
<li><p>那么常考的配置命令语句有 <strong>设置系统时间、配置设备管理 IP 地址</strong></p>
</li>
</ul>
<h3 id="交换机端口配置"><a href="#交换机端口配置" class="headerlink" title="交换机端口配置"></a>交换机端口配置</h3><ul>
<li>35 系列<ul>
<li>设置时间：<code>clock set HH:mm:ss DD MM YYYY</code></li>
<li>配置 IP：<code>ip address &lt;IP 地址&gt; &lt;子网掩码&gt;</code></li>
<li>缺省路由：<code>ip default-gateway &lt;缺省路由 IP 地址&gt;</code></li>
<li>VLAN1 时用于设备管理的缺省 VLAN</li>
<li>配置端口描述信息：<ol>
<li><code>(config)# interface f0/1</code> (进入端口配置模式)</li>
<li><code>(config-if)# description To-Webserver</code>（配置端口描述信息）</li>
<li><code>(config-if)# shutdown</code>（关闭端口）</li>
<li><code>(config-if)# no shutdown</code>（开启端口）</li>
<li><code>(config-if)# duplex auto</code>（设置为自动协商，默认）</li>
<li><code>(config-if)# duplex full</code> （设置为全双工）</li>
<li><code>(config-if)# duplex half</code> （设置为半双工）</li>
<li><code>(config-if)# speed auto</code> （自动速率）</li>
<li><code>(config-if)# speed 10</code> （设置速率 10Mbit/s）</li>
</ol>
</li>
</ul>
</li>
<li>65 系类<ul>
<li>设置时间：<code>set time ww MM/DD/YYYY HH:mm:ss</code></li>
<li>配置 IP：<code>set interface sc0 &lt;IP 地址&gt; &lt;子网掩码&gt; &lt;直接广播地址&gt;</code></li>
<li>缺省路由：<code>set ip route 0.0.0.0 &lt;缺省路由 IP 地址&gt;</code></li>
<li>配置端口描述信息：<ol>
<li><code>(enable) set port name &lt;mod/port&gt; &lt;name&gt;</code> （name 为端口描述，一般不超过 240 个）</li>
<li><code>(enable) set port disable &lt;mod/port&gt;</code> （开启端口）</li>
<li><code>(enable) set port enable &lt;mod/port&gt;</code> （关闭端口）</li>
<li><code>(enable) set port duplex &lt;mod/port&gt; full</code> （全双工）</li>
<li><code>(enable) set port duplex &lt;mod/port&gt; half</code> （半双工）</li>
<li><code>(enable) set prot speed &lt;mod/port&gt; auto</code> （自动速率）</li>
<li><code>(enable) set prot speed 10</code> （设置速率 10Mbit/s）</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="交换机-VLAN-的配置"><a href="#交换机-VLAN-的配置" class="headerlink" title="交换机 VLAN 的配置"></a>交换机 VLAN 的配置</h2><p>交换机 VLAN 的配置主要任务是：配置 VTP、建立或删除 VLAN、为交换机端口分配 VLAN 和在交换机端口上配置 VLAN Trunk。</p>
<h3 id="VLAN-配置"><a href="#VLAN-配置" class="headerlink" title="VLAN 配置"></a>VLAN 配置</h3><ul>
<li>35 系列<ul>
<li>进入 链接：<code>Switch-3528-TEST&gt; # vlan data</code></li>
<li>建立 VLAN： <code>(vlan) vlan &lt;vlan_ID&gt; name &lt;vlan_name&gt;</code></li>
<li>删除 VLAN: <code>(vlan) no vlan &lt;vlan_ID&gt;</code></li>
<li>修改 VLAN： <code>(vlan) vlan &lt;vlan_ID&gt; name &lt;vlan_name&gt;</code></li>
</ul>
</li>
<li>65 系列<ul>
<li>进入：<code>Switch-6509-TEST&gt; # enable</code></li>
<li>建立 VLAN: <code>(enable) set vlan &lt;vlan_ID&gt; name &lt;vlan_name&gt;</code></li>
<li>删除 VLAN: <code>(enable) clear vlan &lt;vlan_ID&gt;</code></li>
<li>修改 VLAN: <code>(enable) set vlan &lt;vlan_ID&gt; name &lt;vlan_name&gt;</code></li>
</ul>
</li>
</ul>
<h3 id="VLAN-Trunk-的配置"><a href="#VLAN-Trunk-的配置" class="headerlink" title="VLAN Trunk 的配置"></a>VLAN Trunk 的配置</h3><ul>
<li><p>35 系类</p>
<ul>
<li><p>进入交换机端口配置模式：</p>
<ol>
<li><code>Switch-3528-TEST&gt; # configure terminal</code></li>
<li><code>(config) # int fo/24</code></li>
<li><code>(config-if) #</code></li>
</ol>
</li>
<li><p>配置 VLAN Trunk 模式：<code>(config-if)# switchport mode trunk</code></p>
</li>
<li><p>封装 VLAN 协议</p>
<p><strong>Cisco ISL：思科私有协议。</strong></p>
<p><strong>IEEE 802.1Q：俗称“Dot One Q”(dot1q),国际标准。</strong></p>
<p><strong>IEEE 802.1Q可用于不同厂家的交换设备互连，且双方交换机端口上都要封装dot1q协议</strong>，保证协议的一致性，否则不能正确的传输多个VLAN信息。</p>
<ol>
<li><code>(conifg-if)# switchport trunk encapsulation dotl q</code> (202.1q 模式)</li>
<li><code>(conifg-if)# switchport trunk encapsulation isl</code> (ISL 协议)</li>
<li><code>(config-if)# switchport trunk encapsulation negotiate P</code> (自动协商)</li>
</ol>
</li>
<li><p>设置允许中继的 VLAN: <code>(config-if)# switchport trunk allowed vlan</code> 1,10 | 11-20</p>
</li>
<li><p>设置不允许中继的 VLAN: <code>(config-if)# switchport trunk allowed vlan except</code> 1,10 | 11-20</p>
</li>
</ul>
</li>
<li><p>65 系列</p>
<ul>
<li>配置 VLAN Trunk 模式，分装 VLAN 协议：<code>(enable) set trunk &lt;mod/port&gt; &lt;mode&gt; &lt;type&gt;</code></li>
<li>设置允许中继的 VLAN：<code>(enable) set trunk &lt;mod/port&gt; vlan &lt;vlan_ID&gt;</code></li>
<li>设置不允许中继的 VLAN：<code>(enable) clear trunk &lt;mod/port&gt; &lt;vlan_ID&gt;</code></li>
</ul>
</li>
</ul>
<h3 id="交换机-VTP-的配置"><a href="#交换机-VTP-的配置" class="headerlink" title="交换机 VTP 的配置"></a>交换机 VTP 的配置</h3><p>VTP 是 VLAN 中继协议，也被称为 VALN 干道协议。他是一个 OSI 参考模型第二层的通信协议，主要用于管理在同一个域的网络范围内 VLANs 的建立 删除和命名</p>
<p>配置 VTP 的任务主要有两个：一是 <strong>建立 VTP 域</strong>，二是 <strong>设置 VTP 的工作模式</strong>；</p>
<p><strong>注意：</strong> 同一个域的所有交换机，必须运行同版本的 VTP，并具有相同的域名；</p>
<ul>
<li>VTP Server：一般，一个 VTP 域内的整个网络只设置一个 VTP Server, 它 <strong>维护该 VTP 域中所有 VLAN 信息列表，可以建立、删除或修改 VLAN</strong></li>
<li>VTP Client：也维护所有 VLAN 信息列表，但是它的VLAN 信息是从 VTP Server 学习到的，并且<strong>不具有建立、删除或修改 VLAN 的功能</strong>。</li>
<li>VTP Transparent：相当于一个独立的交换机，它不参与 VTP 工作，不从 VTP Server 学习 VLAN 的配置信息，二只拥有本设备上自己的 VLAN 信息，因此它也 <strong>只能建立、删除和修改本机上的 VLAN 信息</strong>。</li>
<li>35 系列<ul>
<li>进入工作模式：<code>Switch-3528-TEST&gt; # configure terminal</code></li>
<li>域名配置：<code>(config)# vtp domain TEST</code></li>
<li>工作模式：<code>(config)# vtp mode &lt;type&gt;</code> type=”server|client|transparent”</li>
</ul>
</li>
<li>65 系列<ul>
<li>域名配置：<code>(enable)# set vtp domain TEST</code></li>
<li>工作模式：<code>(enable)# set vtp mode &lt;type&gt;</code> type=”server|client|transparent”</li>
</ul>
</li>
</ul>
<h2 id="为交换机分配端口"><a href="#为交换机分配端口" class="headerlink" title="为交换机分配端口"></a>为交换机分配端口</h2><ul>
<li>35 系列<ul>
<li>进入端口配置模式：同上 <code>交换机 VLAN 的配置 &gt; 3 &gt; 35 系列</code></li>
<li>端口 VLAN 分配：<code>(config-if) switchport access vlan &lt;vlan_ID&gt;</code></li>
</ul>
</li>
<li>65 系列<ul>
<li>端口 VLAN 分配：<code>(enable) set vlan &lt;vlan_ID&gt; &lt;mod/port&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="交换机-STP-的配置"><a href="#交换机-STP-的配置" class="headerlink" title="交换机 STP 的配置"></a>交换机 STP 的配置</h2><h4 id="打开或关闭STP"><a href="#打开或关闭STP" class="headerlink" title="打开或关闭STP"></a>打开或关闭STP</h4><ul>
<li><p>35系列</p>
<p>switch-3548# configure terminal </p>
<p>switch-3548 (config)# spanning-tree vlan 3   </p>
<p>switch-3548 (config)# no spanning-tree vlan 3 </p>
</li>
<li><p>65系列</p>
<p>CatOS6500&gt; (enable) set spanning-tree enable 3 </p>
<p>CatOS6500&gt; (enable) set spanning-tree disable 3</p>
</li>
</ul>
<h4 id="配置根网桥和备份根网桥"><a href="#配置根网桥和备份根网桥" class="headerlink" title="配置根网桥和备份根网桥"></a>配置根网桥和备份根网桥</h4><ul>
<li><p>35系列</p>
<p>switch-3548 (config)# spanning-tree vlan 3 root primary</p>
<p>switch-3548 (config)# spanning-tree vlan 3 root secondary </p>
</li>
<li><p>65系列</p>
<p>CatOS6500&gt; (enable) set spanning-tree root 1,200-204</p>
<p>CatOS6500&gt; (enable) set spanning-tree secondary 1,200-204</p>
</li>
</ul>
<h4 id="配置生成树优先级"><a href="#配置生成树优先级" class="headerlink" title="配置生成树优先级"></a>配置生成树优先级</h4><p>配置生成树优先级：生成树优先级的取值范围是0~61440，增量是<strong>4096</strong>。优先级的值越小优先级越高，如果优先级为0是最高优先级，61440优先级最低。</p>
<ul>
<li>35 系列<ul>
<li>优先级配置：<code>(config)# spanning-tree vlan &lt;vlans&gt; prioriy &lt;0-61440&gt;</code></li>
</ul>
</li>
<li>65 系列<ul>
<li>优先级配置：<code>(enable)# set spanning prioriy &lt;0-61440&gt;</code></li>
</ul>
</li>
</ul>
<h4 id="配置生成树可选功能"><a href="#配置生成树可选功能" class="headerlink" title="配置生成树可选功能"></a>配置生成树可选功能</h4><ul>
<li>BackboneFast：是 <strong>阻塞端口不在等待这段时间</strong>，而是 <strong>直接将端口有侦听和学习状态换为转发状态</strong>；</li>
<li>UplinkGast：当生成树拓扑结构发生变化和在使用上链路组的冗余链路之间完成负载平衡，<strong>提供快速收敛</strong>；</li>
<li>PortFast：用于在接入层交换机端口上跳过正常的生成树操作，<strong>加快终端工作站接入网络中的速度</strong>。它的功能是使交换机的端口侦听和学习转台，<strong>直接从阻塞状态进入到转发状态</strong>；</li>
<li>BPDU Filtering：会是交换机在指定的端口上停止发送 BPDUs，对于进入这个端口的 BPDUs 也不做任何处理，同时 <strong>立刻就昂端口转台转换为转发状态</strong>；</li>
<li>35 系列：<ul>
<li>BackboneFast:<code>(config)# spanning-tree BackboneFast</code></li>
<li>UplinkFast：<code>(config)# spanning-tree uplinkfast</code></li>
<li>PortFast：<code>(config)# spanning-tree portfast defalut</code></li>
<li>BPDU Filtering：<code>(config)# spanning-tree portfast bpdufilter default</code></li>
</ul>
</li>
<li>65 系列：<ul>
<li>BackboneFast:<ol>
<li><code>(enable)# set spantree backbonefast enable</code></li>
<li><code>(enable)# set spantree backbonefast disable</code></li>
</ol>
</li>
<li>UplinkFast：<ol>
<li><code>(enable)# set spantree uplinkfast enable</code></li>
<li><code>(enable)# set spantree uplinkfast disable</code></li>
</ol>
</li>
<li>PortFast：<ol>
<li><code>(enable)# set spantree portfast &lt;mod/port&gt; enable</code></li>
<li><code>(enable)# set spantree portfast &lt;mod/port&gt; disable</code></li>
<li><code>(enable)# set spantree portfast &lt;mod/port&gt; default</code></li>
</ol>
</li>
<li>BPDU Filtering：<ol>
<li><code>(enable)# set spantree portfast bpdu-filter enable</code></li>
<li><code>(enable)# set spantree portfast bpdu-filter disable</code></li>
<li><code>(enable)# set spantree portfast bpdu-filter &lt;mod/port&gt; enable</code></li>
<li><code>(enable)# set spantree portfast bpdu-filter &lt;mod/port&gt; disable</code></li>
<li><code>(enable)# set spantree portfast bpdu-filter &lt;mod/port&gt; default</code></li>
</ol>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>NCRE</category>
      </categories>
      <tags>
        <tag>网络技术</tag>
      </tags>
  </entry>
  <entry>
    <title>网络层：控制平面</title>
    <url>/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h2><p>路由：按照某种指标（传输延迟,所经过的站点数目等）找到一条从源节点到目标节点的较好路径</p>
<ul>
<li>以网络为单位进行路由（路由信息通告+路由计算）</li>
<li>网络——网络的路由 = 路由器——路由器之间的最优路径，用子网的方式大大降低了路由计算的规模</li>
<li>指标：站数，延迟，费用，队列长度等，或者是一些单纯指标的加权平均，采用什么样的指标，表示网络使用者希望网络在什么方面表现突出，什么指标网络使用者比较重视，即代价</li>
</ul>
<p>路由选择算法（routing algorithm）：网络层软件的一部分,完成路由功能</p>
<span id="more"></span>

<p><strong>网络的图抽象</strong></p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210826092308774.png" alt="image-20210826092308774"></p>
<ul>
<li>图：G = (N,E) </li>
<li>N = 路由器集合 = { u, v, w, x, y, z } </li>
<li>E = 链路集合 ={ (u,v), (u,x), (v,x), (v,w), (x,w), (x,y), (w,y), (w,z), (y,z) } </li>
<li>c(x,x’) = 链路的代价 (x,x’)<ul>
<li>代价可能总为１，跳数</li>
<li>或是链路带宽的倒数，最大带宽路径</li>
<li>或是拥塞情况的倒数，最不拥塞路径</li>
</ul>
</li>
<li>路由的输入：拓扑、边的代价、源节点</li>
<li>路由的输出：源节点的汇集树</li>
</ul>
<p>最优化原则（optimality principle）</p>
<p><strong>汇集树（sink tree）</strong></p>
<ul>
<li><p>此节点到所有其它节点的最优路径形成的树</p>
</li>
<li><p>路由选择算法就是为所有路由器找到并使用汇集树</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210826092804242.png" alt="image-20210826092804242"></p>
</li>
</ul>
<p><strong>路由选择算法的原则</strong></p>
<ul>
<li>正确性（correctness）<ul>
<li>算法必须是正确的和完整的，使分组一站一站接力，正确发向目标站</li>
<li>目标所有的站地址，在路由表中都能找到相应的表项</li>
<li>没有处理不了的目标站地址</li>
</ul>
</li>
<li>简单性（simplicity）<ul>
<li>算法在计算机上应简单：最优但复杂的算法</li>
<li>时间上延迟大造成不实用，不应为了获取路由信息增加很多的通信量</li>
</ul>
</li>
<li>健壮性（robustness）<ul>
<li>算法应能适应通信量和网络拓扑的变化：通信量变化，网络拓扑的变化算法能很快适应</li>
<li>不向很拥挤的链路发数据，不向断了的链路发送数据</li>
</ul>
</li>
<li>稳定性（stability）：产生的路由不应该摇摆</li>
<li>公平性（fairness）：对每一个站点都公平</li>
<li>最优性（optimality）：某一个指标的最优，时间上，费用 上，等指标，或综合指标；实际上，获取最优的结果代价较高，可以是次优的</li>
</ul>
<p><strong>路由算法分类</strong></p>
<p>全局/局部路由信息</p>
<ul>
<li>全局<ul>
<li>所有的路由器拥有完整的拓扑和边的代价的信息</li>
<li>“link state” 算法 </li>
</ul>
</li>
<li>分布式<ul>
<li>路由器只知道与它有物理连接关系的邻居路由器，和到相应邻居路由器的代价值</li>
<li>叠代地与邻居交换路由信息、计算路由信息</li>
<li>“distance vector” 算法</li>
</ul>
</li>
</ul>
<p>静态/动态路由信息</p>
<ul>
<li>静态<ul>
<li>路由随时间变化缓慢</li>
<li>非自适应算法（non-adaptive algorithm）：不能适应网络拓扑和通行量的变化，路由表使事现计算好的</li>
</ul>
</li>
<li>动态<ul>
<li>路由变化很快</li>
<li>周期性更新</li>
<li>根据链路代价的变化而变化</li>
<li>自适应路由选择(adaptive algorithm）：能适应网络拓扑和通行量的变化</li>
</ul>
</li>
</ul>
<h3 id="LS算法"><a href="#LS算法" class="headerlink" title="LS算法"></a>LS算法</h3><p>链路状态路由选择算法：Link State</p>
<h4 id="LS的应用情况"><a href="#LS的应用情况" class="headerlink" title="LS的应用情况"></a>LS的应用情况</h4><ul>
<li>OSPF协议是一种LS协议，被用于Internet上</li>
<li>IS-IS（intermediate system-intermediate system）：被用于Internet主干中</li>
</ul>
<h4 id="LS路由的工作过程"><a href="#LS路由的工作过程" class="headerlink" title="LS路由的工作过程"></a>LS路由的工作过程</h4><ul>
<li>各点通过各种渠道获得整个网络拓扑，网络中所有链路代价等信息（这部分和算法没关系，属于协议和实现）</li>
<li>使用LS路由算法，计算本站点到其它站点的最优路径（汇集树），得到路由表</li>
<li>按照此路由表转发分组（datagram方式）</li>
</ul>
<h4 id="链路状态路由选择（link-state-routing）"><a href="#链路状态路由选择（link-state-routing）" class="headerlink" title="链路状态路由选择（link state routing）"></a>链路状态路由选择（link state routing）</h4><ol>
<li>发现相邻节点，获知对方网络地址<ul>
<li>一个路由器工作之后，向所有线路发送HELLO分组</li>
<li>其它路由器收到HELLO分组，回送应答，在应答分组中，告知自己的名字（全局唯一）</li>
<li>在LAN中，通过广播HELLO分组，获得其它路由器的信息</li>
</ul>
</li>
<li>测量到相邻节点的代价（延迟，开销）<ul>
<li>实测法：发送一个分组要求对方立即响应</li>
<li>回送一个ECHO分组</li>
<li>通过测量时间可以估算出延迟情况</li>
</ul>
</li>
<li>组装一个分组，描述相邻节点的情况</li>
<li>将分组通过扩散（即泛洪）的方法发到所有其它路由器<ul>
<li>顺序号：用于控制无穷的扩散，每个路由器都记录（源路由器,顺序号），发现重复的或老的就不扩散<ul>
<li>具体问题1：循环使用问题</li>
<li>具体问题2：路由器崩溃之后序号从0开始</li>
<li>具体问题3：序号出现错误</li>
</ul>
</li>
<li>解决问题的办法：年龄字段（age）<ul>
<li>生成一个分组时，年龄字段不为0</li>
<li>每个一个时间段，AGE字段减1</li>
<li>AGE字段为0的分组将被抛弃</li>
</ul>
</li>
<li>扩散分组的数据结构<ul>
<li>Source：从哪个节点收到LS分组</li>
<li>Seq，Age：序号，年龄</li>
<li>Send flags：发送标记，必须向指定的哪些相邻站点转发LS分组</li>
<li>ACK flags：本站点必须向哪些相邻站点发送应答</li>
<li>DATA：来自source站点的LS分组</li>
</ul>
</li>
</ul>
</li>
<li>通过Dijkstra算法找出最短路径<ul>
<li>路由器获得各站点LS分组和整个网络的拓扑</li>
<li>通过Dijkstra算法计算出到其它各路由器的最短路径（汇集树）</li>
<li>将计算结果安装到路由表中</li>
</ul>
</li>
</ol>
<h3 id="DV算法"><a href="#DV算法" class="headerlink" title="DV算法"></a>DV算法</h3><h4 id="距离矢量路由选择（distance-vector-routing）"><a href="#距离矢量路由选择（distance-vector-routing）" class="headerlink" title="距离矢量路由选择（distance vector routing）"></a>距离矢量路由选择（distance vector routing）</h4><ul>
<li><p>动态路由算法之一 </p>
</li>
<li><p>DV算法历史及应用情况</p>
<ul>
<li>1957 Bellman, 1962 Ford Fulkerson</li>
<li>用于ARPANET, Internet(RIP)  DECnet , Novell, ApplTalk</li>
</ul>
</li>
<li><p>距离矢量路由选择的基本思想</p>
<ul>
<li><p>各路由器维护一张路由表，结构如图</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210826104659992.png" alt="image-20210826104659992"></p>
</li>
<li><p>各路由器与相邻路由器交换路由表</p>
</li>
<li><p>根据获得的路由信息，更新路由表</p>
</li>
</ul>
<img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210826110539960.png" alt="image-20210826110539960" style="zoom:67%;"></li>
</ul>
<h4 id="距离矢量路由例子"><a href="#距离矢量路由例子" class="headerlink" title="距离矢量路由例子"></a>距离矢量路由例子</h4><ul>
<li><p>以当前节点J为例，相邻节点 A，I，H，K</p>
</li>
<li><p>J测得到A，I，H，K的延迟为8ms，10ms，12ms，6ms</p>
</li>
<li><p>通过交换DV，从A，I，H，K获得到它们到G的延迟为18ms，31ms，6ms，31ms</p>
</li>
<li><p>因此从J经过A，I，H，K到G的延迟为26ms，41ms，18ms，37ms</p>
</li>
<li><p>将到G的路由表项更新为18ms，下一跳为：H</p>
</li>
<li><p>其它目标一样，除了本节点J</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210826111139905.png" alt="image-20210826111139905"></p>
</li>
</ul>
<h4 id="距离矢量算法"><a href="#距离矢量算法" class="headerlink" title="距离矢量算法"></a><strong>距离矢量算法</strong></h4><p><strong>Bellman-Ford 方程（动态规划）</strong></p>
<p>设 $d_x(y)$：从x到y的最小路径代价，则$d_x(y)=\min {c(x,v)+d_v(y)}$</p>
<ul>
<li>$\min$：取所有x的邻居取最小的v</li>
<li>$c(x,v)$：到邻居v的代价</li>
<li>$d_v(y)$：从邻居v到目标y的代价</li>
</ul>
<ul>
<li><p>异步式，迭代：每次本地迭代被以下事件触发</p>
<ul>
<li>本地链路代价变化了</li>
<li>从邻居来了DV的更新消息</li>
</ul>
</li>
<li><p>分布式：每个节点只是在自己的DV改变之后向邻居通告，然后邻居们在有必要的时候通知他们的邻居</p>
</li>
<li><p>每个节点：<img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210826112432045.png" alt="image-20210826112432045"></p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210826114815799.png" alt="image-20210826114815799"></p>
</li>
<li><p>经过多次迭代，使得每个节点获得真实的表项</p>
</li>
</ul>
<h4 id="DV的无穷计算问题"><a href="#DV的无穷计算问题" class="headerlink" title="DV的无穷计算问题"></a>DV的无穷计算问题</h4><ul>
<li><p>DV的特点：好消息传的快，坏消息传的慢</p>
<blockquote>
<p>好消息：某个路由器接入或有更短的路径</p>
<p>坏消息：某个路由器被截断，不可达</p>
</blockquote>
<ul>
<li>好消息的传播以每一个交换周期前进一个路由器的速度进行</li>
<li>坏消息的传播速度非常慢（无穷计算问题）</li>
</ul>
</li>
<li><p>水平分裂（split horizon）算法：一种对无穷计算问题的解决办法</p>
<ul>
<li><p>C知道要经过B才能到达A，所以C向B报告它到A的距离为INF；C 告诉D它到A的真实距离</p>
</li>
<li><p>D告诉E，它到A的距离，但D告诉C它通向A的距离为INF</p>
</li>
<li><p>第一次交换：B通过测试发现到A的路径为INF，而C也告诉B到A的距离为INF，因此，B到A的距离为INF</p>
</li>
<li><p>第二次交换：C从B和D那里获知，到A的距离为INF，因此将它到A的距离为INF</p>
</li>
<li><p>坏消息以一次交换一个节点的速度传播</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png" alt="未命名文件"></p>
</li>
<li><p>缺点：在某些拓扑形式下会失败（存在环路）</p>
</li>
</ul>
</li>
</ul>
<h3 id="LS-和-DV-算法的比较"><a href="#LS-和-DV-算法的比较" class="headerlink" title="LS 和 DV 算法的比较"></a>LS 和 DV 算法的比较</h3><p>消息复杂度（DV胜出）</p>
<ul>
<li>LS：有 n 节点, E 条链路,发送报文：O(nE)个<ul>
<li>局部的路由信息；全局传播</li>
</ul>
</li>
<li>DV：只和邻居交换信息<ul>
<li>全局的路由信息，局部传播</li>
</ul>
</li>
</ul>
<p>收敛时间（LS胜出）</p>
<ul>
<li>LS：O($n^2$) <ul>
<li>算法有可能震荡</li>
</ul>
</li>
<li>DV：收敛较慢<ul>
<li>可能存在路由环路</li>
<li>count-to-infinity 问题</li>
</ul>
</li>
</ul>
<p>健壮性（LS胜出） </p>
<ul>
<li>LS<ul>
<li>节点会通告不正确的链路代价</li>
<li>每个节点只计算自己的路由表</li>
<li>错误信息影响较小，局部，路由较健壮</li>
</ul>
</li>
<li>DV<ul>
<li>DV 节点可能通告对全网所有节点的不正确路径代价<ul>
<li>距离矢量</li>
</ul>
</li>
<li>每一个节点的路由表可能被其它节点使用<ul>
<li>错误可以扩散到全网</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="因特网中自治系统内部的路由选择"><a href="#因特网中自治系统内部的路由选择" class="headerlink" title="因特网中自治系统内部的路由选择"></a>因特网中自治系统内部的路由选择</h2><h3 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h3><p>路由信息协议：Routing Information Protocol：</p>
<ul>
<li>基于Distance vector 算法<ul>
<li>距离矢量：:每条链路代价cost=1，即hops (max = 15 hops) 跳数</li>
<li>DV每隔30秒和邻居交换DV，<strong>通告</strong></li>
<li>每个通告包括：最多25个<strong>目标子网</strong></li>
</ul>
</li>
<li>DV：在邻居之间每30秒交换通告报文<ul>
<li>定期，而且在改变路由的时候发送通告报文</li>
<li>在对方的请求下可以发送通告报文</li>
</ul>
</li>
<li>每一个通告：至多AS内部的25个目标网络的 DV <ul>
<li>目标网络+跳数：一次公告最多25个；子网最大跳数为16 </li>
</ul>
</li>
</ul>
<p>RIP链路失效和恢复如果：180秒没有收到通告信息，则认为邻居或者链路失效</p>
<ul>
<li>发现经过这个邻居的路由已失效</li>
<li>新的通告报文会传递给邻居</li>
<li>邻居因此发出新的通告（如果路由变化的话）</li>
<li>链路失效快速地在整网中传输</li>
<li>使用毒性逆转（poison reverse）阻止ping-pong回路（不可达的距离：跳数无限 = 16 段）</li>
</ul>
<p>RIP 进程处理</p>
<ul>
<li>RIP 以应用进程的方式实现：route-d (daemon) </li>
<li>通告报文通过UDP报文传送，周期性重复</li>
<li>网络层的协议使用了传输层的服务（传输距离矢量），以应用层实体的方式实现</li>
</ul>
<h3 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h3><p>开放最短路径优先：Open Shortest Path First</p>
<ul>
<li>使用LS算法<ul>
<li>LS 分组在网络中（一个AS内部）分发</li>
<li>全局网络拓扑、代价在每一个节点中都保持</li>
<li>路由计算采用Dijkstra算法</li>
</ul>
</li>
<li>OSPF通告信息中携带表项，每一个邻居路由器一个表项</li>
<li>通告信息会传遍AS全部（通过泛洪）<ul>
<li>在IP数据报上直接传送OSPF报文（而不是通过UDP和TCP）</li>
</ul>
</li>
<li>IS-IS路由协议：几乎和OSPF一样</li>
<li>安全：所有的OSPF报文都是经过认证的 (防止恶意的攻击)</li>
<li>允许有多个代价相同的路径存在 (在RIP协议中只有一个)</li>
<li>对于每一个链路，对于不同的TOS有多重代价矩阵<ul>
<li>例如：卫星链路代价对于尽力而为的服务代价设置比较低，对实时服务代价设置的比较高</li>
<li>支持按照不同的代价计算最优路径，如：按照时间和延迟分别计算最优路径</li>
</ul>
</li>
<li>对单播和多播的集成支持<ul>
<li>Multicast OSPF (MOSPF) 使用相同的拓扑数据库， 就像在OSPF中一样</li>
</ul>
</li>
<li>在大型网络中支持<strong>层次性</strong>OSPF</li>
</ul>
<p>层次化OSPF路由</p>
<ul>
<li><p>2个级别的层次性：本地, 骨干</p>
<ul>
<li>链路状态通告仅仅在本地区域Area范围内进行</li>
<li>每一个节点拥有本地区域的拓扑信息<ul>
<li>关于其他区域，仅知道去它的方向，通过区域边界路由器（最短路径）</li>
</ul>
</li>
</ul>
</li>
<li><p>区域边界路由器：“汇总（聚集）”到自己区域内网络的距离，向其它区域边界路由器通告</p>
</li>
<li><p>骨干路由器：仅仅在骨干区域内，运行OSPF路由</p>
</li>
<li><p>边界路由器：连接其它的AS’s</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210826134242095.png" alt="image-20210826134242095"></p>
</li>
</ul>
<h2 id="ISP之间的路由选择：BGP"><a href="#ISP之间的路由选择：BGP" class="headerlink" title="ISP之间的路由选择：BGP"></a>ISP之间的路由选择：BGP</h2><h3 id="平面路由"><a href="#平面路由" class="headerlink" title="平面路由"></a>平面路由</h3><ul>
<li>一个网络中的所有路由器的地位一样</li>
<li>通过LS, DV，或者其他路由算法，所有路由器都要知道其他所有路由器（子网）如何走</li>
<li>所有路由器在一个平面</li>
<li>平面路由的问题<ul>
<li>规模巨大的网络中，路由信息的存储、传输和计算代价巨大<ul>
<li>DV：距离矢量很大，且不能够收敛</li>
<li>LS：几百万个节点的LS分组的泛洪传输，存储以及最短路径算法的计算</li>
</ul>
</li>
<li>管理问题<ul>
<li>不同的网络所有者希望按照自己的方式管理网络</li>
<li>希望对外隐藏自己网络的细节</li>
<li>希望和其它网络互联</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a>层次路由</h3><p>层次路由：将互联网分成一个个AS(路由器区域)</p>
<ul>
<li>某个区域内的路由器集合，自治系统（Autonomous  Systems，AS）</li>
<li>一个AS用AS Number （ASN）唯一标示</li>
<li>一个ISP可能包括1个或者多个AS</li>
</ul>
<p>路由变成了2个层次路由</p>
<ul>
<li>AS内部路由：在同一个AS内路由器运行相同的路由协议<ul>
<li>“intra-AS” routing  protocol：内部网关协议</li>
<li>不同的AS可能运行着不同的内部网关协议</li>
<li>能够解决规模和管理问题</li>
<li>如：RIP，OSPF，IGRP</li>
<li>网关路由器：AS边缘路由器，可以连接到其他AS</li>
</ul>
</li>
<li>AS间运行AS间路由协议<ul>
<li>“inter-AS” routing  protocol：外部网关协议</li>
<li>解决AS之间的路由问题，完 成AS之间的互联互通</li>
</ul>
</li>
</ul>
<p>层次路由的优点</p>
<ul>
<li>解决了规模问题<ul>
<li>内部网关协议解决：AS内部数量有限的路由器相互到达的问题，AS内部规模可控<ul>
<li>如AS节点太多，可分割AS，使得AS内部的节点数量有限</li>
</ul>
</li>
<li>AS之间的路由的规模问题<ul>
<li>增加一个AS，对于AS之间的路由从总体上来说，只是增加了一 个节点，即子网（每个AS可以用一个点来表示）</li>
<li>对于其他AS来说只是增加了一 个表项，就是这个新增的AS如何走的问题</li>
<li>扩展性强：规模增大，性能不会减得太多</li>
</ul>
</li>
</ul>
</li>
<li>解决了管理问题<ul>
<li>各个AS可以运行不 同的内部网关协议</li>
<li>可以使自己网络的细节不向外透露</li>
</ul>
</li>
</ul>
<h3 id="互联网AS间路由：BGP"><a href="#互联网AS间路由：BGP" class="headerlink" title="互联网AS间路由：BGP"></a>互联网AS间路由：BGP</h3><ul>
<li><p>BGP（Border Gateway Protocol）：自治区域间路由协议，边界网关协议</p>
</li>
<li><p>BGP 提供给每个AS以下方法</p>
<ul>
<li>eBGP：从相邻的ASes那里获得子网可达信息</li>
<li>iBGP：将获得的子网可达信息传遍到AS内部的所有路由器</li>
<li>根据子网可达信息和策略来决定到达子网的“好”路径</li>
</ul>
</li>
<li><p>允许子网向互联网其他网络通告“我在这里”</p>
</li>
<li><p>基于距离矢量算法（路径矢量），不仅仅是距离矢量，还包括到达各个目标网络的详细路径（AS 序号的列表）能够避免简单DV算法的路由环路问题</p>
</li>
</ul>
<ul>
<li><p>BGP会话：2个BGP路由器（“peers”）在一个半永久的TCP连接上交换BGP报文</p>
<ul>
<li>通告向不同目标子网前缀的“路径”（BGP是一个“路径矢量”协议）</li>
</ul>
</li>
<li><p>当通告一个子网前缀时，通告包括 BGP 属性</p>
<ul>
<li>prefix + attributes = “route” </li>
</ul>
</li>
<li><p>2个重要的属性</p>
<ul>
<li>AS-PATH：前缀的通告所经过的AS列表，如AS 67 AS 17<ul>
<li>检测环路；多路径选择</li>
<li>在向其它AS转发时，需要将自己的AS号加在路径上</li>
</ul>
</li>
<li>NEXT-HOP：从当前AS到下一跳AS有多个链路，在NETX-HOP 属性中，告诉对方通过哪个转发</li>
<li>其它属性：路由偏好指标，如何被插入的属性</li>
</ul>
</li>
<li><p>基于策略的路由</p>
<ul>
<li>当一个网关路由器接收到了一个路由通告，使用输入策略来接受或过滤（accept/decline.）<ul>
<li>过滤原因例1：不想经过某个AS，转发某些前缀的分组</li>
<li>过滤原因例2：已经有了一条往某前缀的偏好路径</li>
</ul>
</li>
<li>策略也决定了是否向它别的邻居通告收到的这个路由信息</li>
</ul>
</li>
</ul>
<ul>
<li>使用TCP协议交换BGP报文</li>
<li>BGP 报文<ul>
<li>OPEN：打开TCP连接，认证发送方</li>
<li>UPDATE：通告新路径（或者撤销原路径）</li>
<li>KEEPALIVE：在没有更新时保持连接，也用于对 OPEN 请求确认</li>
<li>NOTIFICATION：报告以前消息的错误，也用来关闭连接</li>
</ul>
</li>
</ul>
<ul>
<li><p>BGP 路径选择</p>
<ul>
<li><p>路由器可能获得一个网络前缀的多个路径，路由器必须进行路径的选择，路由选择可以基于</p>
<ol>
<li><p>本地偏好值属性：偏好策略决定</p>
</li>
<li><p>最短AS-PATH ：AS的跳数</p>
</li>
<li><p>最近的NEXT-HOP路由器：热土豆路由</p>
<blockquote>
<p>热土豆策略：选择具备最小内部区域代价的网关作为去往目的的出口，不操心域间的代价</p>
</blockquote>
</li>
<li><p>附加的判据：使用BGP标示</p>
</li>
</ol>
</li>
<li><p>一个前缀对应着多种路径，采用消除规则直到留下一条路径</p>
</li>
</ul>
</li>
</ul>
<p>为什么内部网关协议和外部网关协议如此不同?</p>
<ul>
<li>策略<ul>
<li>Inter-AS（外部）：管理员需要控制通信路径，谁在使用它的网络进行数据传输</li>
<li>Intra-AS（内部）：一个管理者，所以无需策略<ul>
<li>AS内部的各子网的主机尽可能地利用资源进行快速路由</li>
</ul>
</li>
</ul>
</li>
<li>规模<ul>
<li>AS间路由必须考虑规模问题，以便支持全网的数据转发</li>
<li>AS内部路由规模不是一个大的问题<ul>
<li>如果AS 太大，可将此AS分成小的AS，因此规模可控</li>
<li>AS之间只使多了一个点</li>
<li>或者AS内部路由支持层次性，层次性路由节约了表空间，降低了更新的数据流量</li>
</ul>
</li>
</ul>
</li>
<li>性能<ul>
<li>Intra-AS：关注性能</li>
<li>Inter-AS：策略可能比性能更重</li>
</ul>
</li>
</ul>
<h2 id="SDN控制平面"><a href="#SDN控制平面" class="headerlink" title="SDN控制平面"></a>SDN控制平面</h2><p>为什么需要一个逻辑上集中的控制平面？</p>
<ul>
<li>网络管理更加容易：避免路由器的错误配置，对于通信流的弹性更好</li>
<li>基于流表的转发，允 许“可编程”的路由器<ul>
<li>集中式“编程”更加容易：集中计算流表然后分发</li>
<li>传统方式分布式“编程”困难：在每个单独的路由器上分别运行分布式的算法，得到转发表（部署和升级代价高），而且要求各分布式计算出的转发表都得基本正确</li>
</ul>
</li>
<li>控制平面的开放实现（非私有）<ul>
<li>新的竞争生态</li>
</ul>
</li>
</ul>
<h3 id="SDN特点"><a href="#SDN特点" class="headerlink" title="SDN特点"></a>SDN特点</h3><ul>
<li>基于流的匹配+行动</li>
<li>控制平面和数据平面的分离</li>
<li>控制平面功能在数据交换设备之外实现</li>
<li>可编程控制：在控制器之上以网络应用形式实现各种网络功能</li>
</ul>
<h3 id="OpenFlow协议"><a href="#OpenFlow协议" class="headerlink" title="OpenFlow协议"></a>OpenFlow协议</h3><ul>
<li>控制器和SDN交换机交互的协议</li>
<li>采用TCP 来交换报文<ul>
<li>加密可选</li>
</ul>
</li>
<li>3种OpenFlow报文类型<ul>
<li>控制器&gt;&gt;&gt;交换机</li>
<li>异步（交换机&gt;&gt;&gt;控制器 ）</li>
<li>对称（misc）</li>
</ul>
</li>
</ul>
<p>OpenFlow：关键的控制器—交换机报文</p>
<ul>
<li>特性：控制器查询交换机特性，交换机应答</li>
<li>配置：交换机查询/设置交换机的配置参数</li>
<li>修改状态：增加删除修改OpenFlow表中的流表</li>
<li>packet-out：控制器可以将分组通过特定的端口发出</li>
</ul>
<p>OpenFlow：关键的交换机—控制器的报文</p>
<ul>
<li>分组进入：将分组（和它的控制）传给控制器，见来自控制器的packet-out报文</li>
<li>流移除：在交换机上删除流表项</li>
<li>端口状态：通告控制器端口的变化</li>
</ul>
<p> 网络管理员不需要直接通过创建/发送流表来编程交换机，而是采用在控制器上的app自动运算和配置</p>
<p>OpenDaylight（ODL）控制器和ONOS控制器</p>
<h2 id="ICMP：因特网控制报文协议"><a href="#ICMP：因特网控制报文协议" class="headerlink" title="ICMP：因特网控制报文协议"></a>ICMP：因特网控制报文协议</h2><ul>
<li>由主机、路由器、网关用于传达网络层控制信息<ul>
<li>错误报告：主机不可到达、 网络、端口、协议</li>
<li>Echo 请求和回复（ping）</li>
</ul>
</li>
<li>ICMP处在网络层，但是是在IP协议的上面，ICMP消息由IP数据报承载</li>
<li>ICMP 报文<ul>
<li>类型</li>
<li>编码</li>
<li>第一个导致该ICMP报文的IP数据报头8个字节</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>ICMP类型</th>
<th>编码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>回显回答（对ping的回答）</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>目的网络不可达</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>目的主机不可达</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>目的协议不可达</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>目的端口不可达</td>
</tr>
<tr>
<td>3</td>
<td>6</td>
<td>目的网络未知</td>
</tr>
<tr>
<td>3</td>
<td>7</td>
<td>目的主机未知</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>源抑制（拥塞控制）</td>
</tr>
<tr>
<td>8</td>
<td>0</td>
<td>回显请求</td>
</tr>
<tr>
<td>9</td>
<td>0</td>
<td>路由器通告</td>
</tr>
<tr>
<td>10</td>
<td>0</td>
<td>路由器发现</td>
</tr>
<tr>
<td>11</td>
<td>0</td>
<td>TTL过期</td>
</tr>
<tr>
<td>12</td>
<td>0</td>
<td>IP首部损坏</td>
</tr>
</tbody></table>
<h2 id="网络管理和SNMP"><a href="#网络管理和SNMP" class="headerlink" title="网络管理和SNMP"></a>网络管理和SNMP</h2><p>网络管理功能</p>
<ul>
<li>性能管理<ul>
<li>性能（利用率、吞吐量）量化、测量、报告、分析和控制不同网络部件的性能</li>
<li>涉及到的部件：单独部件（网卡，协议实体），端到端的路径</li>
</ul>
</li>
<li>故障管理：记录、检测和响应故障<ul>
<li>性能管理为长期监测设备性能</li>
<li>故障管理：突然发生的强度大的性能降低，强调对故障的响应</li>
</ul>
</li>
<li>配置管理：跟踪设备的配置，管理设备配置信息</li>
<li>账户管理：定义、记录和控制用户和设备访问网络资源<ul>
<li>限额使用、给予使用的收费，以及分配资源访问权限</li>
</ul>
</li>
<li>安全管理：定义安全策略，控制对网络资源的使用</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>大学课程</tag>
      </tags>
  </entry>
  <entry>
    <title>网络层：数据平面</title>
    <url>/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="网络层概述"><a href="#网络层概述" class="headerlink" title="网络层概述"></a>网络层概述</h2><p>网络层服务</p>
<ul>
<li>在发送主机和接收主机对之间传送段（segment）</li>
<li>在发送端将段封装到数据报中</li>
<li>在接收端，将段上交给传输层实体</li>
<li>网络层协议存在于<strong>每一个</strong>主机和路由器</li>
<li>路由器检查每一个经过它的IP数据报的头部</li>
</ul>
<span id="more"></span>

<p>网络层关键功能</p>
<ul>
<li>转发：将分组从路由器的输入接口转发到合适的输出接口（局部功能，数据平面）</li>
<li>路由：使用路由算法来决定分组从发送主机到目标接收主机的路径（全局功能，控制平面）<ul>
<li>路由选择算法</li>
<li>路由选择协议</li>
</ul>
</li>
</ul>
<p>网络层</p>
<ul>
<li><p>数据平面</p>
<ul>
<li><p>本地，每个路由器功能</p>
</li>
<li><p>决定从路由器输入端口到达的分组如何转发到输出端口</p>
</li>
<li><p>转发功能</p>
<ul>
<li><p>传统方式：基于目标地址+转发表</p>
</li>
<li><p>SDN方式：基于多个字段+流表</p>
<blockquote>
<p>SDN功能：转发，block（阻止），泛洪，修改字段等等</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>控制平面</p>
<ul>
<li>网络范围内的逻辑</li>
<li>决定数据报如何在路由器之间路由，决定数据报从源到目标主机之间的端到端路径</li>
<li>2个控制平面方法<ul>
<li>传统的路由算法：在路由器中被实现</li>
<li>software-defined networking（SDN，软件定义网络）：在远程的服务器中实现</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>传统方式</p>
<ul>
<li><p>每个路由器(Per-router)控制平面</p>
<ul>
<li>在每一个路由器中的单独路由器算法元件，在控制平面进行交互</li>
</ul>
</li>
<li><p>传统方式：路由和转发的相互作用</p>
<ul>
<li>控制平面：路由算法决定端到端路径 </li>
<li>数据平面：IP协议根据转发表决定了IP数据报在此路由器上的局部转发</li>
</ul>
</li>
</ul>
<p>SDN方式：逻辑集中的控制平面</p>
<ul>
<li>一个不同的（通常是远程的）控制器与本地控制代理（CAs） 交互</li>
<li>可编程的</li>
</ul>
<p>网络服务模型</p>
<ul>
<li>对于单个数据报的服务<ul>
<li>可靠传送</li>
<li>延迟保证，如：少于 40ms的延迟 </li>
</ul>
</li>
<li>对于数据报流的服务<ul>
<li>保序数据报传送</li>
<li>保证流的最小带宽</li>
<li>保证分组之间的延迟差</li>
</ul>
</li>
</ul>
<p>网络层和传输层连接服务区别</p>
<ul>
<li>网络层：在2个主机之间，涉及到路径上的一些路由器</li>
<li>传输层：在2个进程之间，很可能只体现在端系统上 (TCP连接)</li>
</ul>
<p>网络层服务模型</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210821103643065.png" alt="image-20210821103643065"></p>
<h2 id="路由器组成"><a href="#路由器组成" class="headerlink" title="路由器组成"></a>路由器组成</h2><p>高层面（非常简化的）通用路由器体系架构</p>
<ul>
<li>路由：运行路由选择算法／协议（RIP, OSPF, BGP）——-生成路由表</li>
<li>转发：从输入到输出链路交换数据报——–根据路由表进行分组的转发</li>
</ul>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210821104029835.png" alt="image-20210821104029835"></p>
<h3 id="输入端口"><a href="#输入端口" class="headerlink" title="输入端口"></a>输入端口</h3><p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/%E8%BE%93%E5%85%A5%E7%AB%AF%E5%8F%A3%E5%A4%84%E7%90%86.png" alt="输入端口处理"></p>
<ul>
<li><p>功能</p>
<ul>
<li>根据数据报头部的信息如：目的地址 ，在输入端口内存中的转发表中查找合适的输出端口（匹配+行动）</li>
<li>基于目标的转发：仅仅依赖于IP数据报的目标IP地址（传统方法）</li>
<li>通用转发：基于头部字段的任意集合进行转发</li>
<li>最长前缀匹配：当给定目标地址查找转发表时，采用最长地址前缀匹配的目标地址表项</li>
</ul>
</li>
<li><p>输入端口缓存</p>
<ul>
<li>当交换机构的速率小于输入端口的汇聚速率时， 在输入端口可能要排队<ul>
<li>排队延迟以及由于输入缓存溢出造成丢失</li>
</ul>
</li>
<li>Head-of-the-Line (HOL) blocking：排在队头的数据报 阻止了队列中其他数据报向前移动</li>
</ul>
</li>
</ul>
<h3 id="交换结构"><a href="#交换结构" class="headerlink" title="交换结构"></a>交换结构</h3><ul>
<li><p>将分组从输入缓冲区传输到合适的输出端口</p>
</li>
<li><p>交换速率：分组可以按照该速率从输入传输到输出</p>
<ul>
<li>运行速度经常是输入/输出链路速率的若干倍</li>
<li>N 个输入端口：交换机构的交换速度是输入线路速度的N倍，才不会成为瓶颈</li>
</ul>
</li>
<li><p>3种典型的交换机构：内存、总线、纵横式</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210821145011142.png" alt="image-20210821145011142"></p>
</li>
</ul>
<ol>
<li>通过内存交换：第一代路由器<ul>
<li>在CPU直接控制下的交换，采用传统的计算机</li>
<li>分组被拷贝到系统内存，CPU从分组的头部提取出目标地址，查找转发表，找到对应的输出端口，拷贝到输出端口</li>
<li>转发速率被内存的带宽限制（数据报通过BUS两遍）</li>
<li>一次只能转发一个分组</li>
<li>如Cisco Catalyst 8500系列</li>
</ul>
</li>
<li>通过总线交换<ul>
<li>数据报通过共享总线，从输入端口转发到输出端口</li>
<li>总线竞争: 交换速度受限于总线带宽</li>
<li>1次处理一个分组</li>
<li>对于接入网或企业级路由器，速度足够（但不适合区域或骨干网络）</li>
<li>如Cisco 6500路由器：内部通过一个32Gbps背板总线来交换分组</li>
</ul>
</li>
<li>通过互联网络（crossbar等）的交换<ul>
<li>同时并发转发多个分组，克服总线带宽限制</li>
<li>Banyan（榕树）网络，crossbar（纵横）和其它的互联网络被开发，将多个处理器连接成多处理器</li>
<li>当分组从端口A到达，转给端口Y；控制器短接相应的两个总线</li>
<li>高级设计：将数据报分片为固定长度的信元，通过交换网络交换</li>
<li>如Cisco12000：以60Gbps的交换速率通过互联网络</li>
</ul>
</li>
</ol>
<h3 id="输出端口"><a href="#输出端口" class="headerlink" title="输出端口"></a>输出端口</h3><p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/%E8%BE%93%E5%87%BA%E7%AB%AF%E5%8F%A3%E5%A4%84%E7%90%86.png" alt="输出端口处理"></p>
<ul>
<li><p>当数据报从交换机构的到达速度比传输速率快需要输出端口缓存</p>
<blockquote>
<p>数据报（分组）可能会被丢弃， 由于拥塞，缓冲区没有空间</p>
<p>缓存大小：</p>
<ul>
<li>RFC 3439 拇指规则（经验性规则）：平均缓存大小=典型的RTT倍于链路容量C</li>
<li>新推荐：有N（非常大）个流，缓存大小等于$\frac{RTT\times C}{\sqrt{N}}$</li>
</ul>
</blockquote>
</li>
<li><p>由调度规则选择排队的数据报进行传输</p>
</li>
<li><p>输出端口排队</p>
<ul>
<li>当多个输入端口同时向输出端口发送时，缓冲该分组（当通过交换网络到达的速率超过输出速率则缓存）</li>
<li>排队带来延迟，由于输出端口缓存溢出则丢弃数据报</li>
</ul>
</li>
</ul>
<h3 id="调度机制"><a href="#调度机制" class="headerlink" title="调度机制"></a>调度机制</h3><ul>
<li><p>调度: 选择下一个要通过链路传输的分组</p>
</li>
<li><p>FIFO (first in first out) scheduling：按照分组到来的次序发送（先进先出）</p>
</li>
<li><p>优先权排队</p>
<ul>
<li>优先权调度：发送最高优先权的分组</li>
<li>多类，不同类别有不同的优先权<ul>
<li>类别可能依赖于标记或者其他的头部字段，如 IP  source/dest，port  numbers，ds，etc.</li>
<li>先传高优先级的队列中的分组</li>
<li>高（低）优先权中的分组传输次序：FIFO</li>
</ul>
</li>
</ul>
</li>
<li><p>Round Robin (RR) scheduling</p>
<ul>
<li>多类</li>
<li>循环扫描不同类型的队列，发送完一类的一个分组，再发送下一个类的一个分组，循环所有类</li>
</ul>
</li>
<li><p>Weighted Fair Queuing (WFQ)</p>
<ul>
<li><p>循环加权公平排队（Round Robin queuing discipline）</p>
</li>
<li><p>在一段时间内，每个队列得到的服务时间是：$\frac{w_i}{\sum w_j}\times t$和权重成正比</p>
<blockquote>
<p>分母为所有分组排队等待传输的类别之和</p>
<p>分子为当前类</p>
</blockquote>
</li>
<li><p>每个类在每一个循环中获得不同权重的服务量</p>
</li>
</ul>
</li>
</ul>
<h2 id="IP-Internet-Protocol"><a href="#IP-Internet-Protocol" class="headerlink" title="IP Internet Protocol"></a>IP Internet Protocol</h2><p>网络层功能：</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210821152312850.png" alt="image-20210821152312850"></p>
<h3 id="IPv4数据报格式"><a href="#IPv4数据报格式" class="headerlink" title="IPv4数据报格式"></a>IPv4数据报格式</h3><p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F-1629531585689.png" alt="IPv4数据报格式"></p>
<ul>
<li>版本（version）：IP协议版本号，4bit</li>
<li>头部长度（head line）：确定IP数据报中载荷实际开始的地方，4bit</li>
<li>服务类型（type of service，TOS）：使不同类型的IP数据报相互区别</li>
<li>数据报长度（length）：16bit，IP数据报理论最大长度为65535字节</li>
<li>标识（16-bit identifier）、标志（flag）、片偏移（fragment offset）：与分片/重组有关</li>
<li>生存时间（time to live，TTL）：确保数据报不会在网络中循环。每经过一路由器处理，TTL值减1，TTL=0时，数据报丢弃</li>
<li>上层协议（upper layer）：指示IP数据报的数据部分应交给哪个特定的传输层协议（6为TCP、17为UDP）</li>
<li>首部校验和（Internet checksum）：检测收到的IP数据报中的比特错误</li>
<li>源和目的IP地址（source IP address，destination IP address）</li>
<li>选项（Options，if any）：该字段允许IP首部被扩展<ul>
<li>如时戳，由路由器记录, 指定所经过路由器的列表</li>
</ul>
</li>
<li>数据（data）：有效载荷</li>
</ul>
<h3 id="IP-分片和重组"><a href="#IP-分片和重组" class="headerlink" title="IP 分片和重组"></a>IP 分片和重组</h3><ul>
<li>分片（Fragmentation）和重组（Reassembly）</li>
<li>网络链路有MTU（最大传输单元）——链路层帧所携带的最大数据长度<ul>
<li>不同的链路类型有不同的MTU</li>
</ul>
</li>
<li>大的IP数据报在网络上被分片<ul>
<li>一个数据报被分割成若干个小的数据报<ul>
<li>相同的ID</li>
<li>不同的偏移量（offset）</li>
<li>最后一个分片标记为0</li>
</ul>
</li>
<li>“重组”只在最终的目标主机进行</li>
<li>IP头部的信息被用于标识，排序相关分片</li>
</ul>
</li>
</ul>
<p>例：4000 字节数据报包含20字节头部和3980字节数据，其MTU = 1500 bytes</p>
<p>解：第一片：20字节头部+1480字节数据                                             偏移量：0</p>
<p>​        第二片：20字节头部+1480字节数据（1480字节应用数据）     偏移量：1480/8=185</p>
<p>​        第三片：20字节头部+1020字节数据（应用数据）                      偏移量：2960/8=370</p>
<p>其中，flag标志位为1，表明后面还有片，为0表示是最后一片，后面没有其他片</p>
<h3 id="IPv4编址"><a href="#IPv4编址" class="headerlink" title="IPv4编址"></a>IPv4编址</h3><p>IP 地址：32位标示，对主机或者路由器的接口编址</p>
<p>接口：主机/路由器和物理链路的连接处</p>
<ul>
<li>路由器通常拥有多个接口 </li>
<li>主机也有可能有多个接口</li>
<li>IP地址和每一个接口关联</li>
</ul>
<p><strong>一个IP地址和一个接口相关联</strong></p>
<h4 id="子网-Subnet"><a href="#子网-Subnet" class="headerlink" title="子网(Subnet)"></a>子网(Subnet)</h4><ul>
<li><p>IP地址</p>
<ul>
<li>子网部分（高位bits）</li>
<li>主机部分（低位bits）</li>
</ul>
</li>
<li><p>一个子网内的节点（主机或者路由器）它们的IP地址的高位部分相同，这些节点构成的网络的一部分叫做子网</p>
</li>
<li><p>无需路由器介入，子网内各主机可以在物理上相互直接到达（1跳可达）</p>
<blockquote>
<p>有些也经由路由器，但其IP地址的高位相同，也称为子网</p>
</blockquote>
</li>
<li><p>路由信息的通告和计算是以一个子网为单位进行</p>
</li>
</ul>
<h4 id="子网掩码-subnet-mask"><a href="#子网掩码-subnet-mask" class="headerlink" title="子网掩码(subnet mask)"></a>子网掩码(subnet mask)</h4><p>32bits , 0 or 1 in each bit</p>
<ul>
<li>1：bit位置表示子网部分</li>
<li>0：bit位置表示主机部分</li>
</ul>
<p>原始的A、B、C类网络的子网掩码分别是</p>
<ul>
<li>A：255.0.0.0 ：11111111 00000000 0000000 00000000</li>
<li>B：255.255.0.0：11111111 11111111 0000000 00000000</li>
<li>C：255.255.255.0：11111111 11111111 11111111 00000000</li>
</ul>
<p>CIDR下的子网掩码例子：11111111 11111111 11111100 00000000</p>
<p>另外的一种表示子网掩码的表达方式</p>
<ul>
<li>/#</li>
<li>例：/22：表示前面22个bit为子网部分，如11111111 11111111 11111100 00000000 = 255.255.252.0/23</li>
</ul>
<h4 id="IP-地址分类"><a href="#IP-地址分类" class="headerlink" title="IP 地址分类"></a>IP 地址分类</h4><ul>
<li>Class A：126 networks ，16 million hosts</li>
<li>Class B：16382networks ，64 K hosts</li>
<li>Class C：2 million networks ，254 host</li>
<li>Class D：multicast，主播地址</li>
<li>Class E：reserved for future，预留地址</li>
</ul>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB.png" alt="网络地址分类"></p>
<ul>
<li>特殊IP地址<ul>
<li>子网部分: 全为 0—本网络（主机号）</li>
<li>主机部分: 全为0—本主机（网络号）</li>
<li>主机部分: 全为1–广播地址，这个网络的所有主机</li>
<li>127.x.x.x：回退地址</li>
</ul>
</li>
<li>内网（专用）IP地址<ul>
<li>专用地址：地址空间的一部份供专用地址使用</li>
<li>永远不会被当做公用地址来分配, 不会与公用地址重复<ul>
<li>只在局部网络中有意义，区分不同的设备</li>
</ul>
</li>
<li>专用地址范围<ul>
<li>Class A： 10.0.0.0~10.255.255.255 MASK 255.0.0.0</li>
<li>Class B： 172.16.0.0~172.31.255.255 MASK 255.255.0.0</li>
<li>Class C： 192.168.0.0~192.168.255.255 MASK  255.255.255.0</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="IP-编址：CIDR"><a href="#IP-编址：CIDR" class="headerlink" title="IP 编址：CIDR"></a>IP 编址：CIDR</h4><p>CIDR（Classless Inter Domain Routing）：无类域间路由</p>
<ul>
<li>子网部分可以在任意的位置</li>
<li>地址格式：a.b.c.d/x，其中 x 是地址中子网号的长度</li>
</ul>
<h4 id="转发表和转发算法"><a href="#转发表和转发算法" class="headerlink" title="转发表和转发算法"></a>转发表和转发算法</h4><p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210821165807446.png" alt="image-20210821165807446"></p>
<ul>
<li>获得IP数据报的目标地址（IP Des addr）</li>
<li>对于转发表中的每一个表项<ul>
<li>若 (IP Des addr) &amp; (mask) == destination Subnet Num，则按照表项对应的接口转发该数据报</li>
<li>若都没有找到，则使用默认表项（Default gateway）转发数据报</li>
</ul>
</li>
</ul>
<h4 id="如何获得一个IP地址"><a href="#如何获得一个IP地址" class="headerlink" title="如何获得一个IP地址"></a>如何获得一个IP地址</h4><ul>
<li>系统管理员将地址配置在一个文件中<ul>
<li>Wintel（Windows-Intel架构）：control-panel-&gt;network- &gt;configuration-&gt;tcp/ip-&gt;properties</li>
<li>UNIX：/etc/rc.config </li>
</ul>
</li>
<li>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）:  从服务器中动态获得一个IP地址<ul>
<li>也称为即插即用协议（plug-and-play）或零配置协议（zeroconf）</li>
</ul>
</li>
</ul>
<p>DHCP：允许主机在加入网络的时候，动态地从服务器那里获得IP地址</p>
<ul>
<li><p>可以更新对主机在用IP地址的租用期</p>
<blockquote>
<p>每次获取IP地址会生成一个租用期</p>
</blockquote>
</li>
<li><p>重新启动时，允许重新使用以前用过的IP地址</p>
</li>
<li><p>支持移动用户加入到该网络（短期在网）</p>
</li>
<li><p>工作流程</p>
<ul>
<li>主机广播“DHCP discover” 报文[可选]</li>
<li>DHCP 服务器用 “DHCP offer”提供报文响应[可选]</li>
<li>主机请求IP地址：发送 “DHCP request” 报文</li>
<li>DHCP服务器发送地址：“DHCP ack” 报文</li>
<li>在未获取DHCP之前，使用32位全0的本主机的特殊地址，不知道DHCP server的目标地址，目标地址使用32位全1的广播地址</li>
</ul>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210821171109539.png" alt="image-20210821171109539"></p>
</li>
<li><p>DHCP是驻留在UDP之上的DHCP的服务</p>
</li>
</ul>
<p>ICANN: Internet Corporation for Assigned  Names and Numbers，一个ISP获得地址块的方式</p>
<ul>
<li>分配地址</li>
<li>管理DNS</li>
<li>分配域名，解决冲突</li>
</ul>
<p>层次编址：路由聚集（route aggregation）</p>
<h3 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a>网络地址转换</h3><ul>
<li>NAT：Network Address Translation</li>
</ul>
<p>动机：本地网络只有一个有效IP地址</p>
<ul>
<li>不需要从ISP分配一块地址，可用一个IP地址用于所有的（局域网）设备，因此省钱</li>
<li>可以在局域网改变设备的地址情况下而无须通知外界</li>
<li>可以改变ISP（地址变化）而不需要改变内部的设备地址</li>
<li>局域网内部的设备没有明确的地址，对外是不可见的，因此安全</li>
</ul>
<p>实现NAT路由器</p>
<ol>
<li>外出数据包：替换源地址和端口号为NAT IP地址和新的端口号，目标IP和端口不变，如远端的C/S将会用NAP IP地址，新端口号作为目标地址</li>
<li>记住每个转换替换对（在NAT转换表中）如源IP，端口 vs NAP IP ，新端口</li>
<li>进入数据包：替换目标IP地址和端口号，采用存储在NAT表中的mapping表项，用（源IP，端口）</li>
</ol>
<p>NAT 穿越问题：外网无法连接到内网设备</p>
<p>解决方法：</p>
<ol>
<li><p>静态配置NAT：转发进来的对服务器特定端口连接请求</p>
</li>
<li><p>Universal Plug and Play  (UPnP) Internet Gateway  Device (IGD) 协议. 允许 NATted主机</p>
<ul>
<li><p>获知网络的公共IP地址</p>
</li>
<li><p>列举存在的端口映射</p>
</li>
<li><p>增/删端口映射（在租用时间内）</p>
<blockquote>
<p>自动化静态NAT端口映射配置</p>
</blockquote>
</li>
</ul>
</li>
<li><p>中继（used in Skype）</p>
<ul>
<li>NAT后面的服务器建立和中继的连接</li>
<li>外部的客户端链接到中继</li>
<li>中继在2个连接之间桥接</li>
</ul>
</li>
</ol>
<h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>动机：</p>
<ul>
<li>扩展地址空间</li>
<li>头部格式改变帮助加速处理和转发<ul>
<li>TTL-1</li>
<li>头部checksum</li>
<li>分片</li>
</ul>
</li>
<li>头部格式改变帮助QoS </li>
</ul>
<h4 id="IPv6数据报格式"><a href="#IPv6数据报格式" class="headerlink" title="IPv6数据报格式"></a>IPv6数据报格式</h4><ul>
<li>固定的40 字节头部</li>
<li>数据报传输过程中，不允许分片</li>
</ul>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/IPv6%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.png" alt="IPv6数据报格式"></p>
<ul>
<li>版本（Version）：IP版本号，6bits</li>
<li>流量类型（Priority）：同IPv4的TOS</li>
<li>流标签（Flow Label）：标示流中数据报的优先级，20bits</li>
<li>有效载荷长度（Payload Length）：16bits，给出IPv6数据报中跟在定长的40字节首部后的字节数量</li>
<li>下一个首部（Next header）：标示上层协议</li>
<li>跳限制（Hop Limit）：转发数据报的每台路由器该字段减1，到0丢弃该数据报</li>
</ul>
<p>和IPv4的其它变化</p>
<ul>
<li>Checksum：被移除掉，降低在每一段中的处理速度</li>
<li>Options：允许，但是在头部之外, 被 “Next  Header” 字段标示</li>
<li>ICMPv6：ICMP的新版本<ul>
<li>附加了报文类型, 如“Packet Too Big”</li>
<li>多播组管理功能</li>
</ul>
</li>
</ul>
<h4 id="IPv4到IPv6的平移"><a href="#IPv4到IPv6的平移" class="headerlink" title="IPv4到IPv6的平移"></a>IPv4到IPv6的平移</h4><p>隧道（Tunneling）：在IPv4路由器之间传输的IPv4数据报中携带IPv6数据报</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210823171438113.png" alt="image-20210823171438113"></p>
<h2 id="通用转发和SDN"><a href="#通用转发和SDN" class="headerlink" title="通用转发和SDN"></a>通用转发和SDN</h2><p>传统方式：</p>
<ul>
<li>每个路由器上都有实现路由算法元件（它们之间需要相互交互）</li>
<li>每台路由器上既实现控制功能、又实现数据平面</li>
<li>控制功能分布式实现</li>
<li>路由表：控制平面算出路由表，IP协议按路由表实现分组转发</li>
</ul>
<p>传统方式实现网络功能的问题</p>
<ul>
<li><p>垂直集成导致昂贵的成本、不便于创新的生态</p>
<blockquote>
<p>垂直集成：每台路由器或其他网络设备，包括</p>
<ul>
<li>硬件和私有的操作系统</li>
<li>互联网标准协议（IP, RIP, IS-IS, OSPF, BGP）的私有实现</li>
<li>从上到下都由一个厂商提供（代价大、被设备上“绑架“）</li>
</ul>
</blockquote>
</li>
<li><p>分布式、固化设备功能导致网络设备种类繁多</p>
<ul>
<li>无法改变路由等工作逻辑，无法实现流量工程等高级特性</li>
<li>配置错误影响全网运行；升级和维护会涉及到全网设备，进而造成管理困难</li>
<li>要增加新的网络功能，需要设计、实现以及部署新的特定设备，由于设备种类繁多不便于实现</li>
</ul>
</li>
</ul>
<p>SDN：逻辑上集中的控制平面</p>
<p>主要思路：</p>
<ul>
<li>网络设备数据平面和控制平面分离</li>
<li>数据平面—分组交换机<ul>
<li>将路由器、交换机和目前大多数网络设备的功能进一步抽象成：按照流表（由控制平面设置的控制逻辑）进行PDU（帧、分组）的动作（包括转发、丢弃、拷贝、泛洪、阻塞）</li>
<li>统一化设备功能：SDN交换机（分组交换机），执行控制逻辑</li>
</ul>
</li>
<li>控制平面—控制器+网络应用<ul>
<li>分离、集中</li>
<li>计算和下发控制逻辑：流表</li>
</ul>
</li>
</ul>
<p>SDN控制平面和数据平面分离的优势</p>
<ul>
<li>水平集成控制平面的开放实现（而非私有实现），创造出好的产业生态，促进发展<ul>
<li>分组交换机、控制器和各种控制逻辑网络应用app可由不同厂商生产，专业化，引入竞争形成良好生态</li>
</ul>
</li>
<li>集中式实现控制逻辑，网络管理容易<ul>
<li>集中式控制器了解网络状况，编程简单，传统方式困难</li>
<li>避免路由器的误配置</li>
</ul>
</li>
<li>基于流表的匹配+行动的工作方式允许“可编程的”分组交换机<ul>
<li>实现流量工程等高级特性</li>
<li>在此框架下实现各种新型（未来）的网络设备</li>
</ul>
</li>
</ul>
<p>SDN架构</p>
<ol>
<li><p>数据平面交换机</p>
<ul>
<li>快速，简单，商业化交换设备采用硬件实现通用转发功能</li>
<li>流表被控制器计算和安装</li>
<li>基于南向API（例如OpenFlow ），SDN控制器访问基于流的交换机</li>
<li>定义了和控制器的协议</li>
</ul>
</li>
<li><p>SDN控制器（网络OS）</p>
<ul>
<li>维护网络状态信息</li>
<li>通过上面的北向API和网络控制应用交互</li>
<li>通过下面的南向API和网络交换机交互</li>
<li>逻辑上集中，但是在实现上通常由于性能、可扩展性、 容错性以及鲁棒性采用分布式方法</li>
</ul>
</li>
<li><p>网络控制应用</p>
<ul>
<li>控制的大脑： 采用下层提供的服务（SDN控制器提供的API)，实现网络功能<ul>
<li>路由器交换机</li>
<li>接入控制防火墙</li>
<li>负载均衡</li>
<li>其他功能</li>
</ul>
</li>
<li>非绑定：可以被第三方提供，与控制器厂商以通常上不同，与分组交换机厂商也可以不同</li>
</ul>
</li>
</ol>
<p>OpenFlow 数据平面抽象</p>
<ul>
<li>流：由分组（帧）头部字段所定义</li>
<li>通用转发：简单的分组处理规则<ul>
<li>模式：将分组头部字段和流表进行匹配</li>
<li>行动：对于匹配上的分组，可以是丢弃、转发、修改、 将匹配的分组发送给控制器</li>
<li>优先权：几个模式匹配了，优先采用哪个</li>
<li>计数器Counters:：#bytes 以及 #packet</li>
</ul>
</li>
<li>路由器中的流表定义了路由器的匹配和行动规则</li>
</ul>
<p>OpenFlow 抽象：match+action统一化各种网络设备提供的功能</p>
<ul>
<li>路由器<ul>
<li>match：最长前缀匹配</li>
<li>action：通过一条链路转发</li>
</ul>
</li>
<li>交换机<ul>
<li>match：目标MAC地址</li>
<li>action：转发或者泛洪</li>
</ul>
</li>
<li>防火墙<ul>
<li>match：IP地址和 TCP/UDP端口号</li>
<li>action：允许或者禁止</li>
</ul>
</li>
<li>NAT<ul>
<li>match：IP地址和端口号</li>
<li>action：重写地址和端口号</li>
</ul>
</li>
<li>目前几乎所有的网络设备都可以在这个<strong>匹配+行动模式</strong>框架进行描述，具体化为各种网络设备包括未来的网络设备</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>大学课程</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络和因特网</title>
    <url>/2021/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/</url>
    <content><![CDATA[<h2 id="什么是因特网？"><a href="#什么是因特网？" class="headerlink" title="什么是因特网？"></a>什么是因特网？</h2><ul>
<li><p>边（通信链路）：</p>
<ul>
<li>接入网链路：主机连接到互联网的链路</li>
<li>主干链路：路由器间的链路</li>
</ul>
</li>
<li><p>节点：</p>
<ul>
<li>主机及其上运行的应用程序</li>
<li>路由器、交换机等网络交换设备</li>
</ul>
</li>
<li><p>协议：</p>
<ul>
<li>控制信息的接受和发送</li>
</ul>
</li>
</ul>
<span id="more"></span>

<p>互联网是“网络的网络“，由网络通过网络互联设备连接的网络</p>
<h3 id="具体构成描述"><a href="#具体构成描述" class="headerlink" title="具体构成描述"></a>具体构成描述</h3><ul>
<li><p>数以亿计的、互联的计算设备：</p>
<ul>
<li>主机（端系统）</li>
<li>运行网络应用程序</li>
</ul>
</li>
<li><p>通信链路：</p>
<ul>
<li>光纤、同轴电缆、无限电、卫星</li>
<li>传输速率 = 带宽（bps）</li>
</ul>
</li>
<li><p>分组交换设备（转发分组）</p>
<blockquote>
<p>分组（packets）：端系统发送数据到另一端系统时形成的数据包</p>
</blockquote>
<ul>
<li>路由器</li>
<li>链路层交换机</li>
</ul>
</li>
<li><p>因特网</p>
<ul>
<li><p>松散的层次结构、互联的ISP</p>
<blockquote>
<p>ISP（Internet Service Provider，因特网服务提供商）</p>
</blockquote>
</li>
</ul>
</li>
<li><p>协议</p>
<ul>
<li><p>控制信息的接受和发送</p>
</li>
<li><p>TCP、IP、HTTP、FTP、PPP</p>
<blockquote>
<p>协议（protocol）定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送或接收一条报文或其他事件所采取的动作</p>
<p>Internet中所有的通信行为都受到协议制约</p>
</blockquote>
</li>
</ul>
</li>
<li><p>Internet标准</p>
<ul>
<li>IETF（Internet Engineering Task Force，因特网工程任务组）研发</li>
<li>RFC（Request For Comment，请求评论），IETF的标准文档</li>
</ul>
</li>
</ul>
<h3 id="服务描述"><a href="#服务描述" class="headerlink" title="服务描述"></a>服务描述</h3><ul>
<li>使用通信设施进行通信的分布式应用</li>
<li>通信基础设施为应用程序提供编程接口（通信服务）（socket interface，套接字接口）<ul>
<li>将发送和接收数据的应用程序与互联网连接起来</li>
<li>通信服务的方式<ol>
<li>无连接不可靠服务（UDP提供）</li>
<li>面向连接的可靠服务（TCP提供）</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><ul>
<li>网络边缘<ul>
<li>主机</li>
<li>应用程序（客户端和服务器）</li>
</ul>
</li>
<li>网络核心<ul>
<li>互连的路由器</li>
<li>网络的网络</li>
</ul>
</li>
<li>接入网、物理媒体<ul>
<li>有线或无线通信链路</li>
</ul>
</li>
</ul>
<h3 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h3><ul>
<li><p>端系统（主机）</p>
<ul>
<li>运行应用程序</li>
<li>如Web、email</li>
<li>在 “网络的边缘” </li>
</ul>
</li>
<li><p>客户/服务器模式（C/S模式）</p>
<ul>
<li>客户端向服务器请求、接收服务</li>
<li>如Web浏览器/服务器；email 客户端/服务器</li>
</ul>
</li>
<li><p>对等（peer-peer，P2P ）模式</p>
<ul>
<li>很少（甚至没有）专门的服务器</li>
<li>如 Gnutella、KaZaA、Emule</li>
</ul>
</li>
</ul>
<h4 id="采用网络设施的面向连接服务"><a href="#采用网络设施的面向连接服务" class="headerlink" title="采用网络设施的面向连接服务"></a>采用网络设施的面向连接服务</h4><p>目标：在端系统之间传输数据，应用进程通信前需要握手</p>
<blockquote>
<p>握手：在数据传输之前做好准备</p>
<ul>
<li>两个通信主机之间为连接建立状态</li>
</ul>
<p>TCP – 传输控制协议（ Transmission Control  Protocol ）[RFC 793]</p>
<ul>
<li>面向连接</li>
<li>可靠地、按顺序地传送数据：确认和重传</li>
<li>流量控制：发送方不会淹没接收方，发送方的速度会依据接收方调整</li>
<li>拥塞控制：当网络拥塞时，发送方降低发送速率</li>
</ul>
<p>使用TCP的应用</p>
<ul>
<li>HTTP (Web)</li>
<li>FTP (文件传 送)</li>
<li>Telnet (远程登录)</li>
<li>SMTP (email) </li>
</ul>
</blockquote>
<p>[^有连接和面向连接的区别：连接状态的维持仅由端系统维持的是面向连接；路径上的节点都知道连接协议，并维持它，为有连接]: </p>
<h4 id="采用基础设施的无连接服务"><a href="#采用基础设施的无连接服务" class="headerlink" title="采用基础设施的无连接服务"></a>采用基础设施的无连接服务</h4><p>目标：在端系统之间传输数据，使用无连接服务</p>
<blockquote>
<p>UDP – 用户数据报协议（User Datagram  Protocol） [RFC 768]</p>
<ul>
<li>无连接</li>
<li>不可靠数据传输</li>
<li>无流量控制</li>
<li>无拥塞控制</li>
</ul>
<p>使用 UDP的应用</p>
<ul>
<li>流媒体</li>
<li>远程会议</li>
<li>DNS</li>
<li>Internet电话</li>
</ul>
</blockquote>
<h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><p>网络核心：路由器的网状网络</p>
<p>网络传输方式</p>
<ol>
<li> 电路交换（circuit switching）：为每个呼叫预留一条专有电路：如电话网 </li>
<li>分组交换（pocket switching）<ul>
<li>将要传送的数据（报文）分成一个个单位： 分组</li>
<li>将分组从一个路由器传到相邻路由器（hop），一段段最终从源端传到目标端</li>
<li>每段：采用链路的最大传输能力（ 带宽）</li>
</ul>
</li>
</ol>
<h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><p>端到端的资源被分配给从源端到目标端的呼叫 “call”</p>
<ul>
<li>独享资源：不共享，每个呼叫一旦建立起来就能够保证性能</li>
<li>如果呼叫没有数据发送，被分配的资源就会被浪费（no sharing）</li>
<li>通常被传统电话网络采用</li>
</ul>
<p>为呼叫预留端-端资源</p>
<ul>
<li>预留链路带宽、交换能力</li>
<li>专用资源：不共享</li>
<li>保证性能</li>
<li>要求建立呼叫连接</li>
</ul>
<p><strong>电路交换的复用</strong></p>
<p>网络资源（如带宽）被分成片（piece）</p>
<ul>
<li>为呼叫分配片</li>
<li>如果某个呼叫没有数据， 则其资源片处于空闲状态（不共享）</li>
</ul>
<p>复用方式</p>
<ul>
<li><p>频分（Frequency-division multiplexing，FDM）：将带宽可用通信范围进行划分</p>
</li>
<li><p>时分（Time-division  multiplexing，TDM）：将带宽划为T，一个大T划为若干个时隙（slat）</p>
</li>
<li><p>波分（Wave-division  multiplexing，WDM）：光纤通信，将光波段划分为小波段</p>
<p><br><img src="/2021/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/image-20210717161824910.png" alt="image-20210717161824910"></p>
</li>
</ul>
<p>电路交换不适合计算机之间的通信的原因</p>
<ol>
<li>连接建立时间长</li>
<li>计算机之间的通信有突发性，如果使用线路交换，则浪费的片较多，因为即使这个呼叫没有数据传递，其所占据的片也不能够被别的呼叫使用</li>
<li>可靠性不高</li>
</ol>
<h4 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h4><p>在源和目的端之间，每个分组通过通信链路和分组交换机（路由器和链路层交换机）传送</p>
<p>以分组为单位存储-转发方式</p>
<ul>
<li>网络带宽资源不再分为一个个片，传输时使用全部带宽</li>
<li>主机之间传输的数据被分为一个个分组 </li>
</ul>
<p>资源共享，按需使用</p>
<ul>
<li><p>存储-转发：分组每次移动一跳（ hop ）</p>
<ul>
<li><p>在转发之前，节点必须收到整个分组</p>
</li>
<li><p>延迟比线路交换要大（接收到整个分组后再进行转发）</p>
</li>
<li><p>排队时间</p>
<blockquote>
<p>排队和延迟：如果到达速率&gt;链路的输出速率</p>
<ul>
<li>分组将会排队，等待传输</li>
<li>如果路由器的缓存用完了，分组将会被抛弃，即丢包</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>转发表和路由选择协议</p>
<ul>
<li><p>转发: 将分组从路由器的输入链路转移到输出链路</p>
<blockquote>
<p>转发表（forwarding table）：用于将目的地址映射成为输出链路</p>
</blockquote>
</li>
<li><p>路由: 决定分组采用的源到目标的路径（由路由算法决定）</p>
<blockquote>
<p>路由选择协议（routing protocol）：用于自动地设置转发表</p>
</blockquote>
</li>
</ul>
<p>分组交换采用的复用方式：统计多路复用（特殊的TDM），划分时间片的方式是不固定的</p>
<h4 id="分组交换VS电路交换"><a href="#分组交换VS电路交换" class="headerlink" title="分组交换VS电路交换"></a>分组交换VS电路交换</h4><p>同样的网络资源，分组交换允许更多用户使用网络</p>
<p>分组交换</p>
<ol>
<li>适合于对突发式数据传输<ul>
<li>资源共享</li>
<li>简单，不必建立呼叫</li>
</ul>
</li>
<li>过度使用会造成网络拥塞：分组延时和丢失<ul>
<li>对可靠的数据传输需要协议来约束：拥塞控制</li>
</ul>
</li>
</ol>
<h4 id="分组交换网络：存储-转发"><a href="#分组交换网络：存储-转发" class="headerlink" title="分组交换网络：存储-转发"></a>分组交换网络：存储-转发</h4><p>分组交换: 分组的存储转发一段一段从源端传到目标端 ，按照有无网络层的连接，分成：</p>
<ol>
<li><p>数据报网络</p>
<ul>
<li><p>分组的目标地址决定下一跳</p>
</li>
<li><p>在不同的阶段，路由可以改变</p>
</li>
<li><p>类似：问路</p>
</li>
<li><p>Internet</p>
<blockquote>
<p>数据报(datagram) 的工作原理</p>
<ul>
<li>在通信之前,无须建立起一个连接,有数据就传输</li>
<li>每一个分组都独立路由（路径不一样,可能会失序）</li>
<li>路由器根据分组的目标地址进行路由</li>
<li>每个分组携带完整的目标地址，无网络层连接，路由器间不维护通信状态</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>虚电路网络</p>
<ul>
<li>每个分组都带标签（虚电路标识 VC ID），标签决定下一跳</li>
<li>在呼叫建立时决定路径，在整个呼叫中路径保持不变</li>
<li>路由器维持每个呼叫的状态信息</li>
<li>X.25 和ATM</li>
</ul>
</li>
</ol>
<h3 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h3><ul>
<li>住宅接入网络</li>
<li>单位接入网络 （学校、公 司）</li>
<li>无线接入网络</li>
</ul>
<h4 id="住宅接入"><a href="#住宅接入" class="headerlink" title="住宅接入"></a>住宅接入</h4><h5 id="modem（调制解调器）"><a href="#modem（调制解调器）" class="headerlink" title="modem（调制解调器）"></a>modem（调制解调器）</h5><ul>
<li>将上网数据调制加载音频信号上， 在电话线上传输，在局端将其中的数据解调出来<ul>
<li>调频</li>
<li>调幅</li>
<li>调相位</li>
<li>综合调制</li>
</ul>
</li>
<li>拨号调制解调器<ul>
<li>56Kbps 的速率直接接入路由器（通常更低）</li>
<li>不能同时上网和打电话：不能总是在线</li>
</ul>
</li>
</ul>
<h5 id="DSL（digital-subscriber-line，数据用户线）"><a href="#DSL（digital-subscriber-line，数据用户线）" class="headerlink" title="DSL（digital subscriber line，数据用户线）"></a>DSL（digital subscriber line，数据用户线）</h5><ul>
<li>采用现存的到交换局DSLAM的电话线<ul>
<li>DSL线路上的数据被传到互联网</li>
<li>DSL线路上的语音被传到电话网</li>
</ul>
</li>
<li>&lt; 2.5Mbps上行传输速率（通常 &lt; 1Mbps）</li>
<li>&lt; 24Mbps下行传输速率（通常 &lt; 10Mbps）</li>
<li>ADSL，非对称传输</li>
</ul>
<h5 id="线缆网络"><a href="#线缆网络" class="headerlink" title="线缆网络"></a>线缆网络</h5><p>有线电视信号线缆双向改造</p>
<p>FDM：在不同频段传输不同信道的数据， 数字电视和上网数据（上下行，上行带宽共享）</p>
<p>HFC（hybrid fiber coax，混合光纤同轴）</p>
<ul>
<li>非对称：最高30Mbps的下行传输速率，2Mbps 上行传输速率</li>
</ul>
<p>线缆和光纤网络将个家庭用户接入到 ISP 路由器</p>
<p>各用户共享到线缆头端的接入网络</p>
<ul>
<li>与DSL不同，DSL每个用户一个专用线路到CO（central  office）</li>
</ul>
<h5 id="FTTH（Fiber-to-the-home，光纤到户）"><a href="#FTTH（Fiber-to-the-home，光纤到户）" class="headerlink" title="FTTH（Fiber to the home，光纤到户）"></a>FTTH（Fiber to the home，光纤到户）</h5><p>从CO（本地中心局）直接到家庭提供一条光纤路径</p>
<h4 id="企业接入"><a href="#企业接入" class="headerlink" title="企业接入"></a>企业接入</h4><ul>
<li>经常被企业或者大学等机构采用</li>
<li>10Mbps，100Mbps，1Gbps，10Gbps传输率</li>
<li>现在，端系统经常直接接到以太网络交换机上</li>
</ul>
<h4 id="无线接入"><a href="#无线接入" class="headerlink" title="无线接入"></a>无线接入</h4><p>各无线端系统共享无线接入网络端系统到无线路由器（通过基站或者接入点）</p>
<ul>
<li>无线LAN<ul>
<li>建筑物内部</li>
<li>802.11b/g（WiFi）: 11，54Mbps 传输速率</li>
</ul>
</li>
<li>广域无线接入<ul>
<li>由电信运营商提供 (cellular) , 10’s km</li>
<li>1 到 10Mbps</li>
<li>3G和4G：LTE</li>
</ul>
</li>
</ul>
<h3 id="物理媒体"><a href="#物理媒体" class="headerlink" title="物理媒体"></a>物理媒体</h3><p>Bit（比特）：在发送-接收对间传播</p>
<p>物理链路：连接每个发送-接收对之间的物理媒体</p>
<ul>
<li>导引型媒体：有形介质，电波沿着固体媒体前行，如光缆、双绞铜线或同轴电缆。电波传的更远</li>
<li>非导引型媒体：电波在空气或外层空间中传播，如无线局域网或数字卫星频道中</li>
</ul>
<h4 id="双绞线（TP）"><a href="#双绞线（TP）" class="headerlink" title="双绞线（TP）"></a>双绞线（TP）</h4><ul>
<li>两根绝缘铜导线拧合</li>
<li>5类：100Mbps 以太网，Gbps 千兆位以太网</li>
<li>6类：10Gbps万兆以太网</li>
<li>无屏蔽双绞线（Unshielded Twisted Pair ，UTP）</li>
</ul>
<h4 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h4><ul>
<li>两根同轴的铜导线</li>
<li>双向</li>
<li>基带电缆<ul>
<li>电缆上一个单个信道</li>
<li>Ethernet</li>
</ul>
</li>
<li>宽带电缆<ul>
<li>电缆上有多个信道</li>
<li>HFC</li>
</ul>
</li>
</ul>
<h4 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h4><ul>
<li>光脉冲，每个脉冲表示一个 bit，在玻璃纤维中传输</li>
<li>高速：点到点的高速传输（如10Gps-100Gbps传输速率 ）</li>
<li>低误码率：在两个中继器之间可以有很长的距离，不受电磁噪声的干扰</li>
<li>安全</li>
</ul>
<h4 id="无线链路"><a href="#无线链路" class="headerlink" title="无线链路"></a>无线链路</h4><ul>
<li>开放空间传输电磁波，携带要传输的数据</li>
<li>无需物理”线缆”</li>
<li>双向</li>
<li>强度与距离的平方成反比</li>
<li>传播环境效应<ul>
<li>反射</li>
<li>吸收</li>
<li>干扰</li>
</ul>
</li>
</ul>
<p><strong>无线链路类型</strong></p>
<ul>
<li>地面微波<ul>
<li>e.g  up to 45Mbps channels</li>
</ul>
</li>
<li>LAN （e.g，WiFi）<ul>
<li>11Mbps, 54Mbps,540Mbps… </li>
</ul>
</li>
<li>wide-area (e.g.，蜂窝)<ul>
<li>3G cellular：数Mbps </li>
<li>4G 10Mbps</li>
<li>5G 数Gbps</li>
</ul>
</li>
<li>卫星<ul>
<li>每个信道Kbps 到45Mbps（或者多个聚集信道）</li>
<li>270ms 端到端延迟</li>
<li>同步静止卫星和低轨卫星（LEO）</li>
</ul>
</li>
</ul>
<h2 id="Internet结构和ISP"><a href="#Internet结构和ISP" class="headerlink" title="Internet结构和ISP"></a>Internet结构和ISP</h2><ul>
<li>端系统通过接入ISPs (Internet Service Providers)连接到互联网——住宅，公司和大学的ISPs</li>
<li>接入ISPs相应的必须是互联的<ul>
<li>因此任何2个端系统可相互发送分组到对方</li>
</ul>
</li>
<li>导致的“网络的网络”非常复杂<ul>
<li>发展和演化是通过经济的和国家的政策来驱动的</li>
</ul>
</li>
</ul>
<ol>
<li><p>若存在多个接入ISP（用户），将每两个ISPs直接相连，则不可扩展，需要$O（N^2）$连接</p>
</li>
<li><p>所以将每个接入ISP都连接到全局ISP（全局范围内覆盖），客户ISPs和提供者ISPs有经济合约</p>
<blockquote>
<p>竞争：但如果全局ISP是有利可为的业务，那会有竞争者 </p>
<p>合作：通过ISP之间的合作可以完成业务的扩展，肯定会有互联，对等互联的结算关系</p>
</blockquote>
</li>
<li><p>然后业务细分（全球接入和区域接入），区域网络将出现，用与将接入ISPs连接到全局ISPs</p>
</li>
<li><p>内容提供商网络（Internet Content Providers,ICP）可能会构建它们自己的网络，将它们的服务、内容更加靠近端用户，向用户提供更好的服务,减少自己的运营支出</p>
<blockquote>
<p>很多内容提供商(如：Google, Akamai )可能会部署自己的网络，在全球范围内建立数据中心机房（DC），自己铺设电缆或租用运营商电缆，DC之间由专用线缆连接，连接自己的在各地的DC，走自己的数据</p>
<p>连接若干local ISP和各级（包括一层）ISP，更加靠近用户</p>
</blockquote>
</li>
</ol>
<p><img src="/2021/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/image-20210720194639958.png" alt="image-20210720194639958"></p>
<p>在网络的最中心，一些为数不多的充分连接的大范围网络（分布广、节点有限、 但是之间有着多重连接）</p>
<ul>
<li>“tier-1” commercial ISPs (如 Level 3, Sprint, AT&amp;T, NTT)，国家或者国际范围的覆盖</li>
<li>content provider network (如Google): 将它们的数据中心接入ISP，方便周边用户的访问；通常私有网络之间用专网绕过第一层ISP和区域ISP</li>
</ul>
<p><strong>网络的网络</strong></p>
<ul>
<li><p>松散的层次模型</p>
</li>
<li><p>一个分组要经过许多网络</p>
</li>
<li><p>中心：第一层ISP（如UUNet, BBN/Genuity, Sprint,  AT&amp;T）国家/国际覆盖，速率极高</p>
<ul>
<li>直接与其他第一层ISP相连</li>
<li>与大量的第二层ISP和其他客户网络相连</li>
</ul>
</li>
<li><p>第二层ISP：更小些的 (通常是区域性的) ISP</p>
<ul>
<li>与一个或多个第一层ISPs，也可能与其他第二层ISP</li>
</ul>
</li>
<li><p>第三层ISP与其他本地ISP</p>
<ul>
<li>接入网 (与端系统最近)</li>
</ul>
</li>
</ul>
<p><strong>ISP之间的连接</strong></p>
<ul>
<li><p>POP：高层ISP面向客户网络的接入点，涉及费用结算</p>
<ul>
<li><p>如一个低层ISP接入多个高层ISP，多宿（multi home）</p>
<blockquote>
<p>多宿：与两个或多个提供商ISP连接</p>
</blockquote>
</li>
</ul>
</li>
<li><p>对等接入：2个ISP对等互接，不涉及费用结算</p>
</li>
<li><p>IXP（因特网交换点）：多个对等ISP互联互通之处，通常不涉及费用结算</p>
<ul>
<li>对等接入</li>
</ul>
</li>
<li><p>ICP自己部署专用网络，同时和各级ISP连接</p>
</li>
</ul>
<h2 id="分组延时、丢包和吞吐量"><a href="#分组延时、丢包和吞吐量" class="headerlink" title="分组延时、丢包和吞吐量"></a>分组延时、丢包和吞吐量</h2><p>分组延时类型</p>
<ol>
<li>节点处理延时<ul>
<li>检查 bit级差错</li>
<li>检查分组首部和决定将分组导向何处</li>
</ul>
</li>
<li>排队延时<ul>
<li>在输出链路上等待传输的时间</li>
<li>依赖于路由器的拥塞程度</li>
</ul>
</li>
<li>传输延时<ul>
<li>R = 链路带宽(bps)</li>
<li>L = 分组长度(bits)</li>
<li>将分组发送到链路上的时间 = L/R</li>
<li>存储转发延时</li>
<li>传输延时越短信道容量越小</li>
</ul>
</li>
<li>传播延时<ul>
<li>d = 物理链路的长度</li>
<li>s = 在媒体上的传播速度 (通常为3x$10^8$ m/sec或2x$10^8$ m/sec)</li>
<li>传播延时 = d/s</li>
</ul>
</li>
</ol>
<p>节点总延时：$d_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}$</p>
<ul>
<li><p>$d_{proc}=$   处理延时，通常试微妙数量级或更少</p>
</li>
<li><p>$d_{queue}= $  排队延时，取决于拥塞程度</p>
</li>
<li><p>$d_{trans}= $  传输延时，= L/R，对低速率的链路而言很大（如拨号），通常为微秒级到毫秒级</p>
</li>
<li><p>$d_{prop}= $  传播延时，通常为几微秒到几百毫秒</p>
</li>
</ul>
<p>排队延时</p>
<ul>
<li>R = 链路带宽（bps)）</li>
<li>L = 分组长度（bits）</li>
<li>a = 分组到达队列的平均速率</li>
<li>流量强度 = La/R<ul>
<li>La/R ~ 0: 平均排队延时很小</li>
<li>La/R -&gt; 1: 延时变得很大</li>
<li>La/R &gt; 1: 比特到达队列的速率超过了从该队列输出的速率，平均排队延时将趋向无穷大</li>
</ul>
</li>
</ul>
<p><img src="/2021/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/image-20210721083115069.png" alt="image-20210721083115069"></p>
<p><strong>设计系统时流量强度不能大于1</strong></p>
<p>分组丢失（丢包）</p>
<ul>
<li>链路的队列缓冲区容量有限</li>
<li>当分组到达一个满的队列时，该分组将会丢失</li>
<li>丢失的分组可能会被前一个节点或源端系统重传，或根本不重传</li>
</ul>
<p>吞吐量: 在源端和目标端之间传输的速率（数据量/单位时间）</p>
<ul>
<li>瞬间吞吐量：在一个时间点的速率</li>
<li>平均吞吐量：在一个长时间内平均值</li>
</ul>
<p>瓶颈链路：端到端路径上，限制端到端吞吐的链路</p>
<p>具有N条链路的网络，传输速率分别是$R_1,R_2,……,R_N$，吞吐量为min{$R_1,R_2,……,R_N$}</p>
<p>在实际场景中，要考虑到多个分组平均使用链路的情况</p>
<h2 id="协议层次及服务模型"><a href="#协议层次及服务模型" class="headerlink" title="协议层次及服务模型"></a>协议层次及服务模型</h2><p>层次化方式实现复杂网络功能</p>
<ul>
<li>将网络复杂的功能分层功能明确的层次，每一层实现了其中一个或一组功能，功能中有其上层可以使用的功能：服务</li>
<li>本层协议实体相互交互执行本层的协议动作，目的是实现本层功能，通过接口为上层提供更好的服务</li>
<li>在实现本层协议的时候，直接利用了下层所提供的服务</li>
<li>本层的服务：借助下层服务实现的本层协议实体之间交互带来的新功能（上层可以利用的）+  更下层所提供的服务</li>
</ul>
<h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p>服务（Service）：低层实体向上层实体提供它们之间的通信的能力</p>
<ul>
<li>服务用户(service user)</li>
<li>服务提供者(service provider ) </li>
</ul>
<p>原语(primitive)：上层使用下层服务的形式，高层使用低层提供的服务，以及低层向高层提供服务都是通过服务访问原语（如Socket API 的函数）来进行交互的，即提供服务的形式</p>
<p>服务访问点 (Services Access Point，SAP) ：上层使用下层提供的服务通过层间的接口，用于区分不同的服务用户</p>
<ul>
<li>地址(address)：下层的一个实体支撑着上层的多个实体， SAP有标志不同上层实体的作用</li>
<li>可以有不同的实现，队列</li>
<li>如传输层的SAP：端口(port)</li>
</ul>
<h3 id="服务类型"><a href="#服务类型" class="headerlink" title="服务类型"></a>服务类型</h3><ul>
<li>面向连接的服务（Connection-oriented Service）<ul>
<li>连接(Connection)：两个通信实体为进行通信而建立的一 种结合</li>
<li>面向连接的服务通信的过程：建立连接，通信，拆除连接</li>
<li>面向连接的服务的例子：网络层的连接被成为虚电路</li>
<li>适用范围：对于大的数据块要传输; 不适合小的零星报文</li>
<li>特点：保序</li>
<li>服务类型<ul>
<li>可靠的信息流：传送页面（可靠的获得，通过接收方的确认）</li>
<li>可靠的字节流：远程登录</li>
<li>不可靠的连接：数字化声音</li>
</ul>
</li>
</ul>
</li>
<li>无连接的服务（Connectionless Service）<ul>
<li>无连接服务：两个对等层实体在通信前不需要建立一个连接，不预留资源；不需要通信双方都是活跃（例：寄信）</li>
<li>特点：不可靠、可能重复、可能失序</li>
<li>IP分组，数据包</li>
<li>适用范围：适合传送零星数据</li>
<li>服务类型<ul>
<li>不可靠的数据报：电子方式的函件</li>
<li>有确认的数据报：挂号信</li>
<li>请求回答：信息查询</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="服务和协议"><a href="#服务和协议" class="headerlink" title="服务和协议"></a>服务和协议</h3><ul>
<li>服务与协议的区别<ul>
<li>服务(Service)：低层实体向上层实体提供它们之间的通信的能力，是通过原语(primitive)来操作的，垂直关系</li>
<li>协议(protocol) ：对等层实体(peer entity)之间在相互通信的过程中，需要遵循的规则的集合，水平关系</li>
</ul>
</li>
<li>服务与协议的联系<ul>
<li>本层协议的实现要靠下层提供的服务来实现</li>
<li>本层实体通过协议为上层提供更高级的服务</li>
</ul>
</li>
</ul>
<h3 id="数据单元（DU）"><a href="#数据单元（DU）" class="headerlink" title="数据单元（DU）"></a>数据单元（DU）</h3><p>各层次的协议数据单元</p>
<ul>
<li>应用层：报文(message)</li>
<li>传输层：报文段(segment)：TCP段，UDP数据报</li>
<li>网络层：分组packet（如果无连接方式：数据报 datagram）</li>
<li>数据链路层：帧(frame)</li>
<li>物理层：位(bit)</li>
</ul>
<p><img src="/2021/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/image-20210721092802414.png" alt="image-20210721092802414"></p>
<p><img src="/2021/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/image-20210721092815495.png" alt="image-20210721092815495"></p>
<p>分层处理和实现复杂系统的好处</p>
<p>概念化：结构清晰，便于标示网络组件，以及描述其相互关系</p>
<ul>
<li>分层参考模型</li>
</ul>
<p>结构化：模块化更易于维护和系统升级</p>
<ul>
<li>改变某一层服务的实现不影响系统中的其他层次<ul>
<li>对于其他层次而言是透明的</li>
</ul>
</li>
<li>如改变登机程序并不影响系统的其它部分</li>
</ul>
<h3 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h3><ul>
<li><p>应用层：网络应用</p>
<ul>
<li>为人类用户或者其他应用进程提供网络应用服务</li>
<li>FTP，SMTP，HTTP，DNS</li>
</ul>
</li>
<li><p>传输层：主机之间的数据传输</p>
<ul>
<li><p>传输层分组为报文段（segment）</p>
</li>
<li><p>在网络层提供的端到端通信基础上，细分为进程到进程，将不可靠的通信变成可靠地通信</p>
</li>
<li><p>TCP，UDP</p>
</li>
</ul>
</li>
<li><p>网络层：为数据报从源到目的选择路由</p>
<ul>
<li>主机主机之间的通信，端到端通信，不可靠</li>
<li>IP，路由协议</li>
</ul>
</li>
<li><p>链路层：相邻网络节点间的以帧为单位的数据传输</p>
<ul>
<li>链路层分组为帧（frame）</li>
<li>2个相邻2点的通信，点到点通信，可靠或不可靠</li>
<li>点对对协议PPP，802.11（WiFi），Ethernet</li>
</ul>
</li>
<li><p>物理层：在线路上传送bit </p>
</li>
</ul>
<p><img src="/2021/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/image-20210722141359884.png" alt="image-20210722141359884"></p>
<h3 id="OSI-模型"><a href="#OSI-模型" class="headerlink" title="OSI 模型"></a>OSI 模型</h3><ul>
<li>表示层：允许应用解释传输的数据，如加密，压缩，机器相关的表示转换</li>
<li>会话层：数据交换的同步，检查点，恢复</li>
</ul>
<p><img src="/2021/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/image-20210722141543303.png" alt="image-20210722141543303"></p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><img src="/2021/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/image-20210722142941350.png" alt="image-20210722142941350"></p>
<p>每一层，一个分组具有两种类型的字段：首部字段和有效载荷字段，有效载荷字段通常来自上一层的分组</p>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>早期（1960以前）计算机网络</p>
<ul>
<li>线路交换网络</li>
<li>线路交换的特性使得其不适合计算机之间的通信<ul>
<li>线路建立时间过长</li>
<li>独享方式占用通信资源，不适合突发性很强的计算机之间的通信</li>
<li>可靠性不高：非常不适合军事通信</li>
</ul>
</li>
</ul>
<p>1961-1972: 早期的分组交换概念</p>
<ul>
<li>三个小组独立地开展分组交换的研究<ul>
<li>1961：Kleinrock(MIT)，排队论</li>
<li>1964：Baran(美国兰德公司) – 军用网络上的分组交换</li>
<li>1964：Donald（英国）等，NPL（英国国家物理实验室）</li>
</ul>
</li>
<li>1967：Kleinrock和在MIT的同事在美国高级研究计划研究局（ARPA）考虑ARPA-net 计划（第一个分组交换计算机网络）</li>
<li>1969：第一个 ARPA-net 节点（IMP：接口报文处理机）开始工作（安装在UCLA，加州大学洛杉矶分校） </li>
<li>1969年底：建立了4个节点</li>
<li>1972：ARPAnet 公众演示<ul>
<li>网络控制协议是第一个端系统之间的主机-主机协议</li>
<li>NCP协议：相当于传输层和网络层在一起，支持应用开发</li>
<li>第一个e-mail 程序（ BBN）</li>
<li>ARPA-net有15个节点</li>
</ul>
</li>
</ul>
<p>1972-1980：专用网络和网络互联</p>
<ul>
<li>出现了很多对以后来说重要的网络形式<ul>
<li>1970：ALOHAnet,夏威夷上的微波网络</li>
<li>1973: Metcalfe在博士论文中提出了 Ethernet</li>
<li>ATM网络</li>
<li>ALOHAnet，Telenet，Cyclades法国等</li>
</ul>
</li>
<li>1970后期，网络体系结构的必要性<ul>
<li>专用的体系结构： DECnet, SNA, XNA</li>
<li>标准化的体系结构，达到网络的互通互联</li>
</ul>
</li>
<li>1974：网际互联的Cerf and Kahn 体系结构</li>
<li>1979：ARPA-net的规模在持续增加，体系结构也在酝酿着变化，以支持网络互联和 其他目的（性能）需求<ul>
<li>节点数目增加，有200个节点</li>
</ul>
</li>
</ul>
<blockquote>
<p>Cerf and Kahn 网络互联原则定义了今天的Internet体系结构</p>
<ul>
<li>极简、自治（通过IP网连接所有网络）</li>
<li>尽力而为（best  effort）服务模型（是否传到，是否有序无关）</li>
<li>无状态的路由器</li>
<li>分布控制</li>
</ul>
</blockquote>
<p>1980-1990：体系结构变化, 网络数量激增，应用丰富</p>
<ul>
<li>1983：TCP/IP部署，标记日<ul>
<li>NCP分化成2个层次，TCP/IP， 从而出现UDP</li>
<li>覆盖式IP解决网络互联问题</li>
<li>主机设备和网络交换设备分开</li>
</ul>
</li>
<li>1982：smtp e-mail协议定义</li>
<li>1983：DNS 定义，完成域名到IP地址的转换</li>
<li>1985：ftp 协议定义</li>
<li>1988：TCP拥塞控制</li>
<li>其他网络形式的发展<ul>
<li>新的国家级网络：Csnet，BITnet，NSFnet，Minitel</li>
<li>1985年：ISO/OSI提出， 时机不对且太繁琐</li>
</ul>
</li>
<li>100,000主机连接到网络联邦</li>
</ul>
<p>1990, 2000’s：商业化，Web，新的应用</p>
<ul>
<li><p>1990年代初：NSF为ARPA-net 的访问网，双主干网络，之后ARPA-net退役</p>
</li>
<li><p>1991：NSF放宽了对NSFnet用于商业目的的限制 (1995退役)， ASFNET非盈利性机构维护，后面叫Internet</p>
</li>
<li><p>UNIX 中TCP/IP的免费捆绑</p>
</li>
<li><p>1990年代初：Web</p>
<ul>
<li>hypertext，超文本 [Bush 1945, Nelson  1960’s]</li>
<li>HTML，HTTP：Berners-Lee</li>
<li>1994：Mosaic (Netscape， andreesen) </li>
<li>1990年代后期：Web的商业化</li>
</ul>
</li>
<li><p>1990后期 – 21世纪</p>
<ul>
<li>TCP/IP体系结构的包容性，在其上部署应用便捷，出现非常多的应用</li>
<li>新一代杀手级应用（即时讯息 ，P2P 文件共享，社交网络等 ）更进一步促进互联网的发展</li>
<li>安全问题不断出现和修订（互联网的补丁对策）</li>
<li>2001网络泡沫，使得一些好公司沉淀下来（谷歌，微软，苹 果，Yahoo，思科）</li>
<li>主干网的速率达到Gbps</li>
</ul>
</li>
</ul>
<p>2005-现在</p>
<ul>
<li>100+亿主机：包括智能手机和平板</li>
<li>宽带接入的快速部署</li>
<li>高速无线接入无处不在：移动互联时代<ul>
<li>4G部署，5G蓄势待发</li>
<li>带宽大，终端性能高，价格便宜，应用不断增多</li>
</ul>
</li>
<li>在线社交网络等新型应用的出现<ul>
<li>Facebook：10亿用户</li>
<li>微信，QQ：数十亿用户</li>
</ul>
</li>
<li>内容提供商 (Google, Microsoft)创建他们自己的网络<ul>
<li>通过自己的专用网络提供对搜索、视频内容和电子邮件的即刻访问</li>
</ul>
</li>
<li>电子商务，大学，企业在云中运行他们的服务 (e.g. Amazon EC2) </li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>大学课程</tag>
      </tags>
  </entry>
  <entry>
    <title>链路层和局域网</title>
    <url>/2021/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/</url>
    <content><![CDATA[<h2 id="链路层概述"><a href="#链路层概述" class="headerlink" title="链路层概述"></a>链路层概述</h2><p>网络节点的连接方式</p>
<ul>
<li>点到点连接</li>
<li>多点连接<ul>
<li>共享型介质（同轴电缆连接）</li>
<li>通过网络交换机</li>
</ul>
</li>
</ul>
<span id="more"></span>

<p>WAN一般采用点到点链路</p>
<ul>
<li>带宽大、距离远（延迟大） &gt;带宽延迟积大</li>
<li>如果采用多点连接方式<ul>
<li>竞争方式：一旦冲突代价大</li>
<li>令牌等协调方式：在其中协调节点的发送代价大</li>
</ul>
</li>
<li>点到点链路的链路层服务实现非常简单，即封装和解封装</li>
</ul>
<p>LAN一般采用多点连接方式</p>
<ul>
<li>连接节点非常方便</li>
<li>接到共享型介质上（或网络交换机），连接所有其他节点</li>
<li>多点连接方式网络的链路层功能实现相当复杂<ul>
<li>多点接入：协调各节点对共享性介质的访问和使用</li>
<li>竞争方式：冲突之后的协调</li>
<li>令牌方式：令牌产生，占有和释放等</li>
</ul>
</li>
</ul>
<p>术语：</p>
<ul>
<li>主机和路由器是节点（网桥和交换机也是）：nodes</li>
<li>沿着通信路径，连接个相邻节点通信信道的是链路：links<ul>
<li>有线链路</li>
<li>无线链路</li>
<li>局域网，共享性链路</li>
</ul>
</li>
<li>第二层协议数据单元帧frame ，封装数据报</li>
</ul>
<p><strong>数据链路层负责从一个节点通过链路将（帧中的）数据报发送到相邻的物理节点（一个子网内部的2节点）</strong></p>
<p>数据报（分组）在不同的链路上以不同的链路协议传送</p>
<p>不同的链路协议提供不同的服务</p>
<p><strong>链路层服务</strong></p>
<ul>
<li><p>成帧，链路接入</p>
<ul>
<li>将数据报封装在帧中，加上帧头、帧尾部</li>
<li>如果采用的是共享性介质，信道接入获得信道访问权</li>
<li>在帧头部使用“MAC”（物理）地址来标示源和目的，不同于IP地址</li>
</ul>
</li>
<li><p>可靠传输</p>
<ul>
<li>在低出错率的链路上（光纤和双绞线电缆）很少使用</li>
<li>在无线链路经常使用：出错率高</li>
</ul>
</li>
<li><p>流量控制</p>
<ul>
<li>使得相邻的发送和接收方节点的速度匹配</li>
</ul>
</li>
<li><p>错误检测</p>
<ul>
<li>差错由信号衰减和噪声引起</li>
<li>接收方检测出的错误：通知发送端进行重传或丢弃帧</li>
</ul>
</li>
<li><p>差错纠正</p>
<ul>
<li>接收端检查和纠正bit错误，不通过重传来纠正错误</li>
</ul>
</li>
<li><p>双工和全双工</p>
<ul>
<li>半双工：链路可以双向传输，但一次只有一个方向</li>
</ul>
</li>
</ul>
<p><strong>链路层在哪里实现</strong></p>
<ul>
<li>在每一个主机上<ul>
<li>每个路由器上</li>
<li>交换机的每个端口上</li>
</ul>
</li>
<li>链路层功能在“适配器”上 实现（aka network  interface card NIC）或者在一个芯片组上<ul>
<li>以太网卡，802.11 网卡 ; 以太网芯片组</li>
<li>实现链路层和相应的物 理层功能</li>
</ul>
</li>
<li>接到主机的系统总线上</li>
<li>硬件、软件和固件的综合 体</li>
</ul>
<p><strong>适配器通信</strong></p>
<ul>
<li>发送方<ul>
<li>在帧中封装数据报</li>
<li>加上差错控制编码，实现RDT和流量控制功能等</li>
</ul>
</li>
<li>接收方<ul>
<li>检查有无出错，执行 rdt和流量控制功能等</li>
<li>解封装数据报，将其交给上层</li>
</ul>
</li>
<li>适配器是半自治的实现了链路和物理层功能</li>
</ul>
<h2 id="差错检查和纠正错误"><a href="#差错检查和纠正错误" class="headerlink" title="差错检查和纠正错误"></a>差错检查和纠正错误</h2><p>检验和：CRC（循环冗余校验）</p>
<ul>
<li>强大的差错检测码</li>
<li>将数据比特 D，看成是二进制的数据</li>
<li>生成多项式G：双方协商r+1位模式（r次方）<ul>
<li>生成和检查所使用的位模式</li>
</ul>
</li>
<li>目标:选择r位 CRC附加位R，使得<ul>
<li>正好被 G整除（modulo 2）</li>
<li>接收方知道 G，将除以 G，如果非0余数：检查出错误</li>
<li>能检出所有少于r+1位的突发错误</li>
</ul>
</li>
<li>实际中广泛使用（以太网、802.1WiFi，ATM）</li>
</ul>
<p>CRC性能分析</p>
<ul>
<li>突发错误和突发长度</li>
<li>CRC检错性能描述<ul>
<li>能够检查出所有的1bit错误</li>
<li>能够检查出所有的双bits的错误</li>
<li>能够检查出所有长度 =r或者&lt;r 位的错误</li>
<li>出现长度为 r+1的突发错误，检查不出的概率是$\frac{1}{2^{r-1}}$</li>
<li>出现长度大于r+1的突发错误，检查不出的概率是$\frac{1}{2^r}$</li>
</ul>
</li>
</ul>
<p>详细见《自顶向下》P291</p>
<h2 id="多路访问链路和协议"><a href="#多路访问链路和协议" class="headerlink" title="多路访问链路和协议"></a>多路访问链路和协议</h2><p>两种类型的链路（一个子网内部链路连接形式）</p>
<ul>
<li>点对点<ul>
<li>拨号访问的PPP</li>
<li>以太网交换机和主机之间的点对点链路</li>
</ul>
</li>
<li>广播（共享线路或媒体）<ul>
<li>传统以太网</li>
<li>HFC上行链路</li>
<li>802.11无线局域网</li>
</ul>
</li>
</ul>
<h3 id="多路访问协议"><a href="#多路访问协议" class="headerlink" title="多路访问协议"></a>多路访问协议</h3><p>多路访问问题</p>
<ul>
<li>单个共享的广播型链路</li>
<li>2个或更多站点同时传送会造成冲突（collision）<ul>
<li>多个节点在同一个时刻发送，则会收到2个或多个信号叠加</li>
</ul>
</li>
</ul>
<p>多路访问协议（介质访问控制协议：MAC）</p>
<ul>
<li>分布式算法-决定节点如何使用共享信道，即：决定节点什么时候可以发送</li>
<li>关于共享控制的通信必须用借助信道本身传输<ul>
<li>没有带外的信道，各节点使用其协调信道使用</li>
<li>用于传输控制信息</li>
</ul>
</li>
</ul>
<p>理想的多路访问协议</p>
<ul>
<li>给定：Rbps的广播信道</li>
<li>必要条件<ol>
<li>当一个节点要发送时，可以R速率发送</li>
<li>当M个节点要发送，每个可以以R/M的平均速率发送</li>
<li>完全分布的<ul>
<li>没有特殊节点协调发送</li>
<li>没有时钟和时隙的同步</li>
</ul>
</li>
<li>简单</li>
</ol>
</li>
</ul>
<p><strong>MAC（媒体访问控制）协议分类</strong></p>
<ul>
<li>信道划分<ul>
<li>把信道划分成小片（时间、频率、编码）</li>
<li>分配片给每个节点专用</li>
</ul>
</li>
<li>随机访问<ul>
<li>信道不划分，允许冲突</li>
<li>冲突后恢复</li>
</ul>
</li>
<li>依次轮流 <ul>
<li>节点依次轮流</li>
<li>但是有很多数据传输的节点可以获得较长的信道使用权</li>
</ul>
</li>
</ul>
<h3 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h3><p>TDMA（time division multiple access，时分多路复用）</p>
<ul>
<li>轮流使用信道，信道的时间分为周期</li>
<li>每个站点使用每周期中固定的时隙（长度=帧传输时间）传输帧</li>
<li>如果站点无帧传输，时隙空闲会造成浪费</li>
<li>如：6站LAN，1、3、4有数据报，时隙2、5、6空闲</li>
</ul>
<p>FDMA（frequency division multiple access，频分多路复用）</p>
<ul>
<li>信道的有效频率范围被分成一个个小的频段</li>
<li>每个站点被分配一个固定的频段</li>
<li>分配给站点的频段如果没有被使用，则空闲</li>
<li>如：6站LAN，1、3、4有数据报，频段2、5、 6空闲</li>
</ul>
<p>CDMA（code division multiple access，码分多路复用）</p>
<ul>
<li>所有站点在整个频段上同时进行传输，采用编码原理加以区分</li>
<li>完全无冲突</li>
<li>假定：信号同步很好，线性叠加</li>
</ul>
<p>比喻</p>
<ul>
<li>TDM：不同的人在不同的时刻讲话</li>
<li>FDM：不同的组在不同的小房间里通信</li>
<li>CDMA：不同的人使用不同的语言讲话</li>
</ul>
<h3 id="随机存取协议"><a href="#随机存取协议" class="headerlink" title="随机存取协议"></a>随机存取协议</h3><ul>
<li>当节点有帧要发送时<ul>
<li>以信道带宽的全部 Rbps发送</li>
<li>没有节点间的预先协调</li>
</ul>
</li>
<li>两个或更多节点同时传输，会发生冲突 “collision”</li>
<li>随机存取协议规定<ul>
<li>如何检测冲突</li>
<li>如何从冲突中恢复（如：通过稍后的重传）</li>
</ul>
</li>
<li>随机MAC协议<ul>
<li>时隙ALOHA</li>
<li>ALOHA</li>
<li>CSMA，CSMA/CD，CSMA/CA</li>
</ul>
</li>
</ul>
<h4 id="时隙ALOHA"><a href="#时隙ALOHA" class="headerlink" title="时隙ALOHA"></a>时隙ALOHA</h4><p><img src="/2021/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210907115132473.png" alt="image-20210907115132473"></p>
<p>假设</p>
<ul>
<li>所有帧是等长的</li>
<li>时间被划分成相等的时隙 ，每个时隙可发送一帧</li>
<li>节点只在时隙开始时发送帧</li>
<li>节点在时钟上是同步的</li>
<li>如果两个或多个节点在一 个时隙传输，所有的站点都能检测到冲突 </li>
</ul>
<p>运行</p>
<ul>
<li>当节点获取新的帧，在下一 个时隙传输</li>
<li>传输时没有检测到冲突，成功</li>
<li>节点能够在下一时隙发送新帧</li>
<li>检测时如果检测到冲突，失败</li>
<li>节点在每一个随后的时隙以概率p重传帧直到成功</li>
</ul>
<p>优点</p>
<ul>
<li>节点可以以信道带宽全速连续传输</li>
<li>高度分布：仅需要节点之间在时隙上的同步</li>
<li>简单 </li>
</ul>
<p>缺点</p>
<ul>
<li>存在冲突，浪费时隙</li>
<li>即使有帧要发送，仍然有可能存在空闲的时隙</li>
<li>节点检测冲突的时间&lt;帧传输的时间，因为必须传完</li>
<li>需要时钟上同步</li>
</ul>
<p>最好情况：信道利用率37%</p>
<h4 id="纯ALOHA（非时隙）"><a href="#纯ALOHA（非时隙）" class="headerlink" title="纯ALOHA（非时隙）"></a>纯ALOHA（非时隙）</h4><p><img src="/2021/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210907124300634.png" alt="image-20210907124300634"></p>
<ul>
<li>无时隙ALOHA：简单、无须节点间在时间上同步</li>
<li>当有帧需要传输：马上传输</li>
<li>冲突的概率增加<ul>
<li>帧在t0 发送，和其它在[t0 -1, t0 +1]区间内开始发送的帧冲突</li>
<li>和当前帧冲突的区间</li>
</ul>
</li>
<li>效率比时隙ALOHA差</li>
</ul>
<h4 id="CSMA"><a href="#CSMA" class="headerlink" title="CSMA"></a>CSMA</h4><p>CSMA（载波侦听多路访问）：在传输前先侦听信道</p>
<ul>
<li>如果侦听到信道空闲，传送整个帧</li>
<li>如果侦听到信道忙，推迟传送</li>
</ul>
<p>CSMA冲突：冲突仍然可能发生</p>
<ul>
<li><p>由传播延迟造成：两个节点可能侦听不到正在进行的传输</p>
</li>
<li><p>冲突：整个冲突帧的传输时间都被浪费了，是无效的传输</p>
</li>
<li><p>注意：传播延迟（距离）决定了冲突的概率</p>
<blockquote>
<p>节点依据本地的信道使用情况来判断全部信道的使用情况，是局部性的判断</p>
</blockquote>
</li>
</ul>
<h5 id="CSMA-CD（冲突检测）"><a href="#CSMA-CD（冲突检测）" class="headerlink" title="CSMA/CD（冲突检测）"></a>CSMA/CD（冲突检测）</h5><ul>
<li><p>载波侦听CSMA：和在CSMA中一样发送前侦听信道</p>
</li>
<li><p>没有传完一个帧就可以在短时间内检测到冲突</p>
</li>
<li><p>冲突发生时则传输终止，减少对信道的浪费</p>
</li>
<li><p>冲突检测CD技术，在有线局域网中容易实现：</p>
<ul>
<li>检测信号强度，比较传输与接收到的信号是否相同</li>
<li>通过周期的过零点检测</li>
</ul>
</li>
<li><p>以太网CSMA/CD算法</p>
<ol>
<li><p>适配器获取数据报，创建帧</p>
</li>
<li><p>发送前：侦听信道CS</p>
</li>
</ol>
<ul>
<li>闲：开始传送帧</li>
<li>忙：一直等到闲再发送</li>
</ul>
<ol start="3">
<li>发送过程中，冲突检测CD</li>
</ol>
<ul>
<li>没有冲突：成功</li>
<li>检测到冲突：放弃，之后尝试重发</li>
</ul>
<ol start="4">
<li>发送方适配器检测到冲突，除放弃外还发送一个Jam信号（强化冲突信息），所有听到冲突的适配器也是如此</li>
</ol>
<ul>
<li>强化冲突：让所有站点都知道发生冲突，防止冲突时间过短导致其他结点不知道发生冲突</li>
</ul>
<ol start="5">
<li>如果放弃，适配器进入指数退避状态</li>
</ol>
<p>  在第m次失败后，适配器在${0,1,2, ,2^{m-1}}$中随机选择一个数K，等待K*512位时后，转到步骤2</p>
<blockquote>
<p>二进制指数退避算法（exponential backoff）</p>
<ul>
<li>目标：适配器试图适应当前负载，在一个变化的碰撞窗口中随机选择时间点尝试重发<ul>
<li>高负载：重传窗口时间大，减少冲突，但等待时间长</li>
<li>低负载：使得各站点等待时间少，但冲突概率大</li>
</ul>
</li>
<li>首次碰撞：在{0，1}选择K；延迟K512位时</li>
<li>第2次碰撞：在{0，1，2，3}选择K</li>
<li>第10次碰撞：在{0，1，2，3，……，1023}选择<br>K</li>
</ul>
</blockquote>
</li>
<li><p>CSMA/CD效率：$efficiency=\frac{1}{1+5T_{prop}/T_{trans}}$</p>
<ul>
<li>$T_{prop}$ = LAN上2个节点的最大传播延迟</li>
<li>$T_{trans}$ = 传输最大帧的时间</li>
<li>效率变为1的两种情况<ol>
<li>当tprop 变成0时</li>
<li>当ttrans 变成无穷大时</li>
</ol>
</li>
<li>比ALOHA更好的性能，而且简单，廉价，分布式</li>
</ul>
</li>
</ul>
<h5 id="CSMA-CA（冲突避免）"><a href="#CSMA-CA（冲突避免）" class="headerlink" title="CSMA/CA（冲突避免）"></a>CSMA/CA（冲突避免）</h5><ul>
<li><p>802.11（WLAN）：发送前侦听信道</p>
<ul>
<li>不会和其它节点正在进行的传输发生冲突</li>
</ul>
</li>
<li><p>802.11：没有冲突检测</p>
<ul>
<li><p>无法检测冲突：自身信号远远大于其他节点信号</p>
</li>
<li><p>即使能CD：冲突与成功没有直接关系</p>
<blockquote>
<p>隐藏终端和暴露终端问题</p>
</blockquote>
</li>
<li><p>利用冲突避免：CSMA/C(ollision)A(voidance)</p>
<ul>
<li>无法CD，则一旦发送就全部发送完毕，不CD</li>
<li>为了避免无CD带来的信道利用率低的问题，事前进行冲突避免</li>
</ul>
</li>
</ul>
</li>
<li><p>发送方</p>
<ol>
<li><p>如果站点侦测到信道空闲持续DIFS（分布式帧间间隙）长，则传输整个帧</p>
</li>
<li><p>如果侦测到信道忙碌，那么选择一个随机回退值，并在信道空闲时递减该值；如果信道忙碌，回退值不会变化</p>
<p>当数到0时（只生在信道闲时）发送整个帧如果没有收到ACK，增加回退值，重复2</p>
</li>
</ol>
</li>
<li><p>802.11 接收方</p>
<ul>
<li>如果帧正确，则在SIFS（短帧间间隔）后发送ACK</li>
</ul>
</li>
<li><p>无法完全避免冲突</p>
<ul>
<li>两个站点相互隐藏<ul>
<li>A,B 相互隐藏，C在传输</li>
<li>A,B选择了随机回退值</li>
<li>一个节点如A胜利了，发送</li>
<li>而B节点收不到，顺利count down到0 发送</li>
<li>A,B的发送在C附近形成了干扰</li>
</ul>
</li>
<li>选择了非常靠近的随机回退值：<ul>
<li>A,B选择的值非常近</li>
<li>A到0后发送</li>
<li>但是这个信号还没到达B时</li>
<li>B也到0了，发送</li>
<li>冲突</li>
</ul>
</li>
</ul>
</li>
<li><p>允许发送方“预约”信道，而不是随机访问该信道：避免长数据帧的冲突（可选项）</p>
<ul>
<li>发送方首先使用CSMA向BS发送一个小的RTS分组<ul>
<li>RTS可能会冲突（但是由于比较短，浪费信道较少）</li>
</ul>
</li>
<li>BS广播clear-to-send CTS，作为RTS的响应</li>
<li>CTS能够被所有涉及到的节点听到<ul>
<li>发送方发送数据帧</li>
<li>其它节点抑制发送</li>
</ul>
</li>
</ul>
<blockquote>
<p>采用小的预约分组，可以完全避免数据帧的冲突</p>
</blockquote>
</li>
</ul>
<h3 id="线缆接入网络"><a href="#线缆接入网络" class="headerlink" title="线缆接入网络"></a>线缆接入网络</h3><p><img src="/2021/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20211006125243999.png" alt="image-20211006125243999"></p>
<ul>
<li>多个40Mbps 下行（广播）信道，FDM<ul>
<li>下行：通过FDM分成若干信道，互联网、数字电视等</li>
<li>互联网信道：只有1个CMTS在其上传输</li>
</ul>
</li>
<li>多个30 Mbps上行的信道，FDM<ul>
<li>多路访问：所有用户使用；通过TDM分成微时隙</li>
<li>部分时隙（下行）：分配</li>
<li>部分时隙（上行）：竞争预约</li>
</ul>
</li>
<li>DOCSIS（data over cable service interface spec）协议<ul>
<li>采用FDM进行信道的划分：若干上行、下行信道</li>
<li>下行信道:<ul>
<li>在下行MAP帧中：CMTS告诉各节点微时隙分配方案，分配给各站点的上行微时隙</li>
<li>另外：头端传输下行数据（给各个用户）</li>
</ul>
</li>
<li>TDM上行信道<ul>
<li>采用TDM的方式将上行信道分成若干微时隙：MAP指定</li>
<li>站点采用分配给它的微时隙上行数据传输：分配</li>
<li>在特殊的上行微时隙中，各站点请求上行微时隙：竞争<ul>
<li>各站点对于该时隙的使用是随机访问的</li>
<li>一旦碰撞（请求不成功，结果是：在下行的MAP中没有为它分配，则利用二进制退避算法）选择时隙上传输</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="轮流MAC协议"><a href="#轮流MAC协议" class="headerlink" title="轮流MAC协议"></a>轮流MAC协议</h3><p>轮流（Taking Turns）：综合信道划分MAC协议和随机访问MAC协议的优点</p>
<h4 id="轮询协议"><a href="#轮询协议" class="headerlink" title="轮询协议"></a>轮询协议</h4><ul>
<li>主节点邀请从节点依次传送</li>
<li>从节点一般比较“dumb”</li>
<li>缺点:<ul>
<li>轮询（polling）开销：轮询本身消耗信道带宽</li>
<li>等待时间：每个节点需等到主节点轮询后开始传输，即使只有一个节点，也需要等到轮询一周后才能够发送</li>
<li>单点故障：主节点失效时造成整个系统无法工作</li>
</ul>
</li>
</ul>
<h4 id="令牌传递协议"><a href="#令牌传递协议" class="headerlink" title="令牌传递协议"></a>令牌传递协议</h4><ul>
<li>控制令牌( token)循环从一个节点到下一个节点传递</li>
<li>令牌报文：特殊的帧</li>
<li>缺点<ul>
<li>令牌开销：本身消耗带宽</li>
<li>延迟：只有等到抓住令牌，才可传输</li>
<li>单点故障（token）：<ul>
<li>令牌丢失系统级故障，整个系统无法传输</li>
<li>复杂机制重新生成令牌</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>MAC 协议总结</strong></p>
<ul>
<li>信道划分：按时间、频率或者编码<ul>
<li>TDMA、FDMA、CDMA</li>
</ul>
</li>
<li>随机访问（动态）<ul>
<li>ALOHA，S-ALOHA，CSMA，CSMA/CD</li>
<li>载波侦听: 在有些介质上很容易（wire：有线介质），但在有些介质上比较困难（wireless：无线）</li>
<li>CSMA/CD：802.3 Ethernet网中使用</li>
<li>CSMA/CA：802.11WLAN中使用</li>
</ul>
</li>
<li>依次轮流协议<ul>
<li>集中：由一个中心节点轮询</li>
<li>分布：通过令牌控制</li>
<li>蓝牙、FDDI、令牌环</li>
</ul>
</li>
</ul>
<h2 id="LANs"><a href="#LANs" class="headerlink" title="LANs"></a>LANs</h2><p>交换机局域网，提供的服务有链路层寻址和以太网协议</p>
<h3 id="链路层寻址和ARP"><a href="#链路层寻址和ARP" class="headerlink" title="链路层寻址和ARP"></a>链路层寻址和ARP</h3><h4 id="网络地址和MAC地址"><a href="#网络地址和MAC地址" class="headerlink" title="网络地址和MAC地址"></a>网络地址和MAC地址</h4><ul>
<li>32bit IP 地址：<ul>
<li>网络层地址</li>
<li>前n-1跳：用于使数据报到达目的IP子网</li>
<li>最后一跳：到达子网中的目标节点</li>
</ul>
</li>
<li>LAN（MAC/物理/以太网）地址<ul>
<li>用于使帧从一个网卡传递到与其物理连接的另一个网卡(在同一个物理网络中)</li>
<li>48bit MAC地址固化在适配器的ROM，有时也可以通过软件设定</li>
<li>理论上全球任何2个网卡的MAC地址都不相同</li>
<li>e.g.: 1A-2F-BB-76-09-AD</li>
</ul>
</li>
</ul>
<p><strong>网络地址和MAC地址分离</strong></p>
<ol>
<li>IP地址和MAC地址的作用不同<ul>
<li>IP地址是分层的<ul>
<li>一个子网所有站点网络号一致，路由聚集，减少路由表</li>
<li>需要一个网络中的站点地址网络号一致，如果捆绑需要定制网卡非常麻烦</li>
<li>希望网络层地址是配置的；IP地址完成网络到网络的交付</li>
</ul>
</li>
<li>MAC地址是一个平面的<ul>
<li>网卡在生产时不知道被用于哪个网络，因此给网卡一个唯一的标示，用于区分一个网络内部不同的网卡即可</li>
<li>可以完成一个物理网络内部的节点到节点的数据交付</li>
</ul>
</li>
</ul>
</li>
<li>分离好处<ul>
<li>网卡坏了，IP不变，可以捆绑到另外一个网卡的MAC地址上</li>
<li>物理网络还可以除IP之外支持其他网络层协议，链路协议为任意上层网络协议， 如IPX等</li>
</ul>
</li>
<li>捆绑的问题<ul>
<li>如果仅仅使用IP地址，不用MAC地址，那么它仅支持IP协议</li>
<li>每次上电都要重新写入网卡IP地址；</li>
<li>另外一个选择就是不使用任何地址；不用MAC地址，则每到来一个帧都要上传到IP层次，由它判断是不是需要接受，干扰一次</li>
</ul>
</li>
</ol>
<p>局域网上每个适配器都有一个唯一的LAN地址</p>
<p>全局广播地址（Broadcast address） ：FF-FF-FF-FF-FF-FF，发出的帧局域网内所有结点均能接收</p>
<p>MAC 地址由 IEEE 管理和分配</p>
<p>制造商购入 MAC 地址空间（保证唯一性）</p>
<h4 id="ARP（地址解析协议）"><a href="#ARP（地址解析协议）" class="headerlink" title="ARP（地址解析协议）"></a>ARP（地址解析协议）</h4><p>在LAN上的每个IP节点都有一个ARP表</p>
<ul>
<li><p>ARP表：包括一些LAN节点IP/MAC地址的映射</p>
<blockquote>
<p>&lt; IP address；MAC address；TTL&gt;</p>
<ul>
<li>TTL时间是指地址映射失效的时间</li>
<li>典型是20min</li>
</ul>
</blockquote>
</li>
</ul>
<p>工作流程</p>
<ul>
<li>A要发送帧给B（B的IP地址已知），但B的MAC地址不在A的ARP表中</li>
<li>A广播包含B的IP地址的ARP查询包<ul>
<li>Dest MAC address =FF-FF-FF-FF-FF-FF</li>
<li>LAN上的所有节点都会收到该查询包</li>
</ul>
</li>
<li>B接收到ARP包，回复A自己的MAC地址<ul>
<li>帧发送给A</li>
<li>用A的MAC地址（单播）</li>
</ul>
</li>
<li>A在自己的ARP表中，缓存IP-to-MAC地址映射关系，直到信息超时<ul>
<li>软状态：靠定期刷新维持的系统状态</li>
<li>定期刷新周期之间维护的状态信息可能和原有系统不一致</li>
</ul>
</li>
<li>ARP是即插即用的<ul>
<li>节点自己创建ARP的表项</li>
<li>无需网络管理员的干预</li>
</ul>
</li>
</ul>
<h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><h4 id="以太网的物理拓扑"><a href="#以太网的物理拓扑" class="headerlink" title="以太网的物理拓扑"></a><strong>以太网的物理拓扑</strong></h4><ul>
<li><p>总线：在上个世纪90年代中期很流行</p>
<ul>
<li><p>所有节点在一个碰撞域内，一次只允许一个节点发送</p>
</li>
<li><p>可靠性差，如果介质破损，截面形成信号的反射，发送节点误认为是冲突，总是冲突</p>
<p><img src="/2021/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20211008092831473.png" alt="image-20211008092831473"></p>
</li>
</ul>
</li>
<li><p>星型：目前最主流</p>
<ul>
<li><p>连接选择: hub 或者switch</p>
</li>
<li><p>现在一般是交换机在中心</p>
</li>
<li><p>每个节点以及相连的交换机端口使用（独立的）以太网协议（不会和其他节点的发送产生碰撞）</p>
<p><img src="/2021/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20211008092906021.png" alt="image-20211008092906021"></p>
</li>
</ul>
</li>
</ul>
<h4 id="以太帧结构"><a href="#以太帧结构" class="headerlink" title="以太帧结构"></a>以太帧结构</h4><p>发送方适配器在以太网帧中封装IP数据报，或其他网络层协议数据单元</p>
<p><img src="/2021/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20211008093047673.png" alt="image-20211008093047673"></p>
<ul>
<li>前导码<ul>
<li>7B 10101010 + 1B 10101011</li>
<li>用来同步接收方和发送方的时钟速率<ul>
<li>使得接收方将自己的时钟调到发送端的时钟</li>
<li>从而可以按照发送端的时钟来接收所发送的帧</li>
</ul>
</li>
</ul>
</li>
<li>地址：6字节源MAC地址，目标MAC地址<ul>
<li>如：帧目标地址=本站MAC地址，或是广播地址，接收，递交帧中的数据到网络层</li>
<li>否则，适配器忽略该帧</li>
</ul>
</li>
<li>类型：指出高层协(大多情况下是IP，但也支持其它网络层协议Novell IPX和AppleTalk)</li>
<li>CRC：在接收方校验<ul>
<li>如果没有通过校验，丢弃错误帧</li>
</ul>
</li>
</ul>
<h4 id="以太网-1"><a href="#以太网-1" class="headerlink" title="以太网"></a>以太网</h4><p>以太网提供无连接、不可靠的服务</p>
<ul>
<li>无连接：帧传输前，发送方和接收方之间没有握手</li>
<li>不可靠：接收方适配器不发送ACKs或NAKs给发送方<ul>
<li>递交给网络层的数据报流可能有gap</li>
<li>如上层使用像传输层TCP协议这样的rdt，gap会被补上(源主机，TCP实体)</li>
<li>否则，应用层就会看到gap</li>
</ul>
</li>
<li>以太网的MAC协议：采用二进制退避的CSMA/CD介质访问控制形式</li>
</ul>
<p>以太网标准：链路和物理层</p>
<ul>
<li>很多不同的以太网标准</li>
<li>相同的MAC协议（介质访问控制）和帧结构</li>
<li>不同的速率：2 Mbps、10 Mbps 、100 Mbps 、1Gbps、10G bps</li>
<li>不同的物理层标准</li>
<li>不同的物理层媒介：光纤，同轴电缆和双绞线</li>
</ul>
<p>以太网使用CSMA/CD算法</p>
<h4 id="Hubs"><a href="#Hubs" class="headerlink" title="Hubs"></a><strong>Hubs</strong></h4><p>Hubs 本质上是物理层的中继器:</p>
<ul>
<li>从一个端口收，转发到所有其他端口</li>
<li>速率一致</li>
<li>没有帧的缓存</li>
<li>在hub端口上没有CSMA/CD机制:适配器检测冲突</li>
<li>提供网络管理功能</li>
</ul>
<h4 id="Manchester-编码"><a href="#Manchester-编码" class="headerlink" title="Manchester 编码"></a>Manchester 编码</h4><ul>
<li><p>在10BaseT中使用</p>
</li>
<li><p>每一个bit的位时中间有一个信号跳变</p>
</li>
<li><p>允许在接收方和发送方节点之间进行时钟同步</p>
<ul>
<li>节点间不需要集中的和全局的时钟</li>
</ul>
</li>
<li><p>10Mbps，使用20M带宽，效率50%</p>
<p><img src="/2021/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20211008100338741.png" alt="image-20211008100338741"></p>
</li>
</ul>
<h4 id="100BaseT中的4b5b编码"><a href="#100BaseT中的4b5b编码" class="headerlink" title="100BaseT中的4b5b编码"></a>100BaseT中的4b5b编码</h4><p>利用5个字节来代替四个字节，防止传输中长时间编码不跳变，无法准确获取时钟信号的状态</p>
<p><img src="/2021/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20211008100500832.png" alt="image-20211008100500832"></p>
<h4 id="千兆以太网"><a href="#千兆以太网" class="headerlink" title="千兆以太网"></a>千兆以太网</h4><ul>
<li>采用标准的以太帧格式</li>
<li>允许点对点链路和共享广播信道</li>
<li>物理编码：8b10b编码</li>
<li>在共享模式，继续使用CSMA/CD MAC技术，节点间需要较短距离以提高利用率</li>
<li>交换模式：全双工千兆可用于点对点链路<ul>
<li>站点使用专用信道，基本不会冲突，效率高</li>
<li>除非发往同一个目标站点</li>
</ul>
</li>
</ul>
<h3 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h3><p>虚拟局域网（VLAN），支持VLAN的交换机允许经一个单一的物理局域网基础设施定义多个虚拟局域网</p>
<h4 id="IEEE-802-11"><a href="#IEEE-802-11" class="headerlink" title="IEEE 802.11"></a>IEEE 802.11</h4><ul>
<li>802.11b<ul>
<li>使用无需许可的2.4-5 GHz 频谱</li>
<li>无绳电话和微波炉</li>
<li>最高11 Mbps</li>
<li>在物理层采用直接序列扩频direct sequence spreadspectrum (DSSS)<ul>
<li>所有的主机采用同样的序列码</li>
</ul>
</li>
</ul>
</li>
<li>802.11a<ul>
<li>更高频率5-6 GHz</li>
<li>最高54 Mbps</li>
<li>距离相对短，受多路径影响大</li>
</ul>
</li>
<li>802.11g<ul>
<li>频率2.4-5 GHz</li>
<li>最大54 Mbps</li>
<li>与802.11b向后兼容</li>
</ul>
</li>
<li>802.11n：多天线MIMO<ul>
<li>频率2.4-5 GHz</li>
<li>最高200 Mbps</li>
</ul>
</li>
<li>所有的802.11标准都是用CSMA/CA进行多路访问</li>
<li>所有的802.11标准都有基站模式和自组织网络模式</li>
</ul>
<h4 id="802-11-体系结构"><a href="#802-11-体系结构" class="headerlink" title="802.11 体系结构"></a>802.11 体系结构</h4><ul>
<li>无线主机与基站通信<ul>
<li>基站base station = 接入点access point (AP)</li>
</ul>
</li>
<li>基础设施模式下的基本服务集Basic Service Set（BSS）（aka“cell”）包括以下构件<ul>
<li>无线主机</li>
<li>接入点（AP）：基站</li>
<li>自组织模式下：只有无线主机</li>
</ul>
</li>
</ul>
<p><img src="/2021/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20211008101251525.png" alt="image-20211008101251525"></p>
<h4 id="802-11-信道与关联"><a href="#802-11-信道与关联" class="headerlink" title="802.11 信道与关联"></a>802.11 信道与关联</h4><ul>
<li><p>802.11b: 2.4GHz-2.485GHz 频谱被分为11个相互不同的但是部分重叠的频段</p>
<ul>
<li>AP管理员为AP选择一个频率</li>
<li>可能的干扰: 邻居AP可能选择同样一个信道!</li>
</ul>
</li>
<li><p>主机: 必须在通信之前和AP建立associate</p>
<ul>
<li><p>扫描所有的信道，侦听包含AP SSID和MAC地址的信标帧</p>
<ul>
<li><p>主动扫描：主机发送探测，接受AP的响应</p>
<blockquote>
<p>主动扫描:<br>(1) H1广播探测请求帧<br>(2) 自AP发送探测响应<br>(3) H1向选择的AP发送关联请求帧<br>(4) 选择的AP向H1发送关联的响应帧</p>
</blockquote>
</li>
<li><p>被动扫描</p>
<blockquote>
<p>被动扫描:<br>(1) AP发送信标帧<br>(2) 关联请求帧的发送：H1向拟关联的AP<br>(3) 关联响应帧的发送: AP向H1</p>
</blockquote>
</li>
</ul>
</li>
<li><p>选择希望关联的AP</p>
</li>
<li><p>可能需要执行鉴别（认证）[Chapter 8]</p>
<ul>
<li>基于MAC、用户名口令</li>
<li>通过AP的中继，使用RADIUS鉴别服务器进行身份鉴别</li>
</ul>
</li>
<li><p>将会执行DHCP获得IP地址和AP所在的子网前缀</p>
</li>
</ul>
</li>
</ul>
<h4 id="802-11-帧"><a href="#802-11-帧" class="headerlink" title="802.11 帧"></a>802.11 帧</h4><p><img src="/2021/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20211008115830070.png" alt="image-20211008115830070"></p>
<p><img src="/2021/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20211008115945670.png" alt="image-20211008115945670"></p>
<h4 id="Switches"><a href="#Switches" class="headerlink" title="Switches"></a>Switches</h4><p><strong>Hub：集线器</strong></p>
<ul>
<li>网段（LAN segments）：可以允许一个站点发送的网络范围<ul>
<li>在一个碰撞域，同时只允许一个站点在发送</li>
<li>如果有2个节点同时发送，则会碰撞</li>
<li>通常拥有相同的前缀，比IP子网更详细的前缀</li>
</ul>
</li>
<li>所有以Hub连到一起的站点处在一个网段，处在一个碰撞域<ul>
<li>骨干Hub将所有网段连到了一起</li>
</ul>
</li>
<li>通过Hub可扩展节点之间的最大距离</li>
<li>通过HUB,不能将 10BaseT 和 100BaseT 的网络连接到一起</li>
</ul>
<p><strong>交换机</strong></p>
<ul>
<li>链路层设备：扮演主动角色（端口执行以太网协议）<ul>
<li>对帧进行存储和转发</li>
<li>对于到来的帧，检查帧头，根据目标MAC地址进行选择性转发</li>
<li>当帧需要向某个（些）网段进行转发，需要使用CSMA/CD进行接入控制</li>
<li>通常一个交换机端口一个独立网段</li>
</ul>
</li>
<li>透明：主机对交换机的存在可以不关心<ul>
<li>通过交换机相联的各节点好像这些站点是直接相联的一样</li>
<li>有MAC地址；无IP地址</li>
</ul>
</li>
<li>即插即用，自学习<ul>
<li>交换机无需配置</li>
</ul>
</li>
</ul>
<p><strong>交换机：多路同时传输</strong></p>
<ul>
<li>主机有一个专用和直接到交换机的连接</li>
<li>交换机缓存到来的帧</li>
<li>对每个帧进入的链路使用以太网协议，没有碰撞；全双工<ul>
<li>每条链路都是一个独立的碰撞域</li>
<li>MAC协议在其中的作用弱化了</li>
</ul>
</li>
</ul>
<p><strong>交换机：自学习</strong></p>
<ul>
<li>交换机通过学习得到哪些主机（mac地址）可以通过哪些端口到达<ul>
<li>当接收到帧，交换机学习到发送站点所在的端口（网段）</li>
<li>记录发送方MAC地址/进入端口映射关系，在交换表中</li>
</ul>
</li>
</ul>
<p><strong>交换机 VS 路由器</strong></p>
<ul>
<li>都是存储转发设备，但层次不同<ul>
<li>交换机：链路层设备（检查链路层头部）</li>
<li>路由器：网络层设备（检查网络层的头部）</li>
</ul>
</li>
<li>都有转发表<ul>
<li>交换机：维护交换表，按照MAC地址转发<ul>
<li>执行过滤、自学习和生成树算法</li>
<li>即插即用；二层设备，速率高</li>
<li>执行生成树算法，限制广播帧的转发</li>
<li>ARP表项随着站点数量增多而增多</li>
</ul>
</li>
<li>路由器维护路由表，执行路由算法<ul>
<li>路由算法能够避免环路，无需执行生成树算法，可以以各种拓扑构建网络</li>
<li>对广播分组做限制</li>
<li>不是即插即用的，配置网络地址（子网前缀）</li>
<li>三层设备，速率低</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>大学课程</tag>
      </tags>
  </entry>
  <entry>
    <title>JS异步</title>
    <url>/2021/11/02/JS/JS%E5%BC%82%E6%AD%A5/</url>
    <content><![CDATA[<p>JavaScript 的异步编程</p>
<ul>
<li>ES6新增的期约（Promise）是一种对象，代表某个异步操作尚不可用的结果</li>
<li>ES2017 新增的 <code>async</code> 和 <code>await</code> 关键字为简化异步编程提供新语法，允许开发者将基于期约的异步代码写出同步的形式</li>
<li>ES2018 引入异步迭代器和 <code>for/await</code> 循环，允许在看起来同步的简单循环中操作异步事件流</li>
</ul>
<span id="more"></span>



<h2 id="使用回调的异步编程"><a href="#使用回调的异步编程" class="headerlink" title="使用回调的异步编程"></a>使用回调的异步编程</h2><p>在最基本的层面，JavaScript 异步编程是基于回调实现的</p>
<p>回调即函数，可以传递给其他函数，其他函数在满足某个条件或发生某个（异步）事件时调用（回调）这个函数</p>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>一种最简单的异步操作即在一定时间后运行某些代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(checkForUpdates, <span class="number">60000</span>);</span><br></pre></td></tr></table></figure>

<p><code>setTimeout()</code> 函数的第一个参数是一个函数，第二个参数是以毫秒为单位的时间间隔</p>
<p><code>setTimeout()</code> 用来注册回调函数，还指定在什么异步条件下调用回调函数</p>
<p><code>setTimeout()</code> 只会调用一次指定的回调函数，若需要重复运行，使用 <code>setInterval()</code> </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1分钟后调用checkForUpdates，然后每过1分钟调用一次</span></span><br><span class="line"><span class="keyword">let</span> updateIntervalId = <span class="built_in">setInterval</span>(checkForUpdates, <span class="number">60000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// setInterval()返回一个值，把这个值传给clearInterval()</span></span><br><span class="line"><span class="comment">// 可以停止这种重复调用（类似地，setTimeout()也返回一个值，</span></span><br><span class="line"><span class="comment">// 可以把它传给clearTimeout()）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopCheckingForUpdates</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(updataIntervalld);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>客户端 JavaScript 编程几乎全都是事件驱动的，等待用户行为，然后响应用户的动作</p>
<p>事件驱动的 JavaScript 程序在特定上下文中为特定类型的事件注册回调函数，而浏览器在指定的事件发生时调用这些函数，这些回调函数叫做事件处理程序或事件监听器，通过 <code>addEventListener()</code> 注册</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 浏览器返回一个对象，表示与下面的CSS选择符匹配的&lt;button&gt;元素</span></span><br><span class="line"><span class="keyword">let</span> okay = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#confirmUpdateDialog button.okey&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后注册一个回调函数，当用户单击该按钮时会被调用</span></span><br><span class="line">okey.addEventListener(<span class="string">&#x27;click&#x27;</span>,applyUpadte);</span><br></pre></td></tr></table></figure>



<h3 id="网络事件"><a href="#网络事件" class="headerlink" title="网络事件"></a>网络事件</h3><p>JavaScript 中常见的异步操作来源还可以是网络请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从Web服务器获取数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCurrentVersionNumber</span>(<span class="params">versionCallback</span>)</span>&#123;    <span class="comment">// 注意回调参数</span></span><br><span class="line">    <span class="comment">// 通过脚本向后端版本API发送一个HTTP请求</span></span><br><span class="line">    <span class="keyword">let</span> request = <span class="keyword">new</span> XMLHeepRequest();</span><br><span class="line">    request.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;http://www.example.com/api/version&quot;</span>);</span><br><span class="line">    request.send();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册一个将在响应到达时调用的回调</span></span><br><span class="line">    request.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(request.status === <span class="number">200</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果HTTP状态码没问题，则取得版本号并调用回调</span></span><br><span class="line">            <span class="keyword">let</span> currentVersion = <span class="built_in">parseFloat</span>(request.responseText);</span><br><span class="line">            versionCallback(<span class="literal">null</span>, currentVersion);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 否则，通过回调报告错误</span></span><br><span class="line">            versionCallback(response.statusText, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 注册另一个将在网络出错时调用的回调</span></span><br><span class="line">    request.onerror = request.ontimeout = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        versionCallback(e.type, <span class="literal">null</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端 JavaScript 代码可以使用 <code>XMLHttpRequest</code> 类及回调函数来发送 HTTP 请求并异步处理服务器返回的响应</p>
<blockquote>
<p><code>XMLHttpRequest</code> 类在现代客户端 JavaScript 中，很大程度上已经被 <code>fetch()</code> API 取代</p>
</blockquote>
<p>对于大多数 Web API（包括XMLHttpRequest），都可以通过在生成事件的对象上调用 <code>addEventListener()</code> 并将相关事件的名字传给回调函数来定义事件处理程序，也可以如上述代码，将回调函数赋值给这个对象的一个属性来注册事件监听器</p>
<h3 id="Node-中的回调与事件"><a href="#Node-中的回调与事件" class="headerlink" title="Node 中的回调与事件"></a>Node 中的回调与事件</h3><p>Node.js 服务器端 JavaScript 环境底层就是异步的，定义了很多使用回调和事件的 API。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取文件内容的默认API是异步的，会在读取文件内容后调用一个回调函数</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);     <span class="comment">// &quot;fs&quot;模块有文件系统相关的API</span></span><br><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">    <span class="comment">// 默认选项填写</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取配置文件，然后调用回调函数</span></span><br><span class="line">fs.readFile(<span class="string">&quot;config..json&quot;</span>, <span class="string">&quot;utf-8&quot;</span>, <span class="function">(<span class="params">err, text</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="comment">// 如果有错误，显示一条警告消息，但仍然继续</span></span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">&quot;Could not read config file:&quot;</span>, err);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 否则，解析文件内容并赋值给选项对象</span></span><br><span class="line">        <span class="built_in">Object</span>.assign(options, <span class="built_in">JSON</span>.parse(text));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 无论是什么情况，都启动运行程序</span></span><br><span class="line">    startProgram(options);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Node 的 <code>fs.readFile()</code> 函数参数</p>
<ul>
<li>filename（必选），表示要读取的文件名。</li>
<li>encoding（可选），表示文件的字符编码。</li>
<li>callback 是回调函数，用于接收文件的内容。</li>
</ul>
<p>Node 也定义了一些基于事件的 API</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在Node中通过HTTP请求获取URL的内容</span></span><br><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">&quot;https&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取URL文本内容，将其异步传给回调</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getText</span>(<span class="params">url, callback</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 对URL发送一个HTTP GET请求</span></span><br><span class="line">    request = https.get(url);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册一个函数处理“response”事件</span></span><br><span class="line">    request.on(<span class="string">&quot;response&quot;</span>, <span class="function"><span class="params">response</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 这个响应事件意味着收到了响应头</span></span><br><span class="line">        <span class="keyword">let</span> httpStatus = response.statusCode;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 此时没有收到HTTP响应体</span></span><br><span class="line">        <span class="comment">// 因此还要注册几个事件处理程序，以便收到响应体时被调用</span></span><br><span class="line">        response.setEncoding(<span class="string">&quot;utf-8&quot;</span>);      <span class="comment">// 应该Unicode文本</span></span><br><span class="line">        <span class="keyword">let</span> body = <span class="string">&quot;&quot;</span>;                      <span class="comment">// 需要在这里积累</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 每个响应体块就绪时都会调用这个事件处理程序</span></span><br><span class="line">        response.on(<span class="string">&quot;data&quot;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> &#123; body += chunk; &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 响应完成时会调用这个事件处理程序</span></span><br><span class="line">        response.on(<span class="string">&quot;end&quot;</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(httpStatus === <span class="number">200</span>)&#123;         <span class="comment">// 如果HTTP响应码没问题</span></span><br><span class="line">                callback(<span class="literal">null</span>, body);       <span class="comment">// 把响应体传给回调</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                          <span class="comment">// 否则传错误</span></span><br><span class="line">                callback(httpStatus, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为底层网络错误注册一个事件处理程序</span></span><br><span class="line">    request.on(<span class="string">&quot;error&quot;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span>&#123;</span><br><span class="line">        callback(err, <span class="literal">null</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码包含两层处理事件监听器的异步代码，Node 使用 <code>on()</code> 方法注册事件监听器</p>
<h2 id="期约"><a href="#期约" class="headerlink" title="期约"></a>期约</h2><p>期约是一个对象，表示异步操作的结果</p>
<p>使用期约的好处：</p>
<ul>
<li>基于回调的异步编程经常会出现回调多层嵌套的情形，造成代码缩进过多以致难以阅读，期约让这种嵌套回调以一种更线性的期约链形式表达</li>
<li>基于回调的异步编程难以处理错误。若一个异步函数（或异步调用的回调）抛出异常，该异常没有办法传播到异步操作的发起者，对此，可以使用回调参数严密跟踪和传播错误并返回值，但这样麻烦且易出错，期约标准化了异步错误处理，通过期约链提供一种让错误正确传播的途径</li>
</ul>
<p>期约表示的是一次异步计算的未来结果，不能使用它们表示重复的异步计算</p>
<h3 id="使用期约"><a href="#使用期约" class="headerlink" title="使用期约"></a>使用期约</h3><p>核心 JavaScript 支持期约后，浏览器也开始实现基于期约的 API</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getJSON(url).then(<span class="function"><span class="params">jsonData</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这是一个回调函数，在解析得到JSON值</span></span><br><span class="line">    <span class="comment">// 后被异步调用，并接收该JSON值作为参数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>类似上节的 <code>getText()</code> 函数，发送异步 HTTP 请求，并将 HTTP 响应体传给以字符串形式指定的一个回调函数</p>
<p><code>getJSON()</code> 不接受回调函数，将 HTTP 响应体解析成 JSON 格式并返回一个期约，<code>getJSON()</code> 向指定 url 发送异步 HTTP 请求，在请求结果待定期间返回一个期约对象，这个对象有一个实例方法 <code>then()</code>，回调函数传给这个 <code>then()</code> 方法，当 HTTP 响应到达，响应体被解析为 JSON 格式，解析后的值被传给作为 <code>then()</code> 的参数的函数</p>
<p> <code>then()</code> 方法可以想成 <code>addEventListener()</code> 方法，若多次调用一个期约对象的 <code>then()</code> 方法，则指定的每个函数都会在预期计算完成后被调用</p>
<p>期约表示一个计算，每个通过 <code>then()</code> 方法注册的函数都只会被调用一次，且即使调用 <code>then()</code> 时异步计算已经完成，传给 <code>then()</code> 的函数也会被异步调用</p>
<p>通常以动词开头来命名返回期约的函数以及使用期约结果的函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设有一个类似的函数可以显示用户简历</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayUserProfile</span>(<span class="params">profile</span>) </span>&#123; <span class="comment">/* 省略实现细节 */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在返回期约的函数中使用这个函数</span></span><br><span class="line">getJSON(<span class="string">&quot;/api/user/profile&quot;</span>).then(displayUserProfile);</span><br></pre></td></tr></table></figure>



<p><strong>使用期约处理错误</strong></p>
<p>期约可以通过给 <code>then()</code> 方法传第二个函数来实现错误处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getJSON(<span class="string">&quot;/api/user/profile&quot;</span>).then(displayUserProfile,handleProfileError);</span><br></pre></td></tr></table></figure>

<p>上述代码中，若 <code>getJSON()</code> zheng’chang结束，它会将计算结果传给 <code>displayUserProfile()</code>，若出现错误（如用户没有登录、服务器下线、用户网络中断、请求超时等），将 Error 对象传给 <code>handleProfileError()</code></p>
<p>实际开发中，更多的使用传统方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getJSON(<span class="string">&quot;/api/user/profile&quot;</span>).then(displayUserProfile).catch(handleProfileError);</span><br></pre></td></tr></table></figure>



<h3 id="期约链"><a href="#期约链" class="headerlink" title="期约链"></a>期约链</h3><p>期约以线性 <code>then()</code> 方法调用链的形式表达一连串异步操作，而无需把每个操作嵌套在前一个操作的回调内部</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line">fetch(documentURL)                        <span class="comment">// 发送HTTP请求</span></span><br><span class="line">	.then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())    <span class="comment">// 获取JSON格式的响应体</span></span><br><span class="line">	.then(<span class="function"><span class="params">document</span> =&gt;</span> &#123;                   <span class="comment">// 在取得解析后的JSON时</span></span><br><span class="line">    	<span class="keyword">return</span> render(<span class="built_in">document</span>);          <span class="comment">// 把文档显示给用户</span></span><br><span class="line">	&#125;)</span><br><span class="line">	.then(<span class="function"><span class="params">rendered</span> =&gt;</span> &#123;                   <span class="comment">// 在取得渲染的文档后</span></span><br><span class="line">    	cacheInDatabase(rendered);        <span class="comment">// 把它缓存在本地数据库中</span></span><br><span class="line">	&#125;)</span><br><span class="line">	.catch(<span class="function"><span class="params">error</span> =&gt;</span> handle(error));       <span class="comment">// 处理发生的错误</span></span><br></pre></td></tr></table></figure>

<p>HTTP API 的最简单形式就是函数 <code>fetch()</code>，传给它一个 URL，返回一个期约，这个期约在 HTTP 响应开始到达且 HTTP 状态和头部可用时兑现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">&quot;/api/user/profile&quot;</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在期约解决时，可以访问 HTTP 状态和头部</span></span><br><span class="line">    <span class="keyword">if</span>(response.ok &amp;&amp; response.headers.get(<span class="string">&quot;Content-Type&quot;</span>) === <span class="string">&quot;application/json&quot;</span>)&#123;</span><br><span class="line">        <span class="comment">// 还未得到响应体时的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p> <code>fetch()</code> 返回的期约兑现时，传给它的 <code>then()</code> 方法的函数会被调用，这个函数会收到一个 <code>Response</code> 对象，通过这个响应对象可以访问请求状态和头部，也可以通过 <code>text()</code> 和 <code>json()</code> 方法取得文本和 JSON 格式的响应体。不过，虽然最初的期约兑现，响应体尚未到达，用于取得响应体的方法本身也返回期约</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">&quot;/api/user/profile&quot;</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> response.json();</span><br><span class="line">	&#125;)</span><br><span class="line">	.then(<span class="function"><span class="params">profile</span> =&gt;</span> &#123;</span><br><span class="line">    	displayUserProfile(profile);</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>

<p>若存在方法链，每一个 <code>then()</code> 方法调用都返回一个新期约兑现，这个新期约对象在传给 <code>then()</code> 的函数执行结束才会兑现</p>
<h3 id="解决期约"><a href="#解决期约" class="headerlink" title="解决期约"></a>解决期约</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c1</span>(<span class="params">response</span>)</span>&#123;                <span class="comment">// 回调1</span></span><br><span class="line">    <span class="keyword">let</span> p4 = response.json();</span><br><span class="line">    <span class="keyword">return</span> p4;                        <span class="comment">// 返回期约4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c2</span>(<span class="params">profile</span>)</span>&#123;                 <span class="comment">// 回调2</span></span><br><span class="line">    displayUserProfile(profile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = fetch(<span class="string">&quot;/api/user/profile&quot;</span>);  <span class="comment">// 期约1，任务1</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(c1);                 <span class="comment">// 期约2，任务2</span></span><br><span class="line"><span class="keyword">let</span> p3 = p2.then(c2);                 <span class="comment">// 期约3，任务3</span></span><br></pre></td></tr></table></figure>

<p>通过期约抓取 URL 过程，如图所示</p>
<img src="/2021/11/02/JS/JS%E5%BC%82%E6%AD%A5/image-20211102204522636.png" alt="image-20211102204522636" style="zoom:67%;">



<p>当把回调 c 传给 <code>then()</code> 方法时，<code>then()</code> 返回期约 p，并安排好在将来某个时刻异步调用 c，届时，这个回调执行某些计算并返回一个值 v。当这个回调返回值 v 时，p 就以这个值得到解决</p>
<ul>
<li>当期约以一个非期约值解决时，会立即以这个值兑现，即若 c 返回非期约值，该返回值变为 p 的值，p 兑现，结束</li>
<li>若返回值 v 是一个期约，p 会得到解决但并未兑现，此时，p要等到期约 v 落定后才能落定<ul>
<li>v 兑现，p 会以相同的值兑现</li>
<li>v 被拒绝，p 会以相同的理由被拒绝</li>
</ul>
</li>
</ul>
<h3 id="期约错误"><a href="#期约错误" class="headerlink" title="期约错误"></a>期约错误</h3><p>给 <code>.then()</code> 方法传第二个回调函数，这个函数会在期约被拒绝时调用，传给第二个回调函数的参数是一个值（通常是一个 <code>Error</code> 对象），表示拒绝理由</p>
<p>在实际编程中，基于期约的错误一般是通过给期约链添加一个 <code>.catch()</code> 方法调用来处理</p>
<p>在异步代码中，未处理的异常往往不会得到报告，错误只会静默发生，导致极难调试，因此细致的错误处理在异步编程中尤为重要</p>
<p>期约的 <code>.catch()</code> 实际上是对以 <code>null</code> 为第一个参数，以错误处理回调为第二个参数的 <code>.then()</code> 调用的简写</p>
<p>ES2018 中，期约对象新增 <code>.finally()</code> 方法，类似 <code>try/catch/fianlly</code> 语句中的 <code>finally</code> 子句，若在期约链中添加一个 <code>finally</code> 调用，那么传给 <code>.finally()</code> 的回调会在期约落定时被调用，无论期约是兑现还是被拒绝，回调都会被调用，调用时不会给传任何参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接近实际中的URL抓取代码</span></span><br><span class="line">fetch(<span class="string">&quot;/api/user/profile&quot;</span>)         <span class="comment">// 发送HTTP请求</span></span><br><span class="line">	.then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;            <span class="comment">// 在状态和头部就绪时调用</span></span><br><span class="line">    	<span class="keyword">if</span>(!response.ok)&#123;          <span class="comment">// 若遇到404或类似错误</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;           <span class="comment">// 返回空内容</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// 检测头部以确保服务器发送的是JSON</span></span><br><span class="line">    	<span class="comment">// 若不是，表明服务器失效，是一个严重错误</span></span><br><span class="line">    	<span class="keyword">let</span> type = response.headers.get(<span class="string">&quot;content-type&quot;</span>);</span><br><span class="line">    	<span class="keyword">if</span>(type !== <span class="string">&quot;application/json&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`Expected JSON, got <span class="subst">$&#123;type&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// 执行到此，说明状态码为2xx，内容类型为JSON</span></span><br><span class="line">    	<span class="comment">// 可以安心返回一个期约，表示解析响应体之后得到的JSON对象</span></span><br><span class="line">    	<span class="keyword">return</span> response.json();</span><br><span class="line">	&#125;)</span><br><span class="line">	.then(<span class="function"><span class="params">profile</span> =&gt;</span> &#123;             <span class="comment">// 调用时传入解析后的响应体或null</span></span><br><span class="line">    	<span class="keyword">if</span>(profile)&#123;</span><br><span class="line">            displayUserProfile(profile);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;          <span class="comment">// 若遇到404错误并返回null</span></span><br><span class="line">            displayLoggedOutProfilePage();</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	.catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    	<span class="keyword">if</span>(e <span class="keyword">instanceof</span> NerworkError)&#123;</span><br><span class="line">            <span class="comment">// fetch()在互联网连接故障执行下面代码</span></span><br><span class="line">            displayErrorMessage(<span class="string">&quot;Check your internet connection.&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(e <span class="keyword">instanceof</span> <span class="built_in">TypeError</span>)&#123;</span><br><span class="line">            <span class="comment">// 若前面抛出TypeError执行下面代码</span></span><br><span class="line">            displayErrorMessage(<span class="string">&quot;Something is wrong with our server!&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 发生意料之外的错误</span></span><br><span class="line">            <span class="built_in">console</span>.error(e);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>

<p>在复杂网络环境下，错误可能以某种概率随机发生，处理这些错误时，可以重新发送异步请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于期约的操作来查询数据库</span></span><br><span class="line">queryDatabase()</span><br><span class="line">	.then(displayTable)</span><br><span class="line">	.catch(displayDatabaaseError);</span><br></pre></td></tr></table></figure>

<p>假设瞬间网络负载问题会导致这个查询有 1% 的失败概率</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重新发送请求</span></span><br><span class="line">queryDatabase()</span><br><span class="line">	.catch(<span class="function"><span class="params">e</span> =&gt;</span> wait(<span class="number">500</span>).then(queryDatabase)) <span class="comment">//若失败，等待并重试</span></span><br><span class="line">	.then(displayTable)</span><br><span class="line">	.catch(displayDatabaaseError);</span><br></pre></td></tr></table></figure>

<p>此时，错误率降低</p>
<h3 id="并行期约"><a href="#并行期约" class="headerlink" title="并行期约"></a>并行期约</h3><p>若要并行执行多个异步操作，可以使用函数 <code>Promise.all()</code></p>
<p><code>Promise.all()</code> 接收一个期约对象的数组作为输入，返回一个期约</p>
<ul>
<li>若输入期约中的任意一个拒绝，返回的期约也将拒绝</li>
<li>否则，返回的期约会以每个输入期约兑现值得数组兑现</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抓取多个URL文本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先定义一个URL数组</span></span><br><span class="line"><span class="keyword">const</span> urls = [ <span class="comment">/* 零或多个URL */</span> ];</span><br><span class="line"><span class="comment">// 然后将其转换为一个期约对象的数组</span></span><br><span class="line">promises = urls.map(<span class="function"><span class="params">url</span> =&gt;</span> fetch(url).then(<span class="function"><span class="params">r</span> =&gt;</span> r.text()));</span><br><span class="line"><span class="comment">// 现在用一个期约来并行运行数组中的所有期约</span></span><br><span class="line"><span class="built_in">Promise</span>.all(promises)</span><br><span class="line">    .then(<span class="function"><span class="params">bodies</span> =&gt;</span> &#123; <span class="comment">/* 处理得到的字符串数组 */</span> &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.error(e));</span><br></pre></td></tr></table></figure>

<p><code>Promise.all()</code> 输入数组可以包含期约对象和非期约值，若为非期约值，会被当作一个已兑现期约的值，复制到数组中。由此函数返回的期约会在任何一个输入期约被拒绝时拒绝</p>
<p>ES2020中，<code>Promise.allSettled()</code> 与 <code>Promise.all()</code> 一样，但是，<code>Promise.allSettled()</code> 永远不拒绝返回的期约，而是会等所有输入期约全部落定后兑现</p>
<p><code>Promise.allSettled()</code> 返回的期约解决为一个对象数组，其中每个对象都对应一个输入期约，且都有一个 <code>status</code> 属性</p>
<ul>
<li>若属性值为 <code>fulfilled</code>，则该对象还会有一个 <code>value</code> 属性，包含兑现的值</li>
<li>若属性值为 <code>rejected</code>，则该对象还会有一个 <code>reason</code> 属性，包含对应期约的错误或拒绝理由</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.allSettled([<span class="built_in">Promise</span>.resolve(<span class="number">1</span>), <span class="built_in">Promise</span>.reject(<span class="number">2</span>), <span class="number">3</span>])</span><br><span class="line">    .then(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">        results[<span class="number">0</span>]    <span class="comment">// =&gt; &#123;status: &quot;fulfilled&quot;, value: 1&#125;</span></span><br><span class="line">        results[<span class="number">1</span>]    <span class="comment">// =&gt; &#123;status: &quot;rejected&quot;, reason: 2&#125;</span></span><br><span class="line">        results[<span class="number">2</span>]    <span class="comment">// =&gt; &#123;status: &quot;fulfilled&quot;, value: 3&#125;</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>若想同时运行多个期约，但只关心第一个兑现的值，可以使用 <code>Promise.race()</code>，<code>Promise.race()</code> 返回一个期约，这个期约会在输入数组的期约有一个兑现或拒绝时马上兑现或拒绝（或者，若输入数组中有非期约值，直接返回第一个非期约值）</p>
<h3 id="创建期约"><a href="#创建期约" class="headerlink" title="创建期约"></a>创建期约</h3><p>前面使用的是浏览器内置的返回期约的函数，可以创建自己的基于期约的API</p>
<h4 id="基于其他期约的期约"><a href="#基于其他期约的期约" class="headerlink" title="基于其他期约的期约"></a>基于其他期约的期约</h4><p>给定一个期约，调用 <code>.then()</code> 就可以创建（并返回）一个新期约</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以已有的fetch()函数为起点，实现getJSON()</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJSON</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fetch(url).then(<span class="function"><span class="params">response</span> =&gt;</span> response.json());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以getJSON()作为初始期约的来源</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHighScore</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getJSON(<span class="string">&quot;/api/user/profile&quot;</span>).then(<span class="function"><span class="params">profile</span> =&gt;</span> profile.highScore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="基于同步值的期约"><a href="#基于同步值的期约" class="headerlink" title="基于同步值的期约"></a>基于同步值的期约</h4><p>若需要实现一个已有的基于期约的 API，并从一个函数返回期约，尽管执行的计算不涉及异步操作，在这种情况下，可以使用<code>Promise.resolve()</code> 和 <code>Promise.reject()</code></p>
<p><code>Promise.resolve()</code> 接收一个值作为参数，并返回一个会立即（但异步）以该值兑现的期约</p>
<p><code>Promise.reject()</code> 接收一个参数，并返回一个以该参数作为理由拒绝的期约</p>
<p>上面两个静态方法返回的期约在被返回时并未兑现或拒绝，但它们会在当前同步代码块运行结束后立即兑现或拒绝</p>
<p>在一个异步函数中包含同步执行的代码，通过以上两个方法来处理这些同步操作的值是很常见的</p>
<h4 id="从头创建期约"><a href="#从头创建期约" class="headerlink" title="从头创建期约"></a>从头创建期约</h4><p>可以使用 <code>Promise()</code> 构造函数来创建一个新期约对象，而且可以完全控制这个新期约</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于期约的wait()函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">duration</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 创建并返回新期约</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;   <span class="comment">// 这两个函数控制期约</span></span><br><span class="line">        <span class="comment">// 如果参数无效，拒绝期约</span></span><br><span class="line">        <span class="keyword">if</span>(duration &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Time travel not yet implemented&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则，异步等待，然后解决期约</span></span><br><span class="line">        <span class="comment">// setTimeout调用resolve()时未传参，意味着新期约会以undefined值兑现</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(resolve, duration);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用来控制 <code>Promise()</code> 构造函数创建的期约对象命运的函数为 <code>resolve()</code> 和 <code>reject()</code>，若把一个期约传给 <code>resolve()</code>，返回的期约会解决为该新期约，但是通常这里都传一个非期约值，这个值会兑现返回的期约</p>
<p>在 Node 中使用 <code>getJSON()</code> 函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步getJSON()函数</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJSON</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 创建并返回一个新期约</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 向指定的URL发送一个HTTP GET请求</span></span><br><span class="line">        request = http.get(url, <span class="function"><span class="params">response</span> =&gt;</span> &#123;   <span class="comment">// 收到响应时调用</span></span><br><span class="line">            <span class="comment">// 如果HTTP状态码不对，拒绝这个期约</span></span><br><span class="line">            <span class="keyword">if</span>(response.statusCode !== <span class="number">200</span>)&#123;</span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`HTTP status <span class="subst">$&#123;response.statusCode&#125;</span>`</span>));</span><br><span class="line">                response.resume();    <span class="comment">// 这样不会导致内存泄漏</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果响应头不对</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(response.headers[<span class="string">&quot;content-type&quot;</span>] !== <span class="string">&quot;application/json&quot;</span>)&#123;</span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Invalid content-type&quot;</span>));</span><br><span class="line">                response.resume();    <span class="comment">// 不会造成内存泄漏</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 否则，注册事件处理程序读取响应体</span></span><br><span class="line">                <span class="keyword">let</span> body = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                response.setEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                response.on(<span class="string">&quot;data&quot;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> &#123; body += chunk; &#125;);</span><br><span class="line">                response.on(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// 接收完全部响应体后，尝试解析</span></span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="keyword">let</span> parsed = <span class="built_in">JSON</span>.parse(body);</span><br><span class="line">                        <span class="comment">// 如果解析成功，兑现期约</span></span><br><span class="line">                        resolve(parsed);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">                        <span class="comment">// 若解析失败，拒绝期约</span></span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 如果收到响应之前请求失败（如网络故障），拒绝期约</span></span><br><span class="line">        request.on(<span class="string">&quot;error&quot;</span>, <span class="function"><span class="params">error</span> =&gt;</span>&#123;</span><br><span class="line">            reject(error);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="串行期约"><a href="#串行期约" class="headerlink" title="串行期约"></a>串行期约</h3><p>若要按顺序运行任意数量的期约需要动态构建期约链</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抓取URL数组，为了避免网络过载，一次只抓取一个URL</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchSequentially</span>(<span class="params">urls</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 抓取URL时，要把响应体保存在这里</span></span><br><span class="line">    <span class="keyword">const</span> bodies = [];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个函数返回一个期约，它只抓取一个URL响应体</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fetchOne</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fetch(url)</span><br><span class="line">            .then(<span class="function"><span class="params">response</span> =&gt;</span> response.text())</span><br><span class="line">        	.then(<span class="function"><span class="params">body</span> =&gt;</span> &#123;</span><br><span class="line">           		<span class="comment">// 把响应体保存在数组，故意省略返回值，返回undefined</span></span><br><span class="line">            	bodies.push(body);</span><br><span class="line">        	&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从一个立即（以undefined值）兑现的期约开始</span></span><br><span class="line">    <span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve(<span class="literal">undefined</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 现在循环目标URL，构建任意长度的期约链</span></span><br><span class="line">    <span class="comment">// 链的每个环节都会拿取一个URL的响应体</span></span><br><span class="line">    <span class="keyword">for</span>(url <span class="keyword">of</span> urls)&#123;</span><br><span class="line">        p = p.then(<span class="function">() =&gt;</span> fetchOne(url));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 期约链的最后一个期约兑现后，响应体数组（bodies）已经就绪</span></span><br><span class="line">    <span class="comment">// 可以将这个bodies数组通过期约返回，注意，这里为包含任何错误处理程序</span></span><br><span class="line">    <span class="comment">// 希望将错误传播给调用者</span></span><br><span class="line">    <span class="keyword">return</span> p.then(<span class="function">() =&gt;</span> bodies);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上述函数定义后，就可以如前面使用 <code>Promise.all()</code> 并行抓取，按顺序依次抓取每个URL</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetchSequentially(urls)</span><br><span class="line">	.then(<span class="function"><span class="params">bodies</span> =&gt;</span> &#123; <span class="comment">/*处理得到的字符串数组*/</span> &#125;)</span><br><span class="line">	.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.error(e));</span><br></pre></td></tr></table></figure>

<p><code>fetchSequentially()</code> 函数首先会创建一个返回后立即兑现的期约，然后基于这个初始期约构建一个线性的长期约链并返回链中的最后一个期约，类似于多米诺骨牌形式的期约链</p>
<p>还有另一种实现方法，不是事先创建期约，而是让每个期约的回调函数创建并返回下一个期约，类似于俄罗斯套娃的相互嵌套的期约</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个函数接收一个输入值数组和一个promiseMaker函数</span></span><br><span class="line"><span class="comment">// 对输入数组中的任何值x，promiseMaker(x)都应该返回</span></span><br><span class="line"><span class="comment">// 一个兑现为输出值的期约。这个函数返回一个期约，该期约</span></span><br><span class="line"><span class="comment">// 最终会兑现为一个包含计算得到的输出值的数组</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// promiseSequence()不是一次创建所有期约然后让它们</span></span><br><span class="line"><span class="comment">// 并行运行，而是每次只运行一个期约，直到上一个期约兑现</span></span><br><span class="line"><span class="comment">// 之后，才会调用promiseMaker()计算下一个值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseSequence</span>(<span class="params">inputs, promiseMaker</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 为数组创建一个可以修改的私有副本</span></span><br><span class="line">    inputs = [...inputs];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这是要用作期约回调的函数，它的伪递归魔术是核心逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleNextInput</span>(<span class="params">outputs</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inputs.length === <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果没有输入值了，则返回输出值的数组</span></span><br><span class="line">            <span class="comment">// 这个数组最终兑现这个期约，以及所有之前</span></span><br><span class="line">            <span class="comment">// 已经解决但尚未兑现的期约</span></span><br><span class="line">            <span class="keyword">return</span> outputs;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 如果还有要处理的输入值，那么我们将返回</span></span><br><span class="line">            <span class="comment">// 一个期约对象，把当前期约解决为一个来自新期约的未来值</span></span><br><span class="line">            <span class="keyword">let</span> nextInput = inputs.shift();     <span class="comment">// 取得下一个输入值</span></span><br><span class="line">            <span class="keyword">return</span> promiseMaker(nextInput)      <span class="comment">// 计算下一个输出值</span></span><br><span class="line">            	<span class="comment">// 然后用这个新输出值创建一个新输出值的数组</span></span><br><span class="line">           		.then(<span class="function"><span class="params">output</span> =&gt;</span> outputs.concat(output))</span><br><span class="line">            	<span class="comment">// 然后“递归”，传入新的、更长的输出值的数组</span></span><br><span class="line">            	.then(handleNextInput);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从一个以空数组兑现的期约开始</span></span><br><span class="line">    <span class="comment">// 使用上面的函数作为它的回调</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve([]).then(handleNextInput);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用器抓取多个URL的响应</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入一个URL，返回一个以改URL的响应体文本兑现的期约</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchBody</span>(<span class="params">url</span>)</span>&#123; <span class="keyword">return</span> fetch(url).then(<span class="function"><span class="params">r</span> =&gt;</span> r.text()); &#125;</span><br><span class="line"><span class="comment">// 使用它依次抓取一批URL的响应体</span></span><br><span class="line">promiseSequence(urls, fetchBody)</span><br><span class="line">    .then(<span class="function"><span class="params">bodies</span> =&gt;</span> &#123; <span class="comment">/* 处理字符串数组 */</span> &#125;)</span><br><span class="line">    .catch(<span class="built_in">console</span>.error);</span><br></pre></td></tr></table></figure>







<h2 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h2><p>ES2017 新增两个关键字 <code>async</code> 和 <code>await</code>，代表异步 JavaScript 编程范式的迁移</p>
<p> <code>async</code> 和 <code>await</code> 接收基于期约的高校代码并且隐藏期约，让异步代码向低效阻塞的同步代码一样容易理解和推理</p>
<h3 id="await表达式"><a href="#await表达式" class="headerlink" title="await表达式"></a>await表达式</h3><p><code>await</code> 关键字接收一个期约并将其转换为一个返回值或一个抛出的异常</p>
<p>通常不会使用 <code>await</code> 来接收一个保存期约的变量，更多的将其放在一个会返回期约的函数调用前面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&quot;/api/user/profile&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> profile = <span class="keyword">await</span> response.json();</span><br></pre></td></tr></table></figure>

<p><code>await</code> 关键字并不会导致你的程序阻塞或者在指定的期约落定前什么都不做，代码依然是异步的，<code>await</code> 只是掩盖了这个事实，即任何使用 <code>await</code> 的代码本身都是异步的</p>
<h3 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h3><p>任何使用 <code>await</code> 的代码本身都是异步的，因此，只能在以 <code>async</code> 关键字声明的函数内部使用 <code>await</code> 关键字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重写gitHighScore()函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">gitHighScore</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&quot;/api/user/profile&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> profile = <span class="keyword">await</span> response.json();</span><br><span class="line">    <span class="keyword">return</span> profile.highScore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将函数声明为 <code>async</code> 意味着该函数的返回值将是一个期约，即便函数体中不出现期约相关的代码</p>
<ul>
<li>若 <code>async</code> 函数正常返回，则作为该函数真正返回值的期约对象将解决为这个明显的返回值</li>
<li>若 <code>async</code> 函数抛出异常，则返回的期约对象将以该异常被拒绝</li>
</ul>
<p>可以对任何函数使用 <code>async</code> 关键字</p>
<h3 id="等候多个期约"><a href="#等候多个期约" class="headerlink" title="等候多个期约"></a>等候多个期约</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用async重写getJSON()函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getJSON</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">    <span class="keyword">let</span> body = <span class="keyword">await</span> response.json();</span><br><span class="line">    <span class="keyword">return</span> body;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用这个函数抓取两个JSON值</span></span><br><span class="line"><span class="keyword">let</span> value1 = <span class="keyword">await</span> getJSON(url1);</span><br><span class="line"><span class="keyword">let</span> value2 = <span class="keyword">await</span> getJSON(url2);</span><br></pre></td></tr></table></figure>

<p>上述代码的问题在于它不必顺序执行，必须等到抓取第一个 URL 的结果之后才会开始抓取第二个 URL 的值</p>
<p>若第二个 URL 并不依赖从第一个 URL 抓取的值，则应该尝试同时抓取两个值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [value1, value2] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getJSON(url1), getJSON(url2)]);</span><br></pre></td></tr></table></figure>







<h2 id="异步迭代"><a href="#异步迭代" class="headerlink" title="异步迭代"></a>异步迭代</h2><p>期约只适合单次运行的异步计算，不适合与重复性异步事件来源一起使用，由于一个期约无法用于连续的异步事件，我们也不能使用常规的 <code>async</code> 函数和 <code>await</code> 语句来处理事件</p>
<p>ES2018 为此提供了解决方法——异步迭代器。异步迭代器基于期约，配合 <code>for/await</code> 语句使用</p>
<h3 id="for-await循环"><a href="#for-await循环" class="headerlink" title="for/await循环"></a>for/await循环</h3><p>Node 12 的可读流实现了异步迭代</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">parseFile</span>(<span class="params">filename</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stream = fs.createReadStream(filename, &#123; <span class="attr">encoding</span>: <span class="string">&quot;utf-8&quot;</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span> <span class="function"><span class="title">await</span>(<span class="params"><span class="keyword">let</span> chunk <span class="keyword">of</span> stream</span>)</span>&#123;</span><br><span class="line">        parseChunk(chunk);    <span class="comment">// 假设parseChunk()是在其他地方定义的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异步迭代器会产生一个期约，<code>for/await</code> 循环等待该期约兑现，将兑现值赋给循环变量，然后在运行循环体</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有一个URL数组</span></span><br><span class="line"><span class="keyword">const</span> urls = [url1, url2, url3];</span><br><span class="line"><span class="comment">// 对每个URL调用fetch()取得一个期约的数组</span></span><br><span class="line"><span class="keyword">const</span> promises = urls.map(<span class="function"><span class="params">url</span> =&gt;</span> fetch(url));</span><br><span class="line"><span class="comment">// 循环数组中的URL</span></span><br><span class="line"><span class="keyword">for</span> <span class="function"><span class="title">await</span>(<span class="params"><span class="keyword">const</span> response <span class="keyword">of</span> promises</span>)</span>&#123;</span><br><span class="line">    handle(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="异步迭代器"><a href="#异步迭代器" class="headerlink" title="异步迭代器"></a>异步迭代器</h3><p>异步迭代器与常规迭代器类似，有两个重要区别</p>
<ul>
<li>异步可迭代对象以符号名字 <code>Symbol.asyncIterator</code> 而非 <code>Symbol.iterator</code> 实现一个方法</li>
<li>异步迭代器的 <code>next()</code> 方法返回一个期约，解决为一个迭代器结果对象，而不是直接返回一个迭代器结果对象</li>
</ul>
<h3 id="异步生成器"><a href="#异步生成器" class="headerlink" title="异步生成器"></a>异步生成器</h3><p>可以使用声明为 <code>async</code> 的生成器函数来实现异步生成器，通过 <code>yield</code> 生成的值会自动包装到期约中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个基于期约的包装函数，包装setTimeout()以实现等待</span></span><br><span class="line"><span class="comment">// 返回一个期约，这个期约会在指定的毫秒数之后兑现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">elapsedTime</span>(<span class="params">ms</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, ms));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个异步迭代器函数，按照固定的时间间隔</span></span><br><span class="line"><span class="comment">// 递增并生成指定（或无穷）个数的计数器</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">clock</span>(<span class="params">interval, max = <span class="literal">Infinity</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> count = <span class="number">1</span>; count &lt;= max; count++)&#123;    <span class="comment">// 常规for循环</span></span><br><span class="line">    	<span class="keyword">await</span> elapsedTime(interval);              <span class="comment">// 等待时间流逝</span></span><br><span class="line">        <span class="keyword">yield</span> count;                              <span class="comment">// 生成计数器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个测试函数，使用异步迭代器和for/await</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;                            <span class="comment">// 使用async声明，以便使用for/await</span></span><br><span class="line">    <span class="keyword">for</span> <span class="function"><span class="title">await</span>(<span class="params"><span class="keyword">let</span> tick <span class="keyword">of</span> clock(<span class="number">300</span>, <span class="number">100</span>)</span>)</span>&#123;       <span class="comment">// 循环100次，每次间隔300ms</span></span><br><span class="line">        <span class="built_in">console</span>.log(tick);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实现异步迭代器"><a href="#实现异步迭代器" class="headerlink" title="实现异步迭代器"></a>实现异步迭代器</h3><p>直接实现异步迭代器，需要包含一个 <code>Symbol.asyncIterator()</code>  方法的对象，该方法要返回一个 <code>next()</code> 方法的对象，这个 <code>next()</code> 方法要返回解决为一个迭代器结果对象的期约</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重写clock()函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clock</span>(<span class="params">interval, max = <span class="literal">Infinity</span></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 一个setTimeout的期约版，可以实现等待</span></span><br><span class="line">    <span class="comment">// 注意参数是一个绝对时间而非时间间隔</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">until</span>(<span class="params">time</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, time - Data.now()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回一个异步可迭代对象</span></span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        <span class="attr">startTime</span>: <span class="built_in">Date</span>.now(),     <span class="comment">// 记住开始时间</span></span><br><span class="line">        <span class="attr">count</span>: <span class="number">1</span>,                  <span class="comment">// 记住第几次迭代</span></span><br><span class="line">        asyns <span class="function"><span class="title">next</span>(<span class="params"></span>)</span>&#123;              <span class="comment">// 方法使其称为迭代器</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.count &gt; max)&#123;  <span class="comment">// 是否结束</span></span><br><span class="line">                <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>&#125;;   <span class="comment">// 结束后的迭代结果</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算下次迭代什么时间开始</span></span><br><span class="line">            <span class="keyword">let</span> targetTime = <span class="built_in">this</span>.startTime + <span class="built_in">this</span>.count * interval;</span><br><span class="line">            <span class="comment">// 等待该时间到来</span></span><br><span class="line">            <span class="keyword">await</span> until(targetTime);</span><br><span class="line">            <span class="comment">// 在迭代结果对象中返回计数器的值</span></span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="built_in">this</span>.count++ &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 这个方法表示迭代器对象同时也是一个可迭代对象</span></span><br><span class="line">        [<span class="built_in">Symbol</span>.asyncIterator]()&#123; <span class="keyword">return</span> <span class="built_in">this</span>; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异步迭代器的优点是允许我们表示异步事件流或数据流</p>
<p>上述的 <code>clock()</code> 函数写起来相当简单，，因为其中的异步源为 <code>setTimeout()</code> 调用，但是在面对其他异步源时，如事件处理程序的触发，实现异步迭代器就困难许多。通常只有一个事件处理程序响应事件，但每次调用迭代器的 <code>next()</code> 方法都必须返回唯一的期约，在第一个期约解决之前很有可能出现多次调用 <code>next()</code> 的情况，即任何异步迭代器方法都必须能在内部维护一个期约队列，让期约按照异步事件发生的顺序依次解决</p>
<p>可以将期约队列的逻辑封装到一个 <code>AsyncQueue</code> 类中，基于这个类编写异步迭代器</p>
<p><code>AsyncQueue</code> 类包含一个队列类应有的 <code>enqueue()</code> 和 <code>dequeue()</code> 方法，<code>dequeue()</code> 方法返回一个期约而不是一个实际的值，因此尚未调用 <code>enqueue()</code> 之前调用 <code>dequeue()</code> 方法是没问题的。这个里欸 <code>AsyncQueue</code> 类也是一个异步迭代器，与 <code>for/await</code> 配合使用，循环体在每次入队一个新值运行一次</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个异步可迭代队列类。使用enqueue()添加值，使用dequeue()移除值</span></span><br><span class="line"><span class="comment"> * dequeue()返回一个期约意味着值可以在入队之前出队。这个类实现了</span></span><br><span class="line"><span class="comment"> * [Symbol.asyncIterator]和next()，可以与for/await配合使用</span></span><br><span class="line"><span class="comment"> * （这个循环在调用close()方法前不会终止）</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncQueue</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 已经入队尚未出队的值保存在这里</span></span><br><span class="line">        <span class="built_in">this</span>.values = [];</span><br><span class="line">        <span class="comment">// 如果期约出队时它们对应的值尚未入队，</span></span><br><span class="line">        <span class="comment">// 就把那些期约的解决方法保存在这里</span></span><br><span class="line">        <span class="built_in">this</span>.resolvers = [];</span><br><span class="line">        <span class="comment">// 一旦关闭，任何值不能再入队</span></span><br><span class="line">        <span class="comment">// 也不会再返回任何未兑现的期约</span></span><br><span class="line">        <span class="built_in">this</span>.closed = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">enqueue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.closed)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;AsyncQueue closed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.resolvers.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果这个值已经有对应的期约，则解决该期约</span></span><br><span class="line">            <span class="keyword">const</span> resolve = <span class="built_in">this</span>.resolvers.shift();</span><br><span class="line">            resolve(value);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 否则，排队</span></span><br><span class="line">            <span class="built_in">this</span>.values.push(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">dequeue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.values.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果有一个排队的值，为其返回一个解决期约</span></span><br><span class="line">            <span class="keyword">const</span> value = <span class="built_in">this</span>.values.shift();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(value);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.closed)&#123;</span><br><span class="line">            <span class="comment">// 如果没有排队的值，而且队列已关闭</span></span><br><span class="line">            <span class="comment">// 返回一个解决未EOS（流终止）标记的期约</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(AsyncQueue.EOS);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 否则，返回一个未解决的期约，</span></span><br><span class="line">            <span class="comment">// 将解决方法排队，以便后面使用</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123; </span><br><span class="line">                <span class="built_in">this</span>.resolvers.push(resolve); </span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">closed</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 一旦关闭，任何值都不能再入队</span></span><br><span class="line">        <span class="comment">// 因此以EOS标记解决所有待决期约</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">this</span>.resolvers.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.resolvers.shift()(AsyncQueue.EOS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.closed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义这个方法，让这个类为异步可迭代对象</span></span><br><span class="line">    [<span class="built_in">Symbol</span>.asyncIterator]()&#123; <span class="keyword">return</span> <span class="built_in">this</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义next()方法，让类成为异步迭代器</span></span><br><span class="line">    <span class="comment">// dequeue()返回的期约会解决为一个值</span></span><br><span class="line">    <span class="comment">// 或者在关闭时解决为EOS标记，这里需要</span></span><br><span class="line">    <span class="comment">// 返回一个解决为迭代器结果对象的期约</span></span><br><span class="line">    <span class="function"><span class="title">next</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.dequeue()</span><br><span class="line">        	.then(<span class="function"><span class="params">value</span> =&gt;</span> (value === AsyncQueue.EOS)</span><br><span class="line">                 			? &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">                 			: &#123;<span class="attr">value</span>: value, <span class="attr">done</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dequeue()方法返回的标记值，在关闭时表示“流终止”</span></span><br><span class="line">AsyncQueue.EOS = <span class="built_in">Symbol</span>(<span class="string">&quot;end-of-stream&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>使用 <code>AsyncQueue</code> 产生一个浏览器事件流，通过 <code>for/await</code> 循环来处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把指定文档元素上指定类型的事件推入一个AsyncQueue对象</span></span><br><span class="line"><span class="comment">// 然后返回这个队列，以便将其作为事件流来使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eventStream</span>(<span class="params">elt, type</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> q = <span class="keyword">new</span> AsyncQueue();                    <span class="comment">// 创建一个队列</span></span><br><span class="line">    elt.addEventListener(type, <span class="function"><span class="params">e</span> =&gt;</span> q.enqueue(e)); <span class="comment">// 入队事件</span></span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">handleKeys</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 取得一个keypress事件流，对每个事件都执行一次循环</span></span><br><span class="line">    <span class="keyword">for</span> <span class="function"><span class="title">await</span>(<span class="params"><span class="keyword">const</span> event <span class="keyword">of</span> eventStream(<span class="built_in">document</span>, <span class="string">&quot;keypress&quot;</span>)</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(event.key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端学习</tag>
      </tags>
  </entry>
  <entry>
    <title>传输层</title>
    <url>/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<h2 id="概述和传输层服务"><a href="#概述和传输层服务" class="headerlink" title="概述和传输层服务"></a>概述和传输层服务</h2><p>传输服务和协议</p>
<ul>
<li>为运行在不同主机上的应用进程提供逻辑通信</li>
<li>传输协议运行在端系统<ul>
<li>发送方：将应用层的报文分成报文段，然后传递给网络层</li>
<li>接收方：将报文段重组成报文，然后传递给应用层</li>
</ul>
</li>
<li>有多个传输层协议可供应用选择<ul>
<li>Internet：TCP和UDP</li>
</ul>
</li>
</ul>
<span id="more"></span>

<p>传输层与网络层的关系</p>
<ul>
<li><p>网络层服务：主机之间的逻辑通信</p>
</li>
<li><p>传输层服务：进程间的逻辑通信</p>
<ul>
<li><p>依赖于网络层的服务</p>
<ul>
<li>延时、带宽</li>
</ul>
</li>
<li><p>对网络层的服务进行增强</p>
<ul>
<li><p>数据丢失、顺序混乱</p>
</li>
<li><p>加密</p>
<blockquote>
<p>有些服务是可以加强的：不可靠 -&gt; 可靠；安全 </p>
<p>但有些服务是不可以被加强的：带宽，延迟</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Internet传输层协议</p>
<ul>
<li><p>可靠的、保序的传输：TCP</p>
<ul>
<li>多路复用、解复用</li>
<li>拥塞控制</li>
<li>流量控制</li>
<li>建立连接</li>
</ul>
</li>
<li><p>不可靠、不保序的传输：UDP</p>
<ul>
<li><p>多路复用、解复用</p>
</li>
<li><p>没有为尽力而为的IP服务添加更多的其它额外服务</p>
<blockquote>
<p>IP的服务模型为尽力而为交付服务（best-effort delivery service），即IP尽“最大努力”在通信主机之间交付报文段，但不做任何确保。因此IP被称为不可靠服务（unreliable service）</p>
</blockquote>
</li>
</ul>
</li>
<li><p>都不提供的服务</p>
<ul>
<li>延时保证</li>
<li>带宽保证</li>
</ul>
</li>
</ul>
<h2 id="多路复用-解复用"><a href="#多路复用-解复用" class="headerlink" title="多路复用/解复用"></a>多路复用/解复用</h2><p> 在发送方主机多路复用：从多个套接字接收来自多个进程的报文，根据套接字对应的IP地址和端口号等信息对报文段用头部加以封装 (该头部信息用于以后的解复用)</p>
<p>在接收方主机多路解复用：根据报文段的头部信息中的IP地址和端口号将接收到的报文段发给正确的套接字(和对应的应用进程)</p>
<p>多路解复用工作原理</p>
<ul>
<li>解复用作用：TCP或者UDP实体采用哪些信息，将报文段的数据部分交给正确的socket，从而交给正确的进程</li>
<li>主机收到IP数据报<ul>
<li>每个数据报有源IP地址和目标地址</li>
<li>每个数据报承载一个传输层报文段</li>
<li>每个报文段有一个源端口号和目标端口号 (特定应用有著名的端口号) </li>
</ul>
</li>
<li>主机联合使用IP地址和端口号将报文段发送给合适的套接字</li>
</ul>
<p>无连接(UDP)多路解复用</p>
<ol>
<li>创建套接字</li>
<li>在接收端，UDP套接字用二元组标识 (目标IP地址、目标端口号)</li>
<li>当主机收到UDP报文段<ul>
<li>检查报文段的目标端口号</li>
<li>用该端口号将报文段定位给套接字</li>
</ul>
</li>
<li>如果两个不同源IP地址/源端口号的数据报，但是有相同的目标IP地址和端口号，则被定位到相同的套接字</li>
</ol>
<p>面向连接(TCP)的多路复用</p>
<ul>
<li>TCP套接字:四元组本地标识<ul>
<li>源IP地址</li>
<li>源端口号</li>
<li>目的IP地址</li>
<li>目的端口号</li>
</ul>
</li>
<li>解复用：接收主机用这四个值来将数据报定位到合适的套接字</li>
<li>服务器能够在一个TCP 端口上同时支持多个TCP套接字<ul>
<li>每个套接字由其四元组标识（有不同的源IP和源Port）</li>
</ul>
</li>
<li>Web服务器对每个连接客户端有不同的套接字<ul>
<li>非持久对每个请求有不同的套接字</li>
</ul>
</li>
</ul>
<p>面向连接的多路复用：多线程Web Server</p>
<ul>
<li>一个进程下面可能有多个线程：由多个线程分别为客户提供服务</li>
<li>在这个场景下，还是根据4元组决定将报文段内容划分在同一个进程下的不同线程</li>
<li>解复用到不同线程</li>
</ul>
<h2 id="无连接传输：UDP"><a href="#无连接传输：UDP" class="headerlink" title="无连接传输：UDP"></a>无连接传输：UDP</h2><p>“尽力而为”的服务，报文段可能<strong>丢失</strong>或<strong>送到应用进程的报文段乱序</strong></p>
<p>无连接特点</p>
<ul>
<li>UDP发送端和接收端之间没有握手</li>
<li>每个UDP报文段都被独立地处理</li>
</ul>
<p>UDP 被用于流媒体（丢失不敏感， 速率敏感、应用可控制传输速率）、DNS、SNMP</p>
<p>在UDP上可行可靠传输，则</p>
<ul>
<li>在应用层增加可靠性</li>
<li>应用特定的差错恢复</li>
</ul>
<p><strong>UDP报文段格式：</strong></p>
<p>![流程图 (2)](传输层/流程图 (2)-16406727379761.png)</p>
<p><strong>UDP存在的必要性</strong></p>
<ul>
<li>不建立连接（会增加延时 ）</li>
<li>简单：在发送端和接收端没有连接状态</li>
<li>报文段的头部很小（开销小）</li>
<li>无拥塞控制和流量控制：UDP可以尽可能快的发送报文段</li>
</ul>
<p><strong>UDP校验和</strong></p>
<p>目标： 检测在被传输报文段中的差错（如比特反转）</p>
<p>发送方</p>
<ul>
<li>将报文段的内容视为16比特的整数</li>
<li>校验和：报文段的加法和（1的补运算）</li>
<li>发送方将校验和放 UDP的校验和字段</li>
</ul>
<p>接收方</p>
<ul>
<li>计算接收到的报文段的校验和</li>
<li>检查计算出的校验和与校验和字段的内容是否相等<ul>
<li>不相等––检测到差错</li>
<li>相等––没有检测到差错 ，但也许还是有差错，如残存错误</li>
</ul>
</li>
</ul>
<p>校验和的计算：</p>
<ul>
<li>当数字相加时，在最高位的进位要回卷，再加到结果上</li>
<li>最终得到的检验码是计算的反码</li>
<li>目标端：校验范围+校验和=1111111111111111 则通过校验</li>
</ul>
<h2 id="可靠数据传输（rdt）原理"><a href="#可靠数据传输（rdt）原理" class="headerlink" title="可靠数据传输（rdt）原理"></a>可靠数据传输（rdt）原理</h2><p>rdt（可靠数据传输协议）在应用层、传输层和数据链路层都很重要</p>
<p>信道的不可靠特点决定了可靠数据传输协议的复杂性</p>
<p>服务实现模型：</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820075814869.png" alt="image-20210820075814869"></p>
<p>可靠数据传输：问题描述</p>
<ul>
<li><p>渐增式地开发可靠数据传输协议（ rdt ）的发送方和接收方</p>
</li>
<li><p>只考虑单向数据传输，但控制信息是双向流动的</p>
</li>
<li><p>双向的数据传输问题实际上是2个单向数据传输问题的综合</p>
</li>
<li><p>使用有限状态机 (FSM) 来描述发送方和接收方</p>
<blockquote>
<p>有限状态机是一种描述形式</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820080351026.png" alt="image-20210820080351026"></p>
</blockquote>
</li>
</ul>
<p>Rdt1.0： 在可靠信道上的可靠数据传输</p>
<ul>
<li><p>下层的信道是完全可靠的</p>
<ul>
<li>没有比特出错</li>
<li>没有分组丢失</li>
</ul>
</li>
<li><p>发送方和接收方的FSM</p>
<ul>
<li><p>发送方将数据封装发送到下层信道</p>
</li>
<li><p>接收方从下层信道接收数据，解封装</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820080540803.png" alt="image-20210820080540803"></p>
</li>
</ul>
</li>
</ul>
<p>Rdt2.0：具有比特差错的信道</p>
<ul>
<li><p>下层信道可能会出错：将分组中的比特翻转</p>
<ul>
<li>用校验和来检测比特差错</li>
</ul>
</li>
<li><p>问题：怎样从差错中恢复</p>
<ul>
<li>确认（ACK）：接收方显式地告诉发送方分组已被正确接收</li>
<li>否定确认（NAK）: 接收方显式地告诉发送方分组发生了差错<ul>
<li>发送方收到NAK后，发送方重传分组</li>
</ul>
</li>
</ul>
</li>
<li><p>rdt2.0中的新机制：采用差错控制编码进行差错检测</p>
<ul>
<li>发送方差错控制编码、缓存</li>
<li>接收方使用编码检错</li>
<li>接收方的反馈：控制报文（ACK，NAK），由接收方发给发送方</li>
<li>发送方收到反馈相应的动作</li>
</ul>
</li>
<li><p>基于这样重传机制的可靠数据传输协议称为自动重传请求（ARQ）协议</p>
</li>
<li><p>FSM描述</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820081615213.png" alt="image-20210820081615213"></p>
</li>
</ul>
<p>rdt2.0存在致命缺陷则 -&gt; rdt2.1</p>
<p>如果ACK/NAK出错？</p>
<ul>
<li>发送方不知道接收方发生了什么事情</li>
<li>发送方如何做<ul>
<li>若重传可能重复</li>
<li>若不重传可能死锁(或出错) </li>
</ul>
</li>
<li>需要引入新的机制：序号</li>
</ul>
<p>处理重复</p>
<ul>
<li>发送方在每个分组中加入序号</li>
<li>如果ACK/NAK出错，发送方重传当前分组</li>
<li>接收方丢弃（不发给上层）重复分组</li>
</ul>
<p>停止等待协议：发送方发送一个分组， 然后等待接收方的应答</p>
<p>FSM描述：</p>
<ul>
<li><p>发送方处理出错的ACK/NAK</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820082340128.png" alt="image-20210820082340128"></p>
</li>
<li><p>接收方处理出错的ACK/NAK</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820082514757.png" alt="image-20210820082514757"></p>
</li>
</ul>
<p>rdt2.1发送方</p>
<ul>
<li>在分组中加入序列号</li>
<li>两个序列号（0，1）就足够了<ul>
<li>一次只发送一个未经确认的分组</li>
</ul>
</li>
<li>必须检测ACK/NAK是否出错（需要EDC）</li>
<li>状态数变成了两倍<ul>
<li>必须记住当前分组的序列号为0还是1</li>
</ul>
</li>
</ul>
<p>rdt2.1接收方</p>
<ul>
<li>必须检测接收到的分组是否是重复的<ul>
<li>状态会指示希望接收到的分组的序号为0还是1</li>
</ul>
</li>
<li>注意：接收方并不知道发送方是否正确收到了其ACK/NAK<ul>
<li>没有安排确认的确认</li>
</ul>
</li>
</ul>
<p>rdt2.1运行过程：</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820083417442.png" alt="image-20210820083417442"></p>
<p>接收方不知道它最后发送的ACK/NAK是否被正确地收到</p>
<ul>
<li>发送方不对收到的ack/nak给确认，没有所谓的确认的确认</li>
<li>接收方发送ack，如果后面接收方收到的是<ul>
<li>老分组p0，则ack 错误</li>
<li>下一个分组P1，则ack正确</li>
</ul>
</li>
</ul>
<p>rdt2.2：无NAK（NAK free）的协议</p>
<ul>
<li><p>功能同rdt2.1，但只使用ACK(ack 要编号）</p>
</li>
<li><p>接收方对<strong>最后</strong>正确接收的分组发ACK，以替代NAK</p>
<ul>
<li>接收方必须显式地包含被正确接收分组的序号</li>
</ul>
</li>
<li><p>当收到重复的ACK（如：再次收到ack0）时，发送方与收到NAK采取相同的动作：重传当前分组</p>
</li>
<li><p>为后面的一次发送多个数据单位做一个准备</p>
<ul>
<li>一次能够发送多个</li>
<li>使用对前一个数据单位的ACK，代替本数据单位的NAK</li>
<li>确认信息减少一半，协议处理简单</li>
</ul>
</li>
<li><p>运行过程</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820083926717.png" alt="image-20210820083926717"></p>
</li>
</ul>
<p>rdt3.0：具有比特差错和分组丢失的信道</p>
<p>问题：若下层信道可能会丢失分组（数据或ACK）</p>
<p>解决方法：发送方等待ACK一段合理的时间</p>
<blockquote>
<p>链路层的timeout时间确定的 </p>
<p>传输层timeout时间是适应式的</p>
</blockquote>
<ul>
<li>发送端超时重传：如果到时没有收到ACK则重传</li>
<li>问题：如果分组（或ACK ）只是被延迟了<ul>
<li>重传将会导致数据重复，但利用序列号可以处理这个问题</li>
<li>接收方必须指明被正确接收的序列号</li>
</ul>
</li>
<li>需要一个倒计数定时器</li>
</ul>
<p>rdt3.0发送方FSM描述：</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820084716025.png" alt="image-20210820084716025"></p>
<p>rdt3.0运行过程</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820084743656.png" alt="image-20210820084743656"></p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820084813574.png" alt="image-20210820084813574"></p>
<ul>
<li>过早超时（延迟的ACK）也能够正常工作；但是效率较低，一半的分组和确认是重复的</li>
<li>设置一个合理的超时时间是比较重要的</li>
</ul>
<p><strong>rdt3.0的性能</strong></p>
<p>rdt3.0可以工作，但链路容量比较大的情况下，性能很差</p>
<ul>
<li>链路容量比较大，一次发一个PDU的不能够充分利用链路的传输能力</li>
</ul>
<p><br><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820090145229.png" alt="image-20210820090145229"></p>
<ul>
<li><p>$U_{sender}$：利用率，即忙于发送的时间比例</p>
</li>
<li><p>每30ms发送1KB的分组 –&gt;270kbps=33.75kB/s 的吞吐量（在1Gbps 链路上）</p>
</li>
<li><p>瓶颈在于：网络协议限制了物理资源的利用</p>
</li>
<li><p>此例子体现了rdt3.0的停-等操作</p>
</li>
</ul>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820090616698.png" alt="image-20210820090616698"></p>
<ul>
<li><p>通过流水线提高链路利用率，下图展示同时发送3个分组的情况</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820090917997.png" alt="image-20210820090917997"></p>
<ul>
<li>增加n，能提高链路利用率</li>
<li>但当达到某个n，其u=100%时，无法再通过增加n，提高利用率</li>
<li>瓶颈变成了链路带宽</li>
</ul>
</li>
</ul>
<p><strong>流水线协议</strong></p>
<p>流水线：允许发送方在未得到对方确认的情况下一次发送多个分组</p>
<ul>
<li>必须增加序号的范围：用多个bit表示分组的序号</li>
<li>在发送方/接收方要有缓冲区<ul>
<li>发送方缓冲：未得到确认，可能需要重传</li>
<li>接收方缓存：上层用户取用数据的速率≠接收到的数据速率；接收到的数据可能乱序，排序交付（可靠）</li>
</ul>
</li>
<li>两种通用的流水线协议：回退N步（GBN）和选择重传（SR）</li>
</ul>
<p>滑动窗口（slide window）协议</p>
<ul>
<li><p>发送缓冲区</p>
<ul>
<li>形式：内存中的一个区域，落入缓冲区的分组可以发送</li>
<li>功能：用于存放已发送，但是没有得到确认的分组</li>
<li>必要性：需要重发时可用</li>
</ul>
</li>
<li><p>发送缓冲区的大小：一次最多可以发送多少个未经确认的分组</p>
<ul>
<li>停止等待协议=1</li>
<li>流水线协议&gt;1，合理的值，不能很大，链路利用率不能够超100%</li>
</ul>
</li>
<li><p>发送缓冲区中的分组</p>
<ul>
<li>未发送的：落入发送缓冲区的分组，可以连续发送出去</li>
<li>已经发送出去的、等待对方确认的分组：发送缓冲区的分组只有得到确认才能删除</li>
</ul>
</li>
<li><p>发送窗口：发送缓冲区内容的一个范围</p>
<ul>
<li>那些已发送但是未经确认分组的序号构成的空间</li>
</ul>
</li>
<li><p>发送窗口的最大值&lt;=发送缓冲区的值</p>
</li>
<li><p>一开始：没有发送任何一个分组</p>
<ul>
<li>后沿=前沿</li>
<li>之间为发送窗口的尺寸=0</li>
</ul>
</li>
<li><p>每发送一个分组，前沿前移一个单位；发送窗口前沿移动的极限：不能够超过发送缓冲区</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820091837025.png" alt="image-20210820091837025"></p>
</li>
<li><p>发送窗口后沿移动</p>
<ul>
<li><p>条件：收到老分组的确认</p>
</li>
<li><p>结果：发送缓冲区罩住新的分组，来了分组可以发送</p>
</li>
<li><p>移动的极限：不能够超过前沿</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820092208134.png" alt="image-20210820092208134"></p>
</li>
</ul>
</li>
<li><p>接收窗口（Receiving Window）= 接收缓冲区</p>
<ul>
<li>接收窗口用于控制哪些分组可以接收<ul>
<li>只有收到的分组序号落入接收窗口内才允许接收</li>
<li>若序号在接收窗口之外，则丢弃</li>
</ul>
</li>
<li>接收窗口尺寸RW=1，则只能顺序接收，即GBN协议</li>
<li>接收窗口尺寸RW&gt;1 ，则可以乱序接收，但提交给上层的分组，要按序，即SR协议</li>
</ul>
</li>
<li><p>接收窗口的滑动和发送确认</p>
<ul>
<li><p>滑动</p>
<ul>
<li><p>低序号的分组到来，接收窗口移动</p>
</li>
<li><p>高序号分组乱序到，缓存但不交付（因为要实现rdt，不允许失序），不滑动</p>
</li>
</ul>
</li>
<li><p>发送确认</p>
<ul>
<li>接收窗口尺寸=1 ； 发送连续收到的最大的分组确认（累计确认）</li>
<li>接收窗口尺寸&gt;1 ； 收到分组，发送那个分组的确认（非累计确认）</li>
</ul>
</li>
</ul>
</li>
<li><p>正常情况下的2个窗口互动</p>
<ul>
<li>发送窗口<ul>
<li>有新的分组落入发送缓冲区范围，发送且前沿滑动</li>
<li>来了老的低序号分组的确认-&gt;后沿向前滑动-&gt;新的分组可以落入发送缓冲区的范围</li>
</ul>
</li>
<li>接收窗口<ul>
<li>收到分组，落入到接收窗口范围内，接收</li>
<li>是低序号，发送确认给对方</li>
</ul>
</li>
<li>发送端上面来了分组-&gt;发送窗口滑动-&gt;接收窗口滑动-&gt;发确认</li>
</ul>
</li>
<li><p>异常情况下GBN的2窗口互动</p>
<ul>
<li>发送窗口<ul>
<li>新分组落入发送缓冲区范围，发送-&gt;前沿滑动</li>
<li>超时重发机制让发送端将发送窗口中的所有分组发送出去</li>
<li>来了老分组的重复确认-&gt;后沿不向前滑动-&gt;新的分组无法落入发送缓冲区的范围（此时如果发送缓冲区有新的分组可以发送）</li>
</ul>
</li>
<li>接收窗口<ul>
<li>收到乱序分组，没有落入到接收窗口范围内，抛弃</li>
<li>（重复）发送老分组的确认，累计确认；</li>
</ul>
</li>
</ul>
</li>
<li><p>异常情况下SR的2窗口互动</p>
<ul>
<li>发送窗口<ul>
<li>新分组落入发送缓冲区范围，发送-&gt;前沿滑动</li>
<li>超时重发机制让发送端将超时的分组重新发送出去</li>
<li>来了乱序分组的确认-&gt;后沿不向前滑动-&gt;新的分组无法落入发送缓冲区的范围（此时如果发送缓冲区有新的分组可以发送）</li>
</ul>
</li>
<li>接收窗口<ul>
<li>收到乱序分组，落入到接收窗口范围内，接收</li>
<li>发送该分组的确认，单独确认；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>GBN协议和SR协议的异同</p>
<ul>
<li>相同之处<ul>
<li>发送窗口&gt;1</li>
<li>一次能够可发送多个未经确认的分组</li>
</ul>
</li>
<li>不同之处<ul>
<li>GBN :接收窗口尺寸=1<ul>
<li>接收端：只能顺序接收</li>
<li>发送端：从表现来看，一旦一个分组没有发成功，如：0,1,2,3,4  ; 假如1未成功，234都发送出去了，要返回1再发送；GB1</li>
</ul>
</li>
<li>SR: 接收窗口尺寸&gt;1<ul>
<li>接收端：可以乱序接收</li>
<li>发送端：发送0,1,2,3,4，一旦1未成功，2,3,4,已发送，无需重发，选择性发送1</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>流水线协议总结</p>
<ul>
<li>Go-back-N<ul>
<li>发送端最多在流水线中有N个未确认的分组</li>
<li>接收端只是发送累计型确认cumulative ack<ul>
<li>接收端如果发现gap， 不确认新到来的分组</li>
</ul>
</li>
<li>发送端拥有对最老的 未确认分组的定时器<ul>
<li>只需设置一个定时器</li>
<li>当定时器到时时，重传所有未确认分组</li>
</ul>
</li>
</ul>
</li>
<li>Selective Repeat<ul>
<li>发送端最多在流水线中有N个未确认的分组</li>
<li>接收方对每个到来的分组单独确认individual ack （非累计确认）</li>
<li>发送方为每个未确认的分组保持一个定时器,当超时定时器到时，只重发到时的未确认分组</li>
</ul>
</li>
</ul>
<p>GBN：发送方扩展的FSM</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820095627060.png" alt="image-20210820095627060"></p>
<p>GBN：接收方扩展的FSM</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820095652709.png" alt="image-20210820095652709"></p>
<ul>
<li>只发送ACK：对顺序接收的最高序号的分组<ul>
<li>可能会产生重复的ACK</li>
<li>只需记住expectedseqnum；接收窗口=1，只一个变量就可表示接收窗口</li>
</ul>
</li>
<li>对乱序的分组<ul>
<li>丢弃（不缓存），在接收方不被缓存</li>
<li>对顺序接收的最高序号的分组进行确认——累计确认</li>
</ul>
</li>
</ul>
<p>选择重传SR</p>
<ul>
<li>接收方对每个正确接收的分组，分别发送 ACKn（非累积确认）<ul>
<li>接收窗口&gt;1，可以缓存乱序的分组</li>
<li>最终将分组按顺序交付给上层</li>
</ul>
</li>
<li>发送方只对那些没有收到ACK的分组进行重发-选择性重发<ul>
<li>发送方为每个未确认的分组设定一个定时器</li>
</ul>
</li>
<li>发送窗口的最大值（发送缓冲区）限制发送未确认分组的个数</li>
</ul>
<p>选择重传发送方：</p>
<ul>
<li><p>从上层接收数据，如果下一个可用于该分组的序号可在发送窗口中，则发送</p>
</li>
<li><p>timeout(n)：重新发送分组n，重新设定定时器 </p>
</li>
<li><p>ACK(n) in [sendbase,sendbase+N]：将分组n标记为已接收，如n为最小未确认的分组序号， 将base移到下一个未确认序号</p>
</li>
</ul>
<p>选择重传接收方：</p>
<ul>
<li>分组n [rcvbase, rcvbase+N-1]<ul>
<li>发送ACK(n)</li>
<li>乱序：缓存</li>
<li>有序：该分组及以前缓存的序号连续的分组交付给上层 ，然后将窗口移到下一个仍未被接收的分组</li>
</ul>
</li>
<li>分组n [rcvbase-N, rcvbase-1] <ul>
<li>发送ACK(n) </li>
</ul>
</li>
<li>其它：忽略该分组</li>
</ul>
<p>GBN和SR</p>
<table>
<thead>
<tr>
<th></th>
<th>GBN</th>
<th>SR</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>简单，所需资源少（接收方一个 缓存单元）</td>
<td>出错时，重传一个代价小</td>
</tr>
<tr>
<td>缺点</td>
<td>一旦出错，回退N步代价大</td>
<td>复杂，所需要资源多（接收方多个缓存单元）</td>
</tr>
</tbody></table>
<p>适用范围</p>
<ul>
<li>出错率低：比较适合GBN，出错非常罕见，没有必要用复杂的SR，为罕见的事件做日常的准备和复杂处理</li>
<li>链路容量大（延迟大、带宽大）：比较适合SR而不是GBN，一点出错代价太大</li>
</ul>
<p>窗口的最大尺寸，若存在n个分组</p>
<ul>
<li>GBN：$2^n-1$</li>
<li>SR：$2^{n-1}$</li>
</ul>
<h2 id="面向连接的传输：TCP"><a href="#面向连接的传输：TCP" class="headerlink" title="面向连接的传输：TCP"></a>面向连接的传输：TCP</h2><h3 id="TCP：概述"><a href="#TCP：概述" class="headerlink" title="TCP：概述"></a>TCP：概述</h3><ul>
<li>点对点：一个发送方，一个接收方</li>
<li>可靠的、按顺序的字节流<ul>
<li>没有报文边界</li>
</ul>
</li>
<li>管道化（流水线）<ul>
<li>TCP拥塞控制和流量控制设置窗口大小</li>
</ul>
</li>
<li>发送和接收缓存</li>
<li>全双工数据<ul>
<li>在同一连接中数据流双向流动</li>
<li>MSS：最大报文段大小</li>
</ul>
</li>
<li>面向连接<ul>
<li>在数据交换之前，通过握手（交换控制报文）初始化发送方、接收方的状态变量</li>
</ul>
</li>
<li>有流量控制<ul>
<li>发送方不会淹没接收方</li>
</ul>
</li>
</ul>
<p>TCP报文段格式：</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820104619583.png" alt="image-20210820104619583"></p>
<ul>
<li>序号<ul>
<li>报文段首字节的在字节流的编号</li>
</ul>
</li>
<li>确认号<ul>
<li>期望从另一方收到的下一个字节的序号</li>
<li>累积确认</li>
</ul>
</li>
</ul>
<p><strong>TCP往返延时（RTT）和超时</strong></p>
<p>怎样设置TCP超时</p>
<ul>
<li>比RTT要长，但RTT是变化的</li>
<li>太短：太早超时会造成不必要的重传</li>
<li>太长：对报文段丢失反应太慢，消极</li>
</ul>
<p>怎样估计RTT？</p>
<ul>
<li><p>SampleRTT：测量从报文段发出到收到确认的时间</p>
<ul>
<li>如果有重传，忽略此次测量</li>
</ul>
</li>
<li><p>SampleRTT会变化，因此估计的RTT应该比较平滑</p>
<ul>
<li><p>对几个最近的测量值求平均，而不是仅用当前的SampleRTT</p>
</li>
<li><p>$EstimatedRTT(SampleRTT均值) = (1-\alpha)\times EstimatedRTT + \alpha\times SampleRTT$</p>
<ul>
<li>指数加权移动平均（Exponential Weighted Moving Average，EWMA）</li>
<li>过去样本的影响呈指数衰减</li>
<li>推荐值：$\alpha= 0.125$</li>
</ul>
</li>
<li><p>SampleRTT会偏离EstimatedRTT多远，即偏差</p>
<p>$DevRTT =(1-\beta)\times DevRTT+\beta\times|SampleRTT-EstimatedRTT|$</p>
<ul>
<li>推荐值：$\beta= 0.25$</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>超时时间间隔设置为： $TimeoutInterval = EstimatedRTT + 4*DevRTT$，初始设置为1s</p>
<h3 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h3><ul>
<li>TCP在IP不可靠服务的基础上建立了rdt<ul>
<li>管道化的报文段<ul>
<li>GBN or SR</li>
</ul>
</li>
<li>累积确认（像GBN）</li>
<li>单个重传定时器（像GBN）</li>
<li>对于乱序的，没有规范，可以丢弃或缓存</li>
</ul>
</li>
<li>通过以下事件触发重传<ul>
<li>超时（只重发那个最早的未确认段：SR）</li>
<li>快速重传：重复的确认，如收到了ACK50，之后又收到3个ACK50</li>
</ul>
</li>
</ul>
<p>首先考虑简化的TCP发送方</p>
<ul>
<li>忽略重复的确认</li>
<li>忽略流量控制和拥塞控制</li>
</ul>
<p>TCP发送方事件：</p>
<ul>
<li>从应用层接收数据<ul>
<li>用nextseq创建报文段</li>
<li>序号nextseq为报文段首字节的字节流编号</li>
<li>如果还没有运行，启动定时器<ul>
<li>定时器与最早未确认的报文段关联</li>
<li>过期间隔： TimeOutInterval </li>
</ul>
</li>
</ul>
</li>
<li>超时<ul>
<li>重传后沿最老的报文段</li>
<li>重新启动定时器 </li>
</ul>
</li>
<li>收到确认<ul>
<li>如果是对尚未确认的报文段确认<ul>
<li>更新已被确认的报文序号</li>
<li>如果当前还有未被确认的报文段，重新启动定时器</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>TCP重传情况：</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820161745890.png" alt="image-20210820161745890"></p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820161805269.png" alt="image-20210820161805269"></p>
<p>快速重传</p>
<ul>
<li><p>超时周期往往太长</p>
<ul>
<li>在重传丢失报文段之前的延时太长</li>
</ul>
</li>
<li><p>通过重复的ACK来检测报文段丢失</p>
<ul>
<li>发送方通常连续发送大量报文段</li>
<li>如果报文段丢失，通常会引起多个重复的ACK</li>
</ul>
</li>
<li><p>如果发送方收到同一数据的3个冗余ACK，重传最小序号的段</p>
<ul>
<li>快速重传：在定时器过时之前重发报文段</li>
<li>它假设跟在被确认的数据后面的数据丢失了<ul>
<li>第一个ACK是正常的</li>
<li>收到第二个该段的ACK，表示接收方收到一个该段后的乱序段</li>
<li>收到第3，4个该段的ack，表示接收方收到该段之后的2个 ，3个乱序段，段丢失可能性非常大</li>
</ul>
</li>
</ul>
</li>
<li><p>算法</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">event: ACK received, with ACK field value of y </span><br><span class="line"><span class="built_in">	if </span>(y &gt; SendBase) &#123; </span><br><span class="line">		SendBase = y</span><br><span class="line"><span class="built_in">	if </span>(there are currently<span class="built_in"> not-yet-acknowledged </span>segments)</span><br><span class="line">		start timer </span><br><span class="line">	&#125; </span><br><span class="line">	else &#123; </span><br><span class="line">		increment count of dup ACKs received for y</span><br><span class="line">	<span class="built_in">	if </span>(count of dup ACKs received for y = 3) &#123;</span><br><span class="line">		resend segment with sequence number y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>接收方控制发送方，通过<strong>捎带技术</strong>不让发送方发送的太多、太快以至于让接收方的缓冲区溢出</p>
<p>Piggybacking（捎带）：在发送数据的同时携带确认报文</p>
<ul>
<li>接收方在其向发送方的TCP段头部的rwnd字段“通告”其空闲buffer大小<ul>
<li>RcvBuffer大小通过socket选项设置（典型默认大小为4096 字节）</li>
<li>很多操作系统自动调整 RcvBuffer</li>
</ul>
</li>
<li>发送方限制未确认(“in-flight”)字节的个数≤接收方发送过来的 rwnd 值</li>
<li>保证接收方不会被淹没</li>
</ul>
<h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><p>在正式交换数据之前，发送方和接收方握手建立通信关系</p>
<ul>
<li>同意建立连接（每一方都知道对方愿意建立连接）</li>
<li>同意连接参数</li>
</ul>
<p>2次握手连接建立的问题</p>
<ul>
<li><p>变化的延迟（连接请求的段没有丢，但可能超时）</p>
</li>
<li><p>由于丢失造成的重传</p>
</li>
<li><p>报文乱序</p>
</li>
<li><p>相互看不到对方</p>
</li>
<li><p>存在的情况</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820211326552.png" alt="image-20210820211326552"></p>
</li>
</ul>
<p>TCP 3次握手</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820211512381.png" alt="image-20210820211512381"></p>
<p>3次握手解决：半连接和接收老数据问题</p>
<p>方法：若连接不存在， 没建立起来；连接的序号不在当前连接的范围内，则丢弃数据</p>
<p>TCP：关闭连接</p>
<ul>
<li><p>客户端，服务器分别关闭它自己这一侧的连接</p>
<ul>
<li><p>发送FIN bit = 1的TCP段</p>
<blockquote>
<p>FIN：关闭连接</p>
<p>SYN表示建立连接，FIN表示关闭连接，ACK表示响应</p>
</blockquote>
</li>
</ul>
</li>
<li><p>一旦接收到FIN，用ACK回应</p>
<ul>
<li>接到FIN段，ACK可以和它自己发出的FIN段一起发送</li>
</ul>
</li>
<li><p>可以处理同时的FIN交换</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210820212852535.png" alt="image-20210820212852535"></p>
</li>
</ul>
<h2 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h2><ul>
<li>拥塞：太多的数据需要网络传输，超过了网络的处理能力</li>
<li>与流量控制不同</li>
<li>拥塞的表现<ul>
<li>分组丢失（路由器缓冲区溢出）</li>
<li>分组经历比较长的延迟（在路由器的队列中排队）</li>
</ul>
</li>
</ul>
<h3 id="拥塞原因与代价"><a href="#拥塞原因与代价" class="headerlink" title="拥塞原因与代价"></a>拥塞原因与代价</h3><p>情况1 ：两个发送方和一台具有无穷大缓存的路由器，输出链路带宽为R且没有重传</p>
<p>吞吐量上限由两条连接之间共享链路容量造成，即最大为R/2，当发送速率在0~R/2之间，接收方的吞吐量等于发送方的发送速率</p>
<p>当发送速率接近R/2，排队时延陡增，平均时延陡增</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210821080358267.png" alt="image-20210821080358267"></p>
<p>情况2：两个发送方和一台具有有限缓存的路由器</p>
<ul>
<li>分组丢失时，发送端重传<ul>
<li>应用层的输入=应用层输出：$\lambda_{in}=\lambda_{out}$</li>
<li>传输层的输入包括重传：$\lambda_{in}\geq\lambda_{out}$</li>
</ul>
</li>
</ul>
<p>理想化1：发送端知道什么时候路由器的缓冲是可用的</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210821081124973.png" alt="image-20210821081124973"></p>
<ul>
<li>只在缓冲可用时发送</li>
<li>不会丢失：$\lambda_{in^{‘}}=\lambda_{in}$</li>
</ul>
<p>理想化2：掌握丢失信息，分组可以丢失，在路由器由于缓冲器满而被丢弃，若知道分组丢失了，发送方重传分组</p>
<p>当以R/2的速度发送时 , 一些分组是重传的 ，有效输出渐进逼近R/2，在发送方不仅包括发送的数据还包括重传数据</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210821081546986.png" alt="image-20210821081546986"></p>
<p>现实情况：重复</p>
<ul>
<li><p>分组可能丢失，由于缓冲器满而被丢弃</p>
</li>
<li><p>发送端最终超时，发送第2个拷贝，2个分组都被传出</p>
</li>
<li><p>输出比输入少原因</p>
<ul>
<li>重传的丢失分组</li>
<li>没有必要重传的重复分组</li>
</ul>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210821082126992.png" alt="image-20210821082126992"></p>
</li>
<li><p>拥塞的“代价”</p>
<ul>
<li>为了达到一个有效输出，网络需要做更多的工作（重传）</li>
<li>没有必要的重传，链路中包括了多个分组的拷贝，是那些没有丢失，经历的时间比较长（拥塞状态）但是超时的分组</li>
</ul>
</li>
</ul>
<p>情况3：4个发送方和具有有限缓存的多台路由器及多跳路径</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210821082535145.png" alt="image-20210821082535145"></p>
<p>当分组丢失时，任何“关于这个分组的上游传输能力” 都被浪费了，最终形成死锁</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210821082948105.png" alt="image-20210821082948105"></p>
<h3 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h3><p>端到端拥塞控制</p>
<ul>
<li>没有来自网络的显式反馈</li>
<li>端系统根据延迟和丢失事件推断是否有拥塞</li>
<li>TCP采用的方法</li>
</ul>
<p>网络辅助的拥塞控制</p>
<ul>
<li>路由器提供给端系统以反馈信息<ul>
<li>单个bit置位，显示有拥塞（SNA, DECbit,  TCP/IP ECN, ATM）</li>
<li>显式提供发送端可以采用的速率</li>
</ul>
</li>
</ul>
<p>案例分析：ATM ABR 拥塞控制（网络辅助的拥塞控制）</p>
<p>ATM发送的数据为信元</p>
<p>ABR: available bit rate</p>
<ul>
<li>“弹性服务”</li>
<li>如果发送端的路径“轻载 ”，发送方使用可用带宽</li>
<li>如果发送方的路径拥塞了，发送方限制其发送的速度到一个最小保障速率上</li>
</ul>
<p>RM (资源管理) 信元（显示通知）</p>
<ul>
<li>由发送端发送，在数据信元中间隔插入</li>
<li>RM信元中的比特被交换机设置（“网络辅助”）<ul>
<li>NI bit: no increase in  rate (轻微拥塞)速率不要增加</li>
<li>CI bit: congestion  indication 拥塞指示</li>
</ul>
</li>
<li>发送端发送的RM信元被接收端返回，接收端不做任何改变</li>
<li>在RM信元中的2个字节 ER (explicit rate)字段<ul>
<li>拥塞的交换机可能会降低信元中ER的值</li>
<li>发送端发送速度因此是最低的可支持速率</li>
</ul>
</li>
<li>数据信元中的EFCI bit: 被拥塞的交换机设置成1，如果在管理信元RM前面的数据信元EFCI被设置成了1, 接收端在返回的RM信元中设置CI bit</li>
</ul>
<h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>端到端的拥塞控制机制</p>
<ul>
<li>路由器不向主机有关拥塞的反馈信息<ul>
<li>路由器的负担较轻</li>
<li>符合网络核心简单的 TCP/IP架构原则</li>
</ul>
</li>
<li>端系统根据自身得到的信息 ，判断是否发生拥塞，从而采取动作</li>
</ul>
<p><strong>拥塞感知（发送端如何探测到拥塞）</strong></p>
<ul>
<li><p>某个段超时了（丢失事件 ）：拥塞</p>
<ul>
<li>超时时间到，某个段的确认没有来</li>
<li>原因1：网络拥塞（某个路由器缓冲区没空间了，被丢弃）概率大</li>
<li>原因2：出错被丢弃了（各级错误，没有通过校验，被丢弃）概率小</li>
<li>一旦超时，就认为拥塞了，有一定误判，但是总体控制方向是对的</li>
</ul>
</li>
<li><p>有关某个段的3次重复ACK：轻微拥塞</p>
<img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20211228184915293.png" alt="image-20211228184915293" style="zoom:50%;">

<ul>
<li>段的第1个ack，正常，确认绿段，期待红段</li>
<li>段的第2个重复ack，意味着红段的后一段收到了，蓝段乱序到达</li>
<li>段的第2、3、4个ack重复，意味着红段的后第2、3、4个段收到了 ，橙段乱序到达，同时红段丢失的可能性很大（后面3个段都到了， 红段都没到）</li>
<li>网络这时还能够进行一定程度的传输，拥塞但情况要比第一种好</li>
</ul>
</li>
</ul>
<p><strong>速率控制方法（如何控制发送端发送的速率）</strong></p>
<ul>
<li><p>维持一个拥塞窗口的值：Congestion window，cwnd</p>
</li>
<li><p>发送端限制已发送但是未确认的数据量（的上限）：$LastByteSent-LastByteAcked\leq \min{cwnd,rwnd}$</p>
</li>
<li><p>从而粗略地控制发送方的往网络中注入的速率：$rate\approx \frac{cwnd}{RTT}$</p>
</li>
<li><p>cwnd是动态的，是感知到的网络拥塞程度的函数</p>
<ul>
<li><p>超时或者3个重复ack，cwnd 下降</p>
<ul>
<li><p>超时时：cwnd降为1MSS，进入SS阶段然后再倍增到 cwnd/2（每个RTT），从而进入CA（拥塞避免）阶段</p>
<blockquote>
<p>MSS（最大报文段长度）=MTU - IP head- TCP head</p>
</blockquote>
</li>
<li><p>3个重复ack ：cwnd降为cwnd/2，CA阶段</p>
</li>
</ul>
</li>
<li><p>否则（正常收到Ack，没有发送以上情况）：cwnd上升</p>
<ul>
<li>SS阶段：加倍增加（每个RTT）</li>
<li>CA阶段：线性增加（每个RTT）</li>
</ul>
</li>
</ul>
</li>
<li><p>联合控制的方法</p>
<ul>
<li>发送端控制发送但是未确认的量同时也不能够超过接收窗口，满足流量控制要求</li>
<li>同时满足拥塞控制和流量控制要求</li>
</ul>
</li>
</ul>
<p><strong>拥塞控制策略</strong></p>
<p>TCP 慢启动（slow-start，SS）</p>
<ul>
<li>连接刚建立，cwnd = 1 MSS</li>
<li>可用带宽可能接近MSS/RTT，此时应该尽快加速，到达希望的速率</li>
<li>当连接开始时，指数性增加发送速率，直到发生丢失的事件<ul>
<li>启动初值很低</li>
<li>增加速度很快</li>
</ul>
</li>
<li>当连接开始时，指数性增加（每个RTT）发送速率直到发生丢失事件<ul>
<li>每一个RTT，cwnd加倍</li>
<li>每收到一个ACK时，cwnd加1</li>
<li>慢启动阶段：只要不超时或3个重复ack，一个RTT，cwnd加倍</li>
</ul>
</li>
<li>总结：初始速率很慢，但是加速却是指数性的<ul>
<li>指数增加，SS时间很短，长 期来看可以忽略</li>
</ul>
</li>
<li>例子：喝酒</li>
</ul>
<p>TCP 拥塞控制：AIMD</p>
<ul>
<li><p>乘性减：丢失事件后将cwnd降为1，将cwnd/2作为阈值，进入慢启动阶段（倍增直到 cwnd/2） </p>
</li>
<li><p>加性增：当cwnd&gt;阈值时，一个RTT如没有发生丢失事件，将cwnd加1MSS进行探测</p>
</li>
<li><p>在超时之前，当cwnd变成上次发生超时的窗口的一半，将指数性增长变成线性<img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210821091932885.png" alt="image-20210821091932885"></p>
</li>
<li><p>变量：Threshold</p>
</li>
<li><p>出现丢失，Threshold设置成cwnd的1/2</p>
</li>
</ul>
<p>TCP拥塞控制总结：</p>
<ul>
<li>当cwnd＜Threshold，发送端处于慢启动阶段（ slow-start）, 窗口指数性增长</li>
<li>当cwnd &gt; Threshold，发送端处于拥塞避免阶段 （congestion-avoidance）, 窗口线性增长</li>
<li>当收到三个重复的ACKs（triple duplicate ACK），Threshold设置成 cwnd/2，cwnd = Threshold+3</li>
<li>当超时事件发生时timeout，Threshold = cwnd/2  cwnd=1MSS，进入SS阶段</li>
</ul>
<table>
<thead>
<tr>
<th>事件</th>
<th>状态</th>
<th>TCP 发送端行为</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>以前没有收到 ACK的data  被ACKed</td>
<td>慢启动 (SS)</td>
<td>cwnd = cwnd + MSS if（cwnd &gt; Threshold）状态变成“CA”</td>
<td>每一个RTT cwnd 加倍</td>
</tr>
<tr>
<td>以前没有收到 ACK的data  被ACKed</td>
<td>拥塞避 免 (CA)</td>
<td>cwnd = cwnd + MSS *（MSS/cwnd）</td>
<td>加性增加，每一个RTT对 cwnd 加一个1 MSS</td>
</tr>
<tr>
<td>通过收到3个重 复的ACK，发现 丢失的事件</td>
<td>SS or CA</td>
<td>Threshold = cwnd/2，cwnd = Threshold+3</td>
<td>快速重传，实现乘性的减. cwnd 没有变成1  MSS</td>
</tr>
<tr>
<td>超时</td>
<td>SS or CA</td>
<td>Threshold = cwnd/2，cwnd = 1MSS，状态变为SS</td>
<td>进入slow start</td>
</tr>
<tr>
<td>重复的 ACK</td>
<td>SS or CA</td>
<td>对被ACKed 的segment，增加重复ACK的计数</td>
<td>cwnd和Threshold不变</td>
</tr>
</tbody></table>
<p>TCP 吞吐量：忽略慢启动阶段，假设发送端总有数据传输</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210821094010456.png" alt="image-20210821094010456"></p>
<ul>
<li><p>W：发生丢失事件时的窗口尺寸（单位：字节）</p>
</li>
<li><p>平均窗口尺寸：3/4W</p>
</li>
<li><p>平均吞吐量：RTT时间吞吐3/4W</p>
<blockquote>
<p>$T=\frac{\frac{W}{2}+W}{2RTT}=\frac{3}{4}\frac{W}{RTT}$</p>
</blockquote>
</li>
</ul>
<p><strong>TCP公平性</strong></p>
<p>若K个TCP会话分享一个链路带宽为R的瓶颈，每一个会话的有效带宽为 R/K</p>
<p>2个竞争的TCP会话</p>
<ul>
<li>加性增加，斜率为1, 吞吐量增加</li>
<li>乘性减，吞吐量比例减少</li>
</ul>
<p>公平性和 UDP</p>
<ul>
<li>多媒体应用通常不是用 TCP，应用发送的数据速率希望不受拥塞控制的节制</li>
<li>使用UDP：音视频应用泵出数据的速率是恒定的, 忽略数据的丢失</li>
<li>研究领域：TCP友好性</li>
</ul>
<p>公平性和并行TCP连接</p>
<ul>
<li>2个主机间可以打开多个并行的TCP连接</li>
<li>如Web浏览器</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>大学课程</tag>
      </tags>
  </entry>
  <entry>
    <title>应用层</title>
    <url>/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<p>网络应用的原理：网络应用协议的概念和实现方面</p>
<ul>
<li>传输层的服务模型</li>
<li>客户-服务器模式</li>
<li>对等模式(peer-to-peer) </li>
<li>内容分发网络</li>
</ul>
<span id="more"></span>

<p>网络应用的实例：互联网流行的应用层协议</p>
<ul>
<li>HTTP</li>
<li>FTP</li>
<li>SMTP / POP3 /  IMAP</li>
<li>DNS</li>
</ul>
<p>编程：网络应用程序</p>
<ul>
<li>Socket API</li>
</ul>
<h2 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h2><h3 id="创建一个新的网络应用"><a href="#创建一个新的网络应用" class="headerlink" title="创建一个新的网络应用"></a>创建一个新的网络应用</h3><ul>
<li><p>编程</p>
<ol>
<li>在不同的端系统上运行</li>
<li>通过网络基础设施提供的服务，应用进程彼此通信</li>
<li>如Web<ul>
<li>Web 服务器软件与浏览器软件通信 </li>
</ul>
</li>
</ol>
</li>
<li><p>网络核心中没有应用层软件</p>
<ul>
<li>网络核心没有应用层功能</li>
<li>网络应用只在端系统上存在</li>
<li>促进网络应用快速开发和部署</li>
</ul>
</li>
</ul>
<h3 id="应用程序体系结构"><a href="#应用程序体系结构" class="headerlink" title="应用程序体系结构"></a>应用程序体系结构</h3><ul>
<li>客户-服务器模式（C/S:client/server）</li>
<li>对等模式(P2P:Peer To Peer)</li>
<li>混合体模式：客户-服务器和对等体系结构</li>
</ul>
<h4 id="C-S体系结构"><a href="#C-S体系结构" class="headerlink" title="C/S体系结构"></a>C/S体系结构</h4><ul>
<li>服务器<ul>
<li>一直运行</li>
<li>固定的IP地址和众知的端口号（约定）</li>
<li>扩展性：服务器场<ul>
<li><strong>数据中心</strong>进行扩展</li>
<li>扩展性差</li>
</ul>
</li>
</ul>
</li>
<li>客户端<ul>
<li>主动与服务器通信</li>
<li>与互联网有间歇性的连接</li>
<li>可能是动态IP 地址</li>
<li>不直接与其它客户端通信</li>
</ul>
</li>
</ul>
<blockquote>
<p>C/S体系结构达到一定阈值时呈现断崖式下降</p>
</blockquote>
<h4 id="P2P体系结构"><a href="#P2P体系结构" class="headerlink" title="P2P体系结构"></a>P2P体系结构</h4><ul>
<li>（几乎）没有一直运行的服务器</li>
<li>任意端系统之间可以进行通信</li>
<li>每一个节点既是客户端又是服务器<ul>
<li><strong>自扩展性</strong>：新peer节点带来新的服务能力，同时也带来新的服务请求</li>
</ul>
</li>
<li>参与的主机间歇性连接且可以改变IP地址<ul>
<li>难以管理</li>
</ul>
</li>
<li>例子：Gnutella，迅雷</li>
</ul>
<h4 id="混合体模式"><a href="#混合体模式" class="headerlink" title="混合体模式"></a>混合体模式</h4><p>Napster（一个P2P文件分发系统）</p>
<ul>
<li>文件搜索：集中<ul>
<li>主机在中心服务器上注册其资源</li>
<li>主机向中心服务器查询资源位置</li>
</ul>
</li>
<li>文件传输：P2P<ul>
<li>任意Peer节点之间</li>
</ul>
</li>
</ul>
<p>即时通信</p>
<ul>
<li>在线检测：集中</li>
<li>当用户上线时，向中心服务器注册其IP地址</li>
<li>用户与中心服务器联系，以找到其在线好友的位置</li>
<li>两个用户之间聊天：P2P</li>
</ul>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>进程：在主机上运行的应用程序</p>
<ul>
<li>在同一个主机内，使用进程间通信机制通信（ 操作系统定义）</li>
<li>不同主机，通过交换报文（Message）来通信<ul>
<li>使用OS提供的通信服务</li>
<li>按照应用协议交换报文（借助传输层提供的服务）</li>
</ul>
</li>
</ul>
<ul>
<li><p>客户端进程：发起通信的进程 </p>
</li>
<li><p>服务器进程：等待连接的进程</p>
<blockquote>
<p>P2P架构的应用也有客户端进程和服务器进程之分</p>
</blockquote>
</li>
</ul>
<p>分布式进程通信需要解决的问题</p>
<ol>
<li>进程标示和寻址问题（服务用户）</li>
<li>传输层-应用层使用提供服务是如何（服务）<ul>
<li>位置：层间界面的SAP （TCP/IP ：socket）</li>
<li>形式：应用程序接口API （TCP/IP ：socket API）</li>
</ul>
</li>
<li>如何使用传输层提供的服务，实现应用进程之间的报文交换，实现应用（用户使用服务）<ul>
<li>定义应用层协议：报文格式，解释，时序等</li>
<li>编制程序，使用OS提供的API ，调用网络基础设施提供通信服务传报文，实现应用时序等；</li>
</ul>
</li>
</ol>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210725180008010.png" alt="image-20210725180008010"></p>
<h4 id="进程寻址"><a href="#进程寻址" class="headerlink" title="进程寻址"></a>进程寻址</h4><p>进程为了接收报文，必须有一个标识即：SAP（发送也需要标示），进程至少需要三个标示</p>
<ul>
<li>主机：唯一的 32位IP地址<ul>
<li>仅仅有IP地址不能够唯一标示一个进程</li>
<li>在一台端系统上有很多应用进程在运行</li>
</ul>
</li>
<li>所采用的传输层协议：TCP or UDP</li>
<li>端口号（Port Numbers），65536个端口号，16位</li>
</ul>
<p>一些知名端口号的例子</p>
<ul>
<li>HTTP：TCP 80 </li>
<li>Mail：TCP 25 </li>
<li>FTP：TCP 2</li>
</ul>
<p>一个进程：用IP+port标示端节点</p>
<p>本质上，一对主机进程之间的通信由2个端节点构成</p>
<h4 id="传输层提供的服务-需要穿过层间的信息"><a href="#传输层提供的服务-需要穿过层间的信息" class="headerlink" title="传输层提供的服务-需要穿过层间的信息"></a>传输层提供的服务-需要穿过层间的信息</h4><p>层间接口必须要携带的信息</p>
<ul>
<li>要传输的报文（对于本层来说：SDU）</li>
<li>谁传的：对方的应用进程的标示：IP+TCP(UDP) 端口</li>
<li>传给谁：对方的应用进程的标示：对方的IP+TCP(UDP)端口号</li>
</ul>
<p>传输层实体（tcp或者udp实体）根据这些信息进行TCP 报文段（UDP数据报）的封装</p>
<ul>
<li>源端口号，目标端口号，数据等</li>
<li>将IP地址往下交IP实体，用于封装IP数据报：源IP，目标IP</li>
</ul>
<p>如果Socket API 每次传输报文，都携带如此多的信息，太繁琐易错，不便于管理，用个代号标示通信的双方或者单方即socket，就像OS打开文件返回的句柄（对句柄的操作，就是对文件的操作）一样</p>
<h5 id="TCP-socket"><a href="#TCP-socket" class="headerlink" title="TCP socket"></a>TCP socket</h5><ul>
<li>TCP服务，两个进程之间的通信需要之前要建立连接<ul>
<li> 两个进程通信会持续一段时间，通信关系稳定</li>
</ul>
</li>
<li>可以用一个整数表示两个应用实体之间的<strong>通信关系</strong> ，<strong>本地标示</strong></li>
<li>穿过层间接口的信息量最小</li>
<li>便于操作系统管理</li>
<li>TCP socket：源IP，源端口，目标IP，目标IP，目标端口</li>
</ul>
<blockquote>
<p>TCP之上的套接字（socket）</p>
<p>对于使用面向连接服务（TCP）的应用而言，套接字是4元组的一个具有本地意义的标示</p>
<ul>
<li><strong>4元组：源IP，源port，目标IP，目标port</strong></li>
<li>唯一的指定了一个会话（2个进程之间的会话关系）</li>
<li>应用使用这个标示，与远程的应用进程通信</li>
<li>不必在每一个报文的发送都要指定这4元组</li>
<li>就像使用操作系统打开一个文件，OS返回一个文件句柄一样，以后使用这个文件句柄，而不是使用这个文件的目录名、文件名 </li>
<li>简单，便于管理</li>
</ul>
</blockquote>
<img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210801085907358.png" alt="image-20210801085907358" style="zoom:80%;">



<h5 id="UDP-socket"><a href="#UDP-socket" class="headerlink" title="UDP socket"></a>UDP socket</h5><ul>
<li>UDP服务，两个进程之间的通信之前无需建立连接<ul>
<li>每个报文都是独立传输的</li>
<li>前后报文可能给不同的分布式进程</li>
</ul>
</li>
<li>因此，只能用一个整数表示<strong>本应用实体</strong>的标示，因为这个报文可能传给另外一个分布式进程</li>
<li>穿过层间接口的信息大小最小</li>
<li>UDP socket：本IP，本端口</li>
<li>传输报文时：必须要提供对方IP，port</li>
</ul>
<blockquote>
<p>UDP之上的套接字（socket）</p>
<p>对于使用无连接服务（UDP）的应用而言，套接字是2元组的一个具有本地意义的标示</p>
<ul>
<li><strong>2元组：IP，port （源端指定）</strong></li>
<li>UDP套接字指定了应用所在的一个端节点（end  point）</li>
<li>在发送数据报时，采用创建好的本地套接字（标示 ID），就不必在发送每个报文中指明自己所采用的IP和port</li>
<li>但是在发送报文时，必须要指定对方的IP和UDP port(另外一个端节点)</li>
</ul>
</blockquote>
<img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210801090928241.png" alt="image-20210801090928241" style="zoom:80%;">



<p>套接字</p>
<p>进程向套接字发送报文或从套接字接收报文</p>
<p>套接字类似于门户</p>
<ul>
<li>发送进程将报文推出门户，发送进程依赖于传输层设施在另外一侧的 门将报文交付给接受进程</li>
<li>接收进程从另外一端的门户收到报文（依赖于传输层设施）</li>
</ul>
<h4 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h4><p>定义运行在不同端系统上的应用进程如何相互交换报文</p>
<ul>
<li>交换的<strong>报文类型</strong>：请求和应答报文</li>
<li>各种报文类型的<strong>语法</strong>：报文中的各个字段及其描述</li>
<li>字段的<strong>语义</strong>：即字段取值的含义</li>
<li>进程何时、如何发送报文及对报文进行响应的<strong>规则</strong></li>
</ul>
<p>应用协议仅仅是应用的一个组成部分</p>
<ul>
<li>如Web应用包含HTTP协议，web客户端，web服务器，HTML文件解释</li>
</ul>
<p>公开协议</p>
<ul>
<li>由RFC文档定义</li>
<li>允许互操作</li>
<li>如HTTP, SMTP</li>
</ul>
<p>专用（私有）协议</p>
<ul>
<li>协议不公开</li>
<li>如：Skype</li>
</ul>
<p>传输层提供服务的性能指标</p>
<ul>
<li>数据丢失率<ul>
<li>有些应用则要求100%的可靠数据传输（如文件）</li>
<li>有些应用（如音频）能容忍 一定比例以下的数据丢失 </li>
</ul>
</li>
<li>延迟<ul>
<li>一些应用出于有效性考虑，对数据传输有严格的时间限制<ul>
<li>Internet 电话、交互式游戏</li>
<li>延迟、延迟差 </li>
</ul>
</li>
</ul>
</li>
<li>吞吐<ul>
<li>一些应用（如多媒体）必须需要最小限度的吞吐，从而使得应用能够有效运转</li>
<li>一些应用能充分利用可供使 用的吞吐(弹性应用) </li>
</ul>
</li>
<li>安全性<ul>
<li>机密性</li>
<li>完整性</li>
<li>可认证性（鉴别）</li>
</ul>
</li>
</ul>
<p>常见应用对传输服务的要求</p>
<table>
<thead>
<tr>
<th align="center">应用</th>
<th align="center">数据丢失率</th>
<th align="center">吞吐</th>
<th align="center">时间敏感性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">文件传输</td>
<td align="center">不能丢失</td>
<td align="center">弹性</td>
<td align="center">不</td>
</tr>
<tr>
<td align="center">e-mail</td>
<td align="center">不能丢失</td>
<td align="center">弹性</td>
<td align="center">不</td>
</tr>
<tr>
<td align="center">Web 文档</td>
<td align="center">不能丢失</td>
<td align="center">弹性</td>
<td align="center">不</td>
</tr>
<tr>
<td align="center">实时音视频</td>
<td align="center">容忍丢失</td>
<td align="center">音频：5kbps<del>1Mbps       视频：100kbps</del>5Mbps</td>
<td align="center">是，100ms</td>
</tr>
<tr>
<td align="center">存储音视频</td>
<td align="center">容忍丢失</td>
<td align="center">音频：5kbps<del>1Mbps       视频：100kbps</del>5Mbps</td>
<td align="center">是，几秒</td>
</tr>
<tr>
<td align="center">交互式游戏</td>
<td align="center">容忍丢失</td>
<td align="center">几kbps~10kbps</td>
<td align="center">是，100ms</td>
</tr>
<tr>
<td align="center">即时讯息</td>
<td align="center">不能丢失</td>
<td align="center">弹性</td>
<td align="center">是</td>
</tr>
</tbody></table>
<h3 id="Internet-传输层提供的服务"><a href="#Internet-传输层提供的服务" class="headerlink" title="Internet 传输层提供的服务"></a>Internet 传输层提供的服务</h3><h4 id="TCP-服务"><a href="#TCP-服务" class="headerlink" title="TCP 服务"></a>TCP 服务</h4><ul>
<li>可靠的传输服务</li>
<li>流量控制：发送方不会淹没接受方</li>
<li>拥塞控制：当网络出现拥塞时，能抑制发送方</li>
<li>不能提供的服务：时间保证、最小吞吐保证和安全</li>
<li>面向连接：要求在客户端进程和服务器进程之间建立连接</li>
</ul>
<h4 id="UDP-服务"><a href="#UDP-服务" class="headerlink" title="UDP 服务"></a>UDP 服务</h4><ul>
<li>不可靠数据传输</li>
<li>不提供的服务：可靠， 流量控制、拥塞控制、 时间、带宽保证、建立连接</li>
</ul>
<p>UDP存在的必要性</p>
<ul>
<li>能够区分不同的进程，而IP服务不能<ul>
<li>在IP提供的主机到主机端到端功能的基础上，区分了主机的应用进程</li>
</ul>
</li>
<li>无需建立连接，省去了建立连接时间，适合事务性的应用</li>
<li>不做可靠性的工作，例如检错重发，适合那些对实时性要求比较高而对正确性要求不高的应用<ul>
<li>因为为了实现可靠性（准确性、保序等），必须付出时间代价（检错重发）</li>
</ul>
</li>
<li>没有拥塞控制和流量控制，应用能够按照设定的速度发送数据<ul>
<li>而在TCP上面的应用，应用发送数据的速度和主机向网络发送的实际速度是不一致的，因为有流量控制和拥塞控制</li>
</ul>
</li>
</ul>
<h4 id="Internet应用及其应用层协议和传输协议"><a href="#Internet应用及其应用层协议和传输协议" class="headerlink" title="Internet应用及其应用层协议和传输协议"></a>Internet应用及其应用层协议和传输协议</h4><table>
<thead>
<tr>
<th align="center">应用</th>
<th align="center">应用层协议</th>
<th align="center">下层的传输协议</th>
</tr>
</thead>
<tbody><tr>
<td align="center">e-mail</td>
<td align="center">SMTP</td>
<td align="center">TCP</td>
</tr>
<tr>
<td align="center">远程终端访问</td>
<td align="center">Telnet</td>
<td align="center">TCP</td>
</tr>
<tr>
<td align="center">Web</td>
<td align="center">HTTP</td>
<td align="center">TCP</td>
</tr>
<tr>
<td align="center">文件传输</td>
<td align="center">FTO</td>
<td align="center">TCP</td>
</tr>
<tr>
<td align="center">流媒体</td>
<td align="center">专用协议（如RealNetworks）</td>
<td align="center">TCP或UDP</td>
</tr>
<tr>
<td align="center">Internet电话</td>
<td align="center">专用协议（如Net2Phone）</td>
<td align="center">TCP或UDP</td>
</tr>
</tbody></table>
<h4 id="安全TCP"><a href="#安全TCP" class="headerlink" title="安全TCP"></a>安全TCP</h4><p>TCP &amp; UDP </p>
<ul>
<li>都没有加密</li>
<li>明文通过互联网传输 ，甚至密码</li>
</ul>
<p>SSL（安全套接字层）</p>
<ul>
<li>在TCP上面实现，提供加密的TCP连接</li>
<li>私密性</li>
<li>数据完整性</li>
<li>端到端的鉴别</li>
</ul>
<p>SSL在应用层</p>
<ul>
<li>应用采用SSL库，SSL 库使用TCP通信</li>
</ul>
<p>SSL socket API</p>
<ul>
<li>应用通过API将明文交 给socket，SSL将其加密在互联网上传输</li>
</ul>
<h2 id="Web和HTTP"><a href="#Web和HTTP" class="headerlink" title="Web和HTTP"></a>Web和HTTP</h2><p>Web页由一些<strong>对象</strong>组成，对象可以是HTML文件、JPEG图像、Java小程序、声音剪辑文件等</p>
<p>Web页含有一个基本的HTML文件，该基本HTML文件又包含若干对象的引用（链接）</p>
<p>通过URL对每个对象进行引用，URL包含访问协议，用户名，口令字，端口等；</p>
<p>Prot:（协议名）//user:psw（用户，口令）@<a href="http://www.someschool.edu(主机名)/someDept%EF%BC%88%E8%B7%AF%E5%BE%84%E5%90%8D%EF%BC%89/pic.gif%EF%BC%88%E6%96%87%E4%BB%B6%E5%90%8D%EF%BC%89:port%EF%BC%88%E7%AB%AF%E5%8F%A3%E5%8F%B7%EF%BC%89">www.someSchool.edu（主机名）/someDept（路径名）/pic.gif（文件名）:port（端口号）</a></p>
<h3 id="HTTP概况"><a href="#HTTP概况" class="headerlink" title="HTTP概况"></a>HTTP概况</h3><p>HTTP: 超文本传输协议</p>
<ul>
<li><p>Web的应用层协议</p>
</li>
<li><p>客户/服务器模式</p>
<ul>
<li>客户: 请求、接收和显示 Web对象的浏览器</li>
<li>服务器: 对请求进行响应，发送对象的Web服务器</li>
</ul>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210807145628882.png" alt="image-20210807145628882"></p>
</li>
<li><p>HTTP 1.0：RFC 1945</p>
</li>
<li><p>HTTP 1.1：RFC 2068</p>
</li>
</ul>
<p>HTTP使用TCP协议</p>
<ul>
<li>客户发起一个与服务器的 TCP连接 (建立套接字) ， 端口号为 80</li>
<li>服务器接受客户的TCP连接</li>
<li>在浏览器（HTTP客户端）与 Web服务器(HTTP服务器 server)交换HTTP 报文（应用层协议报文）</li>
<li>TCP连接关闭</li>
</ul>
<p><strong>HTTP是无状态的，即服务器并不维护关于客户的任何信息</strong></p>
<blockquote>
<p>维护状态的协议很复杂</p>
<ul>
<li>必须维护历史信息(状态)</li>
<li>如果服务器/客户端死机，它们的状态信息可能不一致， 然而二者的信息必须是一致的</li>
<li>无状态的服务器能够支持更多的客户端</li>
</ul>
</blockquote>
<h3 id="HTTP连接"><a href="#HTTP连接" class="headerlink" title="HTTP连接"></a>HTTP连接</h3><h4 id="非持久HTTP"><a href="#非持久HTTP" class="headerlink" title="非持久HTTP"></a>非持久HTTP</h4><ul>
<li>最多只有一个对象在 TCP连接上发送</li>
<li>下载多个对象需要多个TCP连接</li>
<li>HTTP/1.0使用非持久连接</li>
</ul>
<img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210807150925859.png" alt="image-20210807150925859" style="zoom:67%;">

<p><strong>响应时间模型</strong></p>
<p>往返时间RTT（round-trip  time）：一个小的分组从客户端到服务器，在回到客户端的时间（传输时间忽略） </p>
<p>响应时间</p>
<ul>
<li>一个  RTT用来发起TCP连接</li>
<li>一个 RTT用来HTTP请求并等待HTTP响应</li>
<li>文件传输时间<ul>
<li><strong>共2RTT+传输时间</strong></li>
</ul>
</li>
</ul>
<p>非持久HTTP的缺点</p>
<ul>
<li>每个对象要2个 RTT</li>
<li>操作系统必须为每个TCP连接分配资源</li>
<li>浏览器通常打开并行TCP连接，以获取引用对象</li>
</ul>
<h4 id="持久HTTP"><a href="#持久HTTP" class="headerlink" title="持久HTTP"></a>持久HTTP</h4><ul>
<li>多个对象可以在一个 （在客户端和服务器之间的）TCP连接上传输</li>
<li>HTTP/1.1 默认使用持久连接</li>
<li>服务器在发送响应后，仍保持 TCP连接</li>
<li>在相同客户端和服务器之间的后续请求和响应报文通过相同的连接进行传送</li>
<li>客户端在遇到一个引用对象的 候，就可以尽快发送该对象的请 求</li>
</ul>
<p>非流水方式的持久HTTP</p>
<ul>
<li>客户端只能在收到前一个响应后才能发出新的请求</li>
<li>每个引用对象花费一个RTT</li>
</ul>
<p>流水方式的持久HTTP</p>
<ul>
<li>HTTP/1.1的默认模式</li>
<li>客户端遇到一个引用对象就立即产生一个请求</li>
<li>所有引用（小）对象只花费一个 RTT是可能的</li>
</ul>
<h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><p>两种类型的HTTP报文：请求、响应</p>
<h4 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h4><ul>
<li><p>ASCII（人能够阅读）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /somedir/page.html HTTP/1.1                 请求行 (GET, POST, HEAD，PUT，DELETE命令)</span><br><span class="line">Host: www.someschool.edu  						首部行     主机名</span><br><span class="line">User-agent: Mozilla/4.0 						首部行     用户代理程序，浏览器版本</span><br><span class="line">Connection: close  								首部行		连接关闭</span><br><span class="line">Accept-language:fr  							首部行	    语言</span><br><span class="line">												换行回车符，表示报文结束</span><br></pre></td></tr></table></figure></li>
<li><p>报文格式</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210807153452542.png" alt="image-20210807153452542"></p>
</li>
<li><p>提交表单输入</p>
<ul>
<li><p>Post方式</p>
<ul>
<li>网页通常包括表单输入</li>
<li>包含在实体主体 (entity body )中的输入被提交到服务器</li>
</ul>
</li>
<li><p>GET方式</p>
<ul>
<li><p>通过请求行的 URL字段输入数据上载</p>
</li>
<li><p>如</p>
<img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210807153816852.png" alt="image-20210807153816852" style="zoom: 80%;"></li>
</ul>
</li>
</ul>
</li>
<li><p>方法类型</p>
<ul>
<li><p>HTTP/1.0</p>
<ul>
<li><p>GET</p>
</li>
<li><p>POST</p>
</li>
<li><p>HEAD</p>
<blockquote>
<p>要求服务器在响应报文中不包含请求对象，通常用于调试跟踪或搜索引擎建立索引</p>
</blockquote>
</li>
</ul>
</li>
<li><p>HTTP/1.1</p>
<ul>
<li><p>GET, POST, HEAD</p>
</li>
<li><p>PUT</p>
<blockquote>
<p>将实体主体中的文件上载到URL字段规定的路径</p>
</blockquote>
</li>
<li><p>DELETE</p>
<blockquote>
<p>删除URL字段规定的文件</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h4><ul>
<li><p>ASCII</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK\r\n								状态行 (协议版本、状态码和相应状态信息)</span><br><span class="line">Connection close\r\n							首部行 	连接关闭</span><br><span class="line">Date: Thu, 06 Aug 1998 12:00:15 GMT\r\n			首部行 	日期和时间</span><br><span class="line">Server: Apache/1.3.0 (Unix) \r\n				首部行 	服务器类型版本</span><br><span class="line">Last-Modified: Mon, 22 Jun 1998 …... \r			首部行 	最后修改时间</span><br><span class="line">Content-Length: 6821\r\n						首部行 	内容字节长度</span><br><span class="line">Content-Type: text/html\r\n						首部行 	对象类型，此次指示位HTML文本</span><br><span class="line">	\r\n</span><br><span class="line">	\r\n</span><br><span class="line">data data data data data ... 					实体主体</span><br></pre></td></tr></table></figure></li>
<li><p>响应状态码</p>
<ul>
<li><p>200 OK</p>
<blockquote>
<p>请求成功，请求对象包含在响应报文的后续部分 </p>
</blockquote>
</li>
<li><p>301 Moved Permanently</p>
<blockquote>
<p>请求的对象已经被永久转移了；新的URL在响应报文的Location: 首部行中指定</p>
<p>客户端软件自动用新的URL去获取对象 </p>
</blockquote>
</li>
<li><p>400 Bad Request</p>
<blockquote>
<p>一个通用的差错代码，表示该请求不能被服务器解读 </p>
</blockquote>
</li>
<li><p>404 Not Found</p>
<blockquote>
<p>请求的文档在该服务上没有找到</p>
</blockquote>
</li>
<li><p>505 HTTP Version Not Supported</p>
<blockquote>
<p>服务器不支持请求报文使用的HTTP协议版本</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="用户-服务器状态：cookie"><a href="#用户-服务器状态：cookie" class="headerlink" title="用户-服务器状态：cookie"></a>用户-服务器状态：cookie</h3><p>大多数主要的门户网站使用 cookies</p>
<p>cookies有4个组成部分</p>
<ol>
<li>在HTTP响应报文中有一个cookie的首部行</li>
<li>在HTTP请求报文含有一个cookie的首部行</li>
<li>在用户端系统中保留有一个cookie文件，由用户的浏览器管理</li>
<li>在Web站点有一个后端数据库</li>
</ol>
<p>Cookie维护状态过程</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210807160055822.png" alt="image-20210807160055822"></p>
<p>如何维持状态</p>
<ul>
<li>协议端节点：在多个事务上，发送端和接收端维持状态</li>
<li>cookies：HTTP报文携带状态信息</li>
</ul>
<p>Cookies与隐私</p>
<ul>
<li>Cookies允许站点知道许多关于用户的信息</li>
<li>可能将它知道的东西卖给第三方</li>
<li>使用重定向和cookie的搜索引擎还能知道用户更多的信息</li>
<li>如通过某个用户在大量站点上的行为，了解其个人浏览方式的大致模式</li>
<li>广告公司从站点获得信息</li>
</ul>
<h3 id="Web缓存（代理服务器）"><a href="#Web缓存（代理服务器）" class="headerlink" title="Web缓存（代理服务器）"></a>Web缓存（代理服务器）</h3><p>目标：不访问原始服务器，就满足客户的请求</p>
<ul>
<li>用户设置浏览器： 通过缓存访问Web</li>
<li>浏览器将所有的HTTP请求发给缓存<ul>
<li>在缓存中的对象：缓存直接返回对象</li>
<li>如对象不在缓存，缓存请求原始服务器，然后再将对象返回给客户端</li>
</ul>
</li>
<li>缓存既是客户端又是服务器</li>
<li>通常缓存是由ISP安装 (大学、公司、居民区ISP)</li>
</ul>
<p>使用Web缓存的优点</p>
<ul>
<li>降低客户端的请求响应时间</li>
<li>可以大大减少一个机构内部网络与Internet接入链路上的流量</li>
<li>互联网大量采用了缓存： 可以使较弱的ICP也能够有效提供内容</li>
</ul>
<p><strong>缓存示例</strong></p>
<p>假设</p>
<ul>
<li>平均对象大小 = 100kb</li>
<li>机构内浏览器对原始服务器的平均请求率为 = 15请求/s</li>
<li>平均到浏览器的速率：1.5Mbps</li>
<li>机构内部路由器到原始服务器再返回到路由器的延时（ Internet 延时）= 2s</li>
<li>接入链路带宽：1.54Mbps</li>
<li>局域网带宽：1Gbps</li>
</ul>
<p>结果</p>
<ul>
<li>LAN的流量强度 =（15个请求/s）$\times$ （100kb/请求）/（1Gbps）= 15%</li>
<li>接入链路上的流量强度（15个请求/s）$\times$ （100kb/请求）/（1.54Mbps）=  99%</li>
<li>总延时 = LAN延时 + 接入延时 + Internet 延时 = ms + 分 + 2s，耗时太长，减少耗时可以采用提高宽带的方法</li>
</ul>
<p>利用缓存减少耗时，计算链路利用率，有缓存的延迟</p>
<ul>
<li>假设缓存命中率0.4</li>
<li>40%请求在缓存中被满足，其他60%的请求需要被原始服务器满足</li>
</ul>
<p>则接入链路利用率</p>
<ul>
<li>60%的请求采用接入链路</li>
<li>流量强度=（15个请求/s）$\times$ （100kb/请求）$\times$ 0,6/1.54 =0.58，则排队延时为毫秒级</li>
<li>总体延迟= 0.6 * (从原始服务器获取对象的延迟) +0.4 * (从缓存获取对象的延迟) = 0.6$\times$(10ms+排队延时+2s) + 0.4$\times$(毫秒级)  $\approx$1.2s</li>
<li>比安装154Mbps链路延时小且比较便宜</li>
</ul>
<h3 id="条件GET方法"><a href="#条件GET方法" class="headerlink" title="条件GET方法"></a>条件GET方法</h3><p>目标：若缓存器中的对象拷贝是最新的，就不要发送对象</p>
<p>缓存器: 在HTTP请求中指定缓存拷贝的日期<img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210807165731990.png" alt="image-20210807165731990"></p>
<p>服务器: 如果缓存拷贝陈旧，则响应报文没包含对象<img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210807165752140.png" alt="image-20210807165752140"></p>
<p><br><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210807165843009.png" alt="image-20210807165843009"></p>
<h2 id="FTP-文件传输协议"><a href="#FTP-文件传输协议" class="headerlink" title="FTP(文件传输协议)"></a>FTP(文件传输协议)</h2><p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210807170120401.png" alt="image-20210807170120401"></p>
<ul>
<li>向远程主机上传输文件或从远程主机接收文件</li>
<li>客户/服务器模式<ul>
<li>客户端：发起传输的一方</li>
<li>服务器：远程主机</li>
</ul>
</li>
<li>FTP：RFC 959</li>
<li>FTP服务器：端口号为21</li>
</ul>
<p>FTP：控制连接与数据连接分开</p>
<ul>
<li>FTP客户端与FTP服务器通过端口21联系，并使用TCP为传输协议</li>
<li>客户端通过控制连接获得身份确认</li>
<li>客户端通过控制连接发送命令浏览远程目录</li>
<li>收到一个文件传输命令时，服务器主动打开一个到客户端的数据连接</li>
<li>一个文件传输完成后，服务器关闭连接</li>
<li>服务器打开第二个TCP数据连接用来传输另一个文件</li>
<li>控制连接： 带外（ “out of band”  ）传送，传指令或者控制信息</li>
<li>FTP服务器维护用户的状态信息：当前路径、用户帐户与控制连接对应</li>
<li>有状态协议，服务器需要维护客户端状态</li>
</ul>
<p>FTP命令、响应</p>
<p>命令样例</p>
<ul>
<li>在控制连接上以ASCII文本方式传送</li>
<li>USER username</li>
<li>PASS password</li>
<li>LIST：请服务器返回远程主机当前目录的文件列表</li>
<li>RETR filename：从远程主机的当前目录检索文件 (gets)，下载</li>
<li>STOR filename：向远程主机的当前目录存放文件 (puts)，上载</li>
</ul>
<p>返回码样例</p>
<ul>
<li>状态码和状态信息 (同HTTP)</li>
<li>331 Username OK,  password required</li>
<li>125 data connection  already open;  transfer starting</li>
<li>425 Can’t open data  connection</li>
<li>452 Error writing  file</li>
</ul>
<h2 id="E-mail-电子邮件"><a href="#E-mail-电子邮件" class="headerlink" title="E-mail(电子邮件)"></a>E-mail(电子邮件)</h2><h3 id="主要组成部分"><a href="#主要组成部分" class="headerlink" title="主要组成部分"></a>主要组成部分</h3><ul>
<li><p>用户代理</p>
<blockquote>
<p>又名 “邮件阅读器” </p>
<p>撰写、编辑和阅读邮件</p>
<p>如Outlook、Foxmail</p>
<p>输出和输入邮件保存在服务器上</p>
</blockquote>
</li>
<li><p>邮件服务器</p>
<blockquote>
<p>邮箱中管理和维护发送给用户的邮件</p>
<p>输出报文队列保持待发送邮件报文</p>
<p>邮件服务器之间的SMTP协议：发送email报文</p>
<ul>
<li>客户：发送方邮件服务器</li>
<li>服务器：接收端邮件服务器</li>
</ul>
</blockquote>
</li>
<li><p>简单邮件传输协议：SMTP</p>
<blockquote>
<p>使用TCP在客户端和服务器之间传送报文，端口号为25</p>
<p>直接传输：从发送方服务器到接收方服务器</p>
<p>传输的3个阶段</p>
<ul>
<li>握手</li>
<li>传输报文</li>
<li>关闭</li>
</ul>
<p>命令/响应交互</p>
<ul>
<li>命令：ASCII文本</li>
<li>响应：状态码和状态信息</li>
</ul>
<p>报文必须为7位ASCII码</p>
<p>SMTP使用持久连接</p>
<p>SMTP要求报文（首部和主体）为7位ASCII编码</p>
<p>SMTP服务器使用 CRLF.CRLF决定报文的尾部</p>
<p>与HTTP比较</p>
<ul>
<li>HTTP：拉（pull）</li>
<li>SMTP：推（push）</li>
<li>二者都是ASCII形式的命令/响应交互、状态码</li>
<li>HTTP：每个对象封装在各自的响应报文中</li>
<li>SMTP：多个对象包含在一个报文中</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="邮件报文格式"><a href="#邮件报文格式" class="headerlink" title="邮件报文格式"></a>邮件报文格式</h3><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/未命名文件.png" alt="未命名文件" style="zoom: 67%;">

<p>首部行：如</p>
<ul>
<li>To:</li>
<li>From:</li>
<li>Subject</li>
<li>与SMTP命令不同</li>
</ul>
<p>主体</p>
<ul>
<li>报文，只能是ASCII码字符</li>
</ul>
<p>报文格式：多媒体扩展，类似编码和解码</p>
<ul>
<li><p>MIME：多媒体邮件扩展（multimedia mail extension）, RFC 2045, 2056</p>
</li>
<li><p>在报文首部用额外的行申明MIME内容类型</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">From: alice@crepes.fr </span><br><span class="line"><span class="keyword">To</span>: bob@hamburger.edu </span><br><span class="line">Subject: Picture of yummy crepe. </span><br><span class="line">MIME<span class="params">-Version</span>: <span class="number">1.0</span> 								MIME版本</span><br><span class="line">Content<span class="params">-Transfer</span><span class="params">-Encoding</span>: base64 				数据的编码方式，如base64</span><br><span class="line">Content<span class="params">-Type</span>: image/jpeg 						多媒体数据类型、子类型和参数申明</span><br><span class="line">base64 encoded <span class="built_in">data</span> <span class="params">...</span>.. 						编码好的数据</span><br><span class="line"><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span>. </span><br><span class="line"><span class="params">...</span><span class="params">...</span>base64 encoded <span class="built_in">data</span> </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h3><p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210807174408797.png" alt="image-20210807174408797"></p>
<ul>
<li>SMTP: 传送到接收方的邮件服务器</li>
<li>邮件访问协议：从服务器访问邮件<ul>
<li>POP：邮局访问协议（Post Office Protocol）[RFC 1939]<ul>
<li>用户身份确认 (代理&lt;–&gt;服务器) 并下载</li>
</ul>
</li>
<li>IMAP：Internet邮件访问协议（Internet Mail Access  Protocol）[RFC 1730]<ul>
<li>更多特性 (更复杂)</li>
<li>在服务器上处理存储的报文</li>
</ul>
</li>
<li>HTTP：Hotmail , Yahoo! Mail等<ul>
<li>方便</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="POP3协议"><a href="#POP3协议" class="headerlink" title="POP3协议"></a>POP3协议</h4><p>用户特许阶段</p>
<ul>
<li>客户端命令<ul>
<li>user: 申明用户名</li>
<li>pass: 口令</li>
</ul>
</li>
<li>服务器响应<ul>
<li>+OK，指示前面的命令正常</li>
<li>-ERR ，指示前面的命令出现错误</li>
</ul>
</li>
</ul>
<p>事物处理阶段, 客户端</p>
<ul>
<li>list：报文号列表</li>
<li>retr：根据报文号检索报文</li>
<li>dele：删除</li>
<li>quit</li>
</ul>
<p>更新阶段</p>
<ul>
<li>在客户端发出quit命令后，结束POP3会话</li>
<li>邮件服务器删除被标记的报文</li>
</ul>
<p>用户代理方式</p>
<ul>
<li>“ 下载并删除”模式<ul>
<li>如果改变客户机，用户不能阅读邮件</li>
</ul>
</li>
<li>“下载并保留”模式<ul>
<li>不同客户机上为报文的拷贝</li>
</ul>
</li>
</ul>
<p>POP3在会话中是无状态的</p>
<p>POP3访问后，本地下载邮件，是在本地管理文件夹</p>
<h4 id="IMAP协议"><a href="#IMAP协议" class="headerlink" title="IMAP协议"></a>IMAP协议</h4><p>IMAP服务器将每个报文与一个文件夹联系起来</p>
<p>允许用户用目录来组织报文</p>
<p>允许用户读取报文组件</p>
<p>IMAP在会话过程中维护用户状态</p>
<ul>
<li>目录名、报文ID与目录名之间映射</li>
</ul>
<p>IMAP是远程管理文件夹</p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS（Domain Name System，域名系统）：因特网的目录服务</p>
<p>DNS的必要性</p>
<ul>
<li>IP地址标识主机、路由器便于解析，但IP地址较于字符串不好记忆，不便人类使用（没有意义）</li>
<li>则存在着字符串—IP地址转换的必要性</li>
<li>人类用户提供要访问机器的字符串名称，由DNS负责转换成为二进制的网络地址</li>
</ul>
<p>DNS的主要思路</p>
<ul>
<li>分层的、基于域的命名机制</li>
<li>若干分布式的数据库完成名字到IP地址的转换</li>
<li>运行在UDP之上端口号为<strong>53</strong>的应用服务</li>
<li>核心的Internet功能，但以应用层协议实现<ul>
<li>在网络边缘处理复杂性</li>
</ul>
</li>
</ul>
<p>DNS主要目的</p>
<ul>
<li>实现主机名-IP地址的转换(name/IP translate) </li>
<li>其它目的<ul>
<li>主机别名到规范主机名的转换（Host aliasing）</li>
<li>邮件服务器别名到邮件服务器的正规名字的转换（Mail server  aliasing）</li>
<li>负载均衡（Load Distribution）</li>
</ul>
</li>
</ul>
<p>DNS工作过程</p>
<ul>
<li>DNS应用调用解析器（resolver）</li>
<li>解析器作为客户向Name Server发出查询报文（封装在UDP段中）</li>
<li>Name Server返回响应报文（name/ip）</li>
</ul>
<p>DNS系统需要解决的问题</p>
<ol>
<li>如何命名设备<ul>
<li>用有意义的字符串：好记，便于人类使用</li>
<li>解决一个平面命名的重名问题：层次化命名</li>
</ul>
</li>
<li>如何完成名字到IP地址的转换<ul>
<li>分布式的数据库维护和响应名字查询</li>
</ul>
</li>
<li>如何维护：增加或者删除一个域，需要在域名系统中做哪些工作</li>
</ol>
<h3 id="DNS域名结构"><a href="#DNS域名结构" class="headerlink" title="DNS域名结构"></a>DNS域名结构</h3><p>一个层面命名设备会有很多重名</p>
<p>DNS采用层次树状结构的命名方法，树叶是主机</p>
<p>Internet 根被划为几百个顶级域（top lever domains）</p>
<ul>
<li>通用的(generic) <ul>
<li>.com; .edu ; .gov ; .int ; .mil ; .net ; .org ; .firm ; .hsop ; .web ; .arts ; .rec</li>
</ul>
</li>
<li>国家的(countries)<ul>
<li>.cn ; .us ; .nl ; .jp</li>
</ul>
</li>
</ul>
<p> 每个（子）域下面可划分为若干子域（subdomains）</p>
<p><strong>DNS名字空间</strong></p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210809082016756.png" alt="image-20210809082016756"></p>
<p>域名(Domain Name)</p>
<ul>
<li>从本域往上，直到树根</li>
<li>中间使用“.”间隔不同的级别</li>
<li>例如<ul>
<li>ustc.edu.cn</li>
<li>auto.ustc.edu.cn</li>
<li><a href="http://www.auto/">www.auto</a>. ustc.edu.cn</li>
</ul>
</li>
<li>域的域名：可以用于表示一个域</li>
<li>主机的域名：一个域上的一个主机</li>
</ul>
<p>域名的管理</p>
<ul>
<li>一个域管理其下的子域，如 .jp 被划分为 ac.jp co.jp    .cn 被划分为 edu.cn com.cn</li>
<li>创建一个新的域，必须征得它所属域的同意</li>
</ul>
<p>域与物理网络无关</p>
<ul>
<li>域遵从组织界限，而不是物理网络<ul>
<li>一个域的主机可以不在一个网络</li>
<li>一个网络的主机不一定在一个域</li>
</ul>
</li>
<li>域的划分是逻辑的，而不是物理的</li>
</ul>
<p>​    </p>
<h3 id="名字服务器（Name-Server）"><a href="#名字服务器（Name-Server）" class="headerlink" title="名字服务器（Name Server）"></a>名字服务器（Name Server）</h3><p>单个名字服务器存在的问题</p>
<ul>
<li>可靠性问题：单点故障</li>
<li>扩展性问题：通信容量</li>
<li>维护问题：远距离的集中式数据库</li>
</ul>
<p>区域（zone）</p>
<ul>
<li>区域的划分由区域管理者自己决定</li>
<li>将DNS名字空间划分为互不相交的区域，每个区域都是树的一部分</li>
<li>名字服务器<ul>
<li>每个区域都有一个名字服务器：维护着它所管辖区域的<strong>权威信息</strong>（authoritative record）</li>
<li>名字服务器允许被放置在区域之外，以保障可靠性</li>
<li>区域名字服务器维护<strong>资源记录</strong></li>
</ul>
</li>
</ul>
<p>权威DNS服务器：组织机构的DNS服务器， 提供组织机构服务器（如 Web和mail）可访问的主机和IP之间的映射</p>
<ul>
<li>组织机构可以选择实现自己维护或由某个服务提供商来维护</li>
</ul>
<p>顶级域(TLD)服务器：负责顶级域名（如com, org, net,  edu和gov）和所有国家级的顶级域名（如cn, uk, fr, ca,  jp ）</p>
<ul>
<li>Network solutions 公司维护com TLD服务器</li>
<li>Educause公司维护edu TLD服务</li>
</ul>
<p>根DNS服务器：提供TLD服务器的IP地址</p>
<ul>
<li>有400多个，有13个不同的组织管理</li>
</ul>
<p>本地名字服务器（Local Name Server）</p>
<ul>
<li>并不严格属于层次结构</li>
<li>每个ISP（居民区的ISP、公司、大学）都有一个本地DNS服务器</li>
<li>也称为“默认名字服务器” </li>
<li>当一个主机发起一个DNS查询时，查询被送到其本地DNS服务器<ul>
<li>起着代理的作用，将查询转发到层次结构中</li>
</ul>
</li>
</ul>
<p>名字解析过程</p>
<ul>
<li><p>目标名字在Local Name Server中</p>
<ul>
<li>情况1：查询的名字在该区域内部</li>
<li>情况2：存在缓存（cashing），直接将缓存信息返回</li>
</ul>
</li>
<li><p>递归查询</p>
<ul>
<li>名字解析负担都放在当前联络的名字服务器上</li>
<li>问题：根服务器的负担太重</li>
<li>解决：迭代查询 (iterated  queries)</li>
</ul>
<img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210810091220582.png" alt="image-20210810091220582" style="zoom:80%;"></li>
<li><p>迭代查询</p>
<ul>
<li><p>根（及各级域名）服务器返回的不是查询结果，而是下一个NS的地址</p>
</li>
<li><p>最后由权威名字服务器给出解析结果</p>
</li>
<li><p>当前联络的服务器给出可以联系的服务器的名字</p>
<img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210810091602444.png" alt="image-20210810091602444" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<p>提高性能：缓存</p>
<ul>
<li>一旦名字服务器学到了一个映射，就将该映射缓存起来</li>
<li>根服务器通常都在本地服务器中缓存着<ul>
<li>使得根服务器不用经常被访问</li>
</ul>
</li>
<li>目的：提高效率</li>
<li>可能存在的问题：如果情况变化，缓存结果和权威资源记录不一致<ul>
<li>解决方案：TTL（默认2天）</li>
</ul>
</li>
</ul>
<h3 id="DNS记录和报文"><a href="#DNS记录和报文" class="headerlink" title="DNS记录和报文"></a>DNS记录和报文</h3><p>资源记录（resource records，RR）</p>
<ul>
<li><p>作用：维护 域名-IP地址（其它）的映射关系</p>
</li>
<li><p>位置：Name Server的分布式数据库中</p>
</li>
<li><p>RR格式：(name, value, type, TTL)</p>
<ul>
<li><p>Domain_name：域名</p>
</li>
<li><p>TTL（time to live）：生存时间，决定了资源记录应当从缓存中删除的时间（若维护的是权威信息，则是长期的；若为缓冲记录，则是短期的，基本为2天）</p>
</li>
<li><p>Class 类别：对于Internet，值为IN</p>
</li>
<li><p>Value 值：可以是数字，域名或ASCII串</p>
</li>
<li><p>Type 类别：资源记录的类型</p>
<blockquote>
<p>Type=A</p>
<ul>
<li>Name 为主机</li>
<li>Value 为IP地址</li>
</ul>
<p>Type=CNAME</p>
<ul>
<li>Name 为规范名字的别名</li>
<li>value 为规范名字</li>
</ul>
<p>Type=MX</p>
<ul>
<li>Value为name对应的邮件服务器的名字</li>
</ul>
<p>Type=NS</p>
<ul>
<li>Name域名(如foo.com)</li>
<li>Value为该域名的权威服务器的域名</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>DNS协议：查询和响应报文的报文格式相同</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210810092204307.png" alt="image-20210810092204307"></p>
<ul>
<li>标识符（ID）：16位</li>
<li>flags<ul>
<li>查询（0）/应答（1）</li>
<li>希望递归</li>
<li>递归可用</li>
<li>应答为权威</li>
</ul>
</li>
</ul>
<p>维护问题：新增一个域</p>
<ul>
<li>在上级域的名字服务器中增加两条记录，指向这个新增的子域的域名和域名服务器的地址</li>
<li>在新增子域的名字服务器上运行名字服务器，负责本域的名字解析： 名字-&gt;IP地址</li>
</ul>
<p>例子：在com域中建立一个“Network Utopia” </p>
<ul>
<li>到注册登记机构注册域名networkutopia.com<ul>
<li>需要向该机构提供权威DNS服务器（基本的、和辅助的）的名字和IP地址</li>
<li>登记机构在com TLD服务器中插入两条RR记录<ul>
<li>(networkutopia.com, dns1.networkutopia.com, NS) </li>
<li>(dns1.networkutopia.com, 212.212.212.1, A) </li>
</ul>
</li>
</ul>
</li>
<li>在networkutopia.com的权威服务器中确保有<ul>
<li>用于Web服务器的<a href="http://www.networkuptopia.com的类型为a的记录/">www.networkuptopia.com的类型为A的记录</a></li>
<li>用于邮件服务器mail.networkutopia.com的类型为MX的记录</li>
</ul>
</li>
</ul>
<h3 id="DNS安全性"><a href="#DNS安全性" class="headerlink" title="DNS安全性"></a>DNS安全性</h3><p>分布式拒绝服务（DDoS）带宽洪泛攻击</p>
<ul>
<li>对根服务器进行流量轰炸攻击：发送大量ping<ul>
<li>没有成功</li>
<li>原因１：根目录服务器配置 了流量过滤器，防火墙</li>
<li>原因２：Local DNS 服务器缓存了TLD服务器的IP地址,  因此无需查询根服务器</li>
</ul>
</li>
<li>向TLD服务器流量轰炸攻击：发送大量查询<ul>
<li>效果一般，大部分DNS缓存了TLD</li>
</ul>
</li>
</ul>
<p>重定向攻击</p>
<ul>
<li><p>中间人攻击</p>
<ul>
<li>截获查询，伪造回答，从而攻击某个（DNS回答指定的IP）站点</li>
</ul>
</li>
<li><p>DNS中毒</p>
<ul>
<li>发送伪造的应答给DNS服务器，希望它能够缓存这个虚假的结果</li>
</ul>
</li>
<li><p>技术上较困难：分布式截获和伪造</p>
</li>
</ul>
<p>利用DNS基础设施进行DDoS</p>
<ul>
<li><p>伪造某个IP进行查询， 攻击这个目标IP</p>
</li>
<li><p>查询放大，响应报文比查询报文大</p>
</li>
<li><p>效果有限</p>
<p>总的说来，DNS比较健壮</p>
</li>
</ul>
<h2 id="P2P文件分发"><a href="#P2P文件分发" class="headerlink" title="P2P文件分发"></a>P2P文件分发</h2><p>纯P2P架构</p>
<ul>
<li>没有（或极少）一直运行的服务器</li>
<li>任意端系统都可以直接通信</li>
<li>利用peer的服务能力</li>
<li>Peer节点间歇上网，每次IP地址都有可能变化</li>
<li>例子<ul>
<li>文件分发 （BitTorrent）</li>
<li>流媒体</li>
<li>VoIP（Skype）</li>
</ul>
</li>
</ul>
<h3 id="P2P的扩展性"><a href="#P2P的扩展性" class="headerlink" title="P2P的扩展性"></a>P2P的扩展性</h3><p>例：从一台服务器分发文件（大小F）到N个peer，耗时D</p>
<ul>
<li><p>C/S模式：$D_{CS}\geq\max&lt;!–swig￼8–&gt;}}$</p>
</li>
<li><p>P2P模式：$D_{P2P}\geq\max{\frac{F}{u_s},\frac{F}{d_{min}},\frac{NF}{u_s+\sum_{i=1}^Nu_i}}$</p>
</li>
</ul>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210811100551734.png" alt="image-20210811100551734"></p>
<p>如图所示，C/S模式随着对等方数量增加，分发时间呈线性增长并且无界，P2P模式最小分发时间不仅总是小于C/S模式的分发时间，且小于任意的对等方数量N，总小于1小时</p>
<p>P2P体系结构的应用具有自扩展性</p>
<h3 id="P2P管理模式"><a href="#P2P管理模式" class="headerlink" title="P2P管理模式"></a>P2P管理模式</h3><ul>
<li><p>非结构化P2P：节点与节点之间的关系是任意的</p>
<ul>
<li><p>集中式目录：文件传输是分散的， 而定位内容是高度集中的</p>
<ul>
<li>存在的问题：单点故障；性能瓶颈；侵犯版权</li>
</ul>
</li>
<li><p>查询洪泛：Gnutella</p>
<ul>
<li><p>全分布式：没有中心服务器</p>
</li>
<li><p>开放文件共享协议</p>
</li>
<li><p>许多Gnutella客户端实现了Gnutella协议</p>
<blockquote>
<p>Gnutella：协议</p>
<ul>
<li><p>在已有的TCP连接上发送查询报文</p>
</li>
<li><p>对等方转发查询报文</p>
</li>
<li><p>以反方向返回查询命中报文</p>
<img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/image-20210812150238651.png" alt="image-20210812150238651" style="zoom:67%;"></li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>利用不匀称性：KaZaA</p>
<blockquote>
<p>KaZaA：查询</p>
<ul>
<li>每个文件有一个散列标识码和一个描述符</li>
<li>客户端向其组长发送关键字查询</li>
<li>组长用匹配进行响应<ul>
<li>对每个匹配：元数据、散列标识码和IP地址</li>
</ul>
</li>
<li>如果组长将查询转发给其他组长，其他组长也以匹配进行响应</li>
<li>客户端选择要下载的文件<ul>
<li>向拥有文件的对等方发送一个带散列标识码的HTTP请求</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>DHT（分布式散列表）结构化P2P：overlay（覆盖网，逻辑网络）是有序的</p>
<ul>
<li>哈希表</li>
<li>DHT方案</li>
<li>环形DHT以及覆盖网络</li>
<li>Peer波动</li>
</ul>
</li>
</ul>
<h4 id="BitTorrent-https-www-bilibili-com-video-BV1JV411t7ow-p-18"><a href="#BitTorrent-https-www-bilibili-com-video-BV1JV411t7ow-p-18" class="headerlink" title="BitTorrent(https://www.bilibili.com/video/BV1JV411t7ow?p=18)"></a>BitTorrent(<a href="https://www.bilibili.com/video/BV1JV411t7ow?p=18">https://www.bilibili.com/video/BV1JV411t7ow?p=18</a>)</h4><ul>
<li>文件被分为一个个块256KB</li>
<li>网络中的这些peers发送接收文件块，相互服务</li>
</ul>
<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><h3 id="因特网视频"><a href="#因特网视频" class="headerlink" title="因特网视频"></a>因特网视频</h3><p>视频：固定速度显示的图像序列</p>
<p>网络视频特点</p>
<ul>
<li>高码率：&gt;10x于音频，高的网络带宽需求</li>
<li>可以被压缩</li>
<li>90%以上的网络流量是视频</li>
</ul>
<p>数字化图像：像素的阵列</p>
<ul>
<li>每个像素被若干bits表示</li>
</ul>
<p>编码：使用图像内和图像间的冗余来降低编码的比特数</p>
<ul>
<li>空间冗余（图像内）</li>
<li>时间冗余（相邻的图像间）</li>
</ul>
<p>编码方式</p>
<ul>
<li>CBR（constant bit  rate）：以固定速率编码</li>
<li>VBR（variable bit  rate）：视频编码速率随时间的变化而变化</li>
</ul>
<h3 id="多媒体流化服务：DASH"><a href="#多媒体流化服务：DASH" class="headerlink" title="多媒体流化服务：DASH"></a>多媒体流化服务：DASH</h3><p>DASH（HTTP的动态适应性流）: Dynamic, Adaptive Streaming over HTTP</p>
<p>服务器</p>
<ul>
<li>将视频文件分割成多个块</li>
<li>每个块独立存储，编码于不同码率（8-10种）</li>
<li>告示文件（manifest file）: 提供不同块的URL</li>
</ul>
<p>客户端</p>
<ul>
<li>先获取告示文件</li>
<li>周期性地测量服务器到客户端的带宽</li>
<li>查询告示文件,在一个时刻请求一个块，HTTP头部指定字节范围</li>
<li>如果带宽足够，选择最大码率的视频块</li>
<li>会话中的不同时刻，可以切换请求不同的编码块 (取决于当时的可用带宽) </li>
</ul>
<p>智能客户端：客户端自适应决定</p>
<ul>
<li>什么时候去请求块 (不至于缓存挨饿，或者溢出)</li>
<li>请求什么编码速率的视频块 (当带宽够用时，请求高质量的视频块)</li>
<li>哪里去请求块 (可以向离自己近的服务器发送URL，或者向高可用带宽的服务器请求) </li>
</ul>
<h3 id="内容分发网（CDN）"><a href="#内容分发网（CDN）" class="headerlink" title="内容分发网（CDN）"></a>内容分发网（CDN）</h3><p>CDN：Content Distribution Networks</p>
<p>服务器如何通过网络向上百万用户同时流化视频内容 (上百万视频内容)?</p>
<p>通过CDN，全网部署缓存节点，存储服务内容，就近为用户提供服务，提高用户体验</p>
<ul>
<li>enter deep：将CDN服务器深入到许多接入网<ul>
<li>更接近用户，数量多，离用户近，高度分布式设计管理困难</li>
<li>如Akamai, 1700个位置</li>
</ul>
</li>
<li>bring home：部署在少数(10个左右)关键位置，如将服务器簇安装于POP附近（离若干1stISP POP较近）<ul>
<li>采用租用线路将服务器簇连接起来</li>
<li>Limelight</li>
</ul>
</li>
</ul>
<p>用户从CDN中请求内容</p>
<ul>
<li>通过DNS重定向到最近的拷贝，请求内容</li>
<li>如果网络路径拥塞，可能选择不同的拷贝</li>
</ul>
<p><strong>集群选择策略</strong>：动态的将客户定向到CDN中的某个服务器集群或数据中心的机制</p>
<h2 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h2><p>应用进程使用传输层提供的服务才能够交换报文，实现应用协议，实现应用</p>
<p>socket：分布式应用进程之间的门，传输层协议提供的端到端服务接口</p>
<p>应用进程使用Socket API访问传输服务</p>
<p>2种传输层服务的socket类型</p>
<ul>
<li>TCP: 可靠的、字节流的服务</li>
<li>UDP: 不可靠（数据UDP数据报）服务</li>
</ul>
<p>套接字：应用进程与端到端传输协议（TCP或UDP）之间的门户</p>
<h3 id="TCP套接字编程"><a href="#TCP套接字编程" class="headerlink" title="TCP套接字编程"></a>TCP套接字编程</h3><p>TCP服务：从一个进程向另一个进程可靠地传输字节流</p>
<p>TCP连接过程：</p>
<p>服务器首先运行，等待连接建立</p>
<ol>
<li><p>服务器进程必须先处于运行状态</p>
<ul>
<li><p><strong>创建</strong>欢迎socket</p>
</li>
<li><p>和本地端口<strong>捆绑</strong></p>
</li>
<li><p>在欢迎socket上阻塞式<strong>等待接收</strong>用户的连接</p>
</li>
</ul>
</li>
</ol>
<p>客户端主动和服务器建立连接</p>
<ol start="2">
<li>创建客户端本地套接字（隐式捆绑到本地port）<ul>
<li>指定服务器进程的IP地址和端口 号，与服务器进程连接</li>
</ul>
</li>
<li>当与客户端连接请求到来时<ul>
<li>服务器接受来自用户端的请求 ，解除阻塞式等待，返回一个新的socket（与欢迎socket不一样），与客户端通信<ul>
<li>允许服务器与多个客户端通信</li>
<li>使用源IP和源端口来区分不同的客户端</li>
</ul>
</li>
</ul>
</li>
<li>连接API调用有效时，客户端与服务器建立了TCP连接</li>
</ol>
<p>![未命名文件 (../../../../../嘉兴学院/大三暑假/计算机网络/第2章/应用层.assets/未命名文件 (1).png)](应用层.assets/未命名文件 (1).png)</p>
<p>TCP Socket编程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//IP地址和port捆绑关系的结构体（标示进程的端节点）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">	<span class="keyword">short</span> sin_family; 					<span class="comment">// AF_INET，地址簇</span></span><br><span class="line">	u_short sin_port; 					<span class="comment">// port</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span> ;</span> 			<span class="comment">// IP address, unsigned long</span></span><br><span class="line">	<span class="keyword">char</span> sin_zero[<span class="number">8</span>]; 					<span class="comment">// align</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//域名和IP地址的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>&#123;</span> </span><br><span class="line">    <span class="keyword">char</span> *h_name;						<span class="comment">//主机域名 </span></span><br><span class="line">	<span class="keyword">char</span> **h_aliases; 					<span class="comment">//二维指针，主机别名</span></span><br><span class="line">	<span class="keyword">int</span> h_addrtype; 					</span><br><span class="line">	<span class="keyword">int</span> h_length;                       <span class="comment">//地址长度</span></span><br><span class="line">	<span class="keyword">char</span> **h_addr_list; 				<span class="comment">//IP地址列表</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> h_addr h_addr_list[0];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">hostent作为调用域名解析函数时的参数</span></span><br><span class="line"><span class="comment">返回后，将IP地址拷贝到 sockaddr_in的IP地址部分</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C语言编程参考资料PPT</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//应用程序客户端</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *                                    //该模块形成python中网络通信基础</span><br><span class="line">serverName = <span class="string">&#x27;servername&#x27;</span>								//使用服务器的主机名，将自动执行DNS lookup得到服务器的IP地址</span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line">clientSocket = socket(AF_INET,SOCK_STREAM)				//创建客户端套接字，第一个参数指定地址簇，AF_INET指示底层网络															 使用IPv4.第二个参数指示该套接字为SOCK_STREAM类型，即为TCP															 套接字，客户端套接字的端口号由OS执行</span><br><span class="line">clientSocket.connect((serverName,serverPort))			//建立TCP连接</span><br><span class="line">sentence = raw_input(<span class="string">&#x27;Input lowercase sentence:&#x27;</span>)		//获取用户输入</span><br><span class="line">clientSocket.send(sentence.encode())					//通过客户的套接字进入TCP连接发送字符串sentence</span><br><span class="line">modifiedSentence = clientSocket.recv(<span class="number">1024</span>)			    //接收来自服务器的数据</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;From Server:&#x27;</span>,modifiedSentence.decode())			//打印数据</span><br><span class="line">clientSocket.close()									//关闭客户套接字，TCP连接</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//应用程序服务器端</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *                                    //导入套接字模块						</span><br><span class="line">serverPort = <span class="number">12000</span>	</span><br><span class="line">serverSocket = socket(AF_INET,SOCK_STREAM)				//服务器创建欢迎套接字</span><br><span class="line">serverSocket.bind((<span class="string">&#x27;&#x27;</span>,serverPort))						//将端口号与套接字关联</span><br><span class="line">serverSocket.listen(<span class="number">1</span>)									//等待并接听客户，定义请求连接的最大数（至少为<span class="number">1</span>）</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The server is ready to receive&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    connectionSocket,addr = serverSocket.accept()		//创建连接套接字，w</span><br><span class="line">    sentence = connectionSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line">    capitalizedSentence = sentence.upper()</span><br><span class="line">    connectionSocket.send(capitalizedSentence.encode())</span><br><span class="line">    connectionSocket.close</span><br></pre></td></tr></table></figure>



<h3 id="UDP套接字编程"><a href="#UDP套接字编程" class="headerlink" title="UDP套接字编程"></a>UDP套接字编程</h3><p>UDP：在客户端和服务器之间没有连接</p>
<ul>
<li>没有握手</li>
<li>发送端在每一个报文中明确地指定目标的IP地址和端口号</li>
<li>服务器必须从收到的分组中提取出发送端的IP地址和端口号</li>
</ul>
<p>UDP: 传送的数据可能乱序，也可能丢失</p>
<p>UDP 为客户端和服务器提供不可靠的字节组的传送服务</p>
<p><img src="/2021/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/UDP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B.png" alt="UDP套接字编程"></p>
<p>UDP Socket编程：客户端的数据经由服务器转化为大写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//应用程序客户端</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *                                    //该模块形成python中网络通信基础</span><br><span class="line">serverName = <span class="string">&#x27;hostname&#x27;</span>									//使用服务器的主机名，将自动执行DNS lookup得到服务器的IP地址</span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line">clientSocket = socket(AF_INET,SOCK_DGRAM)				//创建客户端套接字，第一个参数指定地址簇，AF_INET指示底层网络															 使用IPv4.第二个参数指示该套接字为SOCK_DGRAM类型，即为UDP															套接字，客户端套接字的端口号由OS执行</span><br><span class="line">message = raw_input(<span class="string">&#x27;Input lowercase sentence:&#x27;</span>)		//生成发送报文</span><br><span class="line">clientSocket.sendto(message.encode(),(serverNmae,serverPort))		//发送报文</span><br><span class="line">modifiedMessage,serverAddress = clientSocket.recvfrom(<span class="number">2048</span>)			//接收来自服务器的数据</span><br><span class="line"><span class="built_in">print</span>(modifiedMessage.decode())							//打印数据</span><br><span class="line">clientSocket.close()									//关闭客户套接字</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//应用程序服务器端</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *                                    //导入套接字模块						</span><br><span class="line">serverPort = <span class="number">12000</span>										//整数变量设置未<span class="number">12000</span></span><br><span class="line">serverSocket = socket(AF_INET,SOCK_DGRAM)	</span><br><span class="line">serverSocket.bind((<span class="string">&#x27;&#x27;</span>,serverPort))						//将端口号与服务器套接字绑定</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The server is ready to receive&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:												//循环允许UDPSrever无限期地接收并处理来自客户地分组</span><br><span class="line">    message,clientAddress = serverSocket.recvfrom(<span class="number">2048</span>)	//接收到分组，该分组地数据被放置到变量message中，源地址放置到															 变量clientAddress中。变量clientAddress包含了客户的IP地															址和客户的端口号</span><br><span class="line">    modifiedMseeage = message.decode().upper()			//将报文由decode函数转化为字符串后，获取客户端的行并转换大写</span><br><span class="line">    serverSocket.sendto(modifiedMseeage.encode(),clientAddress) //发送分组，并等待另一个UDP分组到达</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>大学课程</tag>
      </tags>
  </entry>
</search>
